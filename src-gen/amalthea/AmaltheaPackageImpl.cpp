// -*- mode: c++; c-basic-style: "bsd"; c-basic-offset: 4; -*-
/*
 * amalthea/AmaltheaPackageImpl.cpp
 * This file was created by EMF4CPP 2.0.0 and is copyrighted by the
 * respective user and/or provider of the processed ECORE model.
 *
 * EMF4CPP is free software. You can obtain it from
 * https://github.com/catedrasaes-umu/emf4cpp
 */

#include <amalthea/AmaltheaPackage.hpp>
#include <amalthea/AmaltheaFactory.hpp>
#include <ecore.hpp>
#include <ecore/EcorePackage.hpp>
#include <ecore/EClass.hpp>
#include <ecore/EAttribute.hpp>
#include <ecore/EReference.hpp>
#include <ecore/EOperation.hpp>
#include <ecore/EParameter.hpp>
#include <ecore/EEnum.hpp>
#include <ecore/EEnumLiteral.hpp>
#include <ecore/EDataType.hpp>
#include <ecore/EGenericType.hpp>
#include <ecore/ETypeParameter.hpp>
#include <ecore/EcorePackage.hpp>

using namespace ::amalthea;

AmaltheaPackage::AmaltheaPackage()
{

    // Feature definitions of Amalthea
    m_Amalthea__version = ::ecore::Ptr < ::ecore::EAttribute
            > (new ::ecore::EAttribute);
    m_Amalthea__commonElements = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_Amalthea__swModel = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_Amalthea__hwModel = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_Amalthea__osModel = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_Amalthea__stimuliModel = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_Amalthea__eventModel = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_Amalthea__constraintsModel = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_Amalthea__propertyConstraintsModel = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_Amalthea__mappingModel = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_Amalthea__componentsModel = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_Amalthea__configModel = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of CommonElements
    m_CommonElements__tags = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_CommonElements__namespaces = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_CommonElements__coreClassifiers = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_CommonElements__memoryClassifiers = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of BaseObject

    // Feature definitions of ReferableObject

    // Feature definitions of ReferableBaseObject

    // Feature definitions of IAnnotatable
    m_IAnnotatable__customProperties = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of ITaggable
    m_ITaggable__tags = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of INamed
    m_INamed__name = ::ecore::Ptr < ::ecore::EAttribute
            > (new ::ecore::EAttribute);
    m_INamed__qualifiedName = ::ecore::Ptr < ::ecore::EAttribute
            > (new ::ecore::EAttribute);

    // Feature definitions of IReferable
    m_IReferable__uniqueName = ::ecore::Ptr < ::ecore::EAttribute
            > (new ::ecore::EAttribute);

    // Feature definitions of IDisplayName
    m_IDisplayName__displayName = ::ecore::Ptr < ::ecore::EAttribute
            > (new ::ecore::EAttribute);

    // Feature definitions of IDescription
    m_IDescription__description = ::ecore::Ptr < ::ecore::EAttribute
            > (new ::ecore::EAttribute);

    // Feature definitions of INamespaceMember
    m_INamespaceMember__namespace = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of Tag
    m_Tag__tagType = ::ecore::Ptr < ::ecore::EAttribute
            > (new ::ecore::EAttribute);
    m_Tag__taggedObjects = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of Namespace
    m_Namespace__nextSegments = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_Namespace__previousSegment = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_Namespace__memberObjects = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of Classifier

    // Feature definitions of CoreClassifier

    // Feature definitions of MemoryClassifier

    // Feature definitions of TransmissionPolicy
    m_TransmissionPolicy__chunkProcessingTicks = ::ecore::Ptr
            < ::ecore::EAttribute > (new ::ecore::EAttribute);
    m_TransmissionPolicy__transmitRatio = ::ecore::Ptr < ::ecore::EAttribute
            > (new ::ecore::EAttribute);
    m_TransmissionPolicy__chunkSize = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of Quantity

    // Feature definitions of TimeComparable

    // Feature definitions of Time
    m_Time__value = ::ecore::Ptr < ::ecore::EAttribute
            > (new ::ecore::EAttribute);
    m_Time__unit = ::ecore::Ptr < ::ecore::EAttribute
            > (new ::ecore::EAttribute);

    // Feature definitions of Frequency
    m_Frequency__value = ::ecore::Ptr < ::ecore::EAttribute
            > (new ::ecore::EAttribute);
    m_Frequency__unit = ::ecore::Ptr < ::ecore::EAttribute
            > (new ::ecore::EAttribute);

    // Feature definitions of Voltage
    m_Voltage__value = ::ecore::Ptr < ::ecore::EAttribute
            > (new ::ecore::EAttribute);
    m_Voltage__unit = ::ecore::Ptr < ::ecore::EAttribute
            > (new ::ecore::EAttribute);

    // Feature definitions of DataSize
    m_DataSize__value = ::ecore::Ptr < ::ecore::EAttribute
            > (new ::ecore::EAttribute);
    m_DataSize__unit = ::ecore::Ptr < ::ecore::EAttribute
            > (new ::ecore::EAttribute);

    // Feature definitions of DataRateComparable

    // Feature definitions of DataRate
    m_DataRate__value = ::ecore::Ptr < ::ecore::EAttribute
            > (new ::ecore::EAttribute);
    m_DataRate__unit = ::ecore::Ptr < ::ecore::EAttribute
            > (new ::ecore::EAttribute);

    // Feature definitions of CustomProperty
    m_CustomProperty__key = ::ecore::Ptr < ::ecore::EAttribute
            > (new ::ecore::EAttribute);
    m_CustomProperty__value = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of Value

    // Feature definitions of ListObject
    m_ListObject__values = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of StringObject
    m_StringObject__value = ::ecore::Ptr < ::ecore::EAttribute
            > (new ::ecore::EAttribute);

    // Feature definitions of BigIntegerObject
    m_BigIntegerObject__value = ::ecore::Ptr < ::ecore::EAttribute
            > (new ::ecore::EAttribute);

    // Feature definitions of ReferenceObject
    m_ReferenceObject__value = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of IntegerObject
    m_IntegerObject__value = ::ecore::Ptr < ::ecore::EAttribute
            > (new ::ecore::EAttribute);

    // Feature definitions of LongObject
    m_LongObject__value = ::ecore::Ptr < ::ecore::EAttribute
            > (new ::ecore::EAttribute);

    // Feature definitions of FloatObject
    m_FloatObject__value = ::ecore::Ptr < ::ecore::EAttribute
            > (new ::ecore::EAttribute);

    // Feature definitions of DoubleObject
    m_DoubleObject__value = ::ecore::Ptr < ::ecore::EAttribute
            > (new ::ecore::EAttribute);

    // Feature definitions of BooleanObject
    m_BooleanObject__value = ::ecore::Ptr < ::ecore::EAttribute
            > (new ::ecore::EAttribute);

    // Feature definitions of NumericStatistic

    // Feature definitions of MinAvgMaxStatistic
    m_MinAvgMaxStatistic__min = ::ecore::Ptr < ::ecore::EAttribute
            > (new ::ecore::EAttribute);
    m_MinAvgMaxStatistic__avg = ::ecore::Ptr < ::ecore::EAttribute
            > (new ::ecore::EAttribute);
    m_MinAvgMaxStatistic__max = ::ecore::Ptr < ::ecore::EAttribute
            > (new ::ecore::EAttribute);

    // Feature definitions of SingleValueStatistic
    m_SingleValueStatistic__value = ::ecore::Ptr < ::ecore::EAttribute
            > (new ::ecore::EAttribute);

    // Feature definitions of ITimeDeviation

    // Feature definitions of TimeInterval
    m_TimeInterval__lowerBound = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_TimeInterval__upperBound = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of TimeConstant
    m_TimeConstant__value = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of TimeHistogram
    m_TimeHistogram__entries = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of TimeHistogramEntry
    m_TimeHistogramEntry__occurrences = ::ecore::Ptr < ::ecore::EAttribute
            > (new ::ecore::EAttribute);

    // Feature definitions of BoundedTimeDistribution

    // Feature definitions of TruncatedTimeDistribution
    m_TruncatedTimeDistribution__lowerBound = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_TruncatedTimeDistribution__upperBound = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of TimeBoundaries
    m_TimeBoundaries__samplingType = ::ecore::Ptr < ::ecore::EAttribute
            > (new ::ecore::EAttribute);

    // Feature definitions of TimeStatistics
    m_TimeStatistics__average = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of TimeUniformDistribution

    // Feature definitions of TimeGaussDistribution
    m_TimeGaussDistribution__mean = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_TimeGaussDistribution__sd = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of TimeWeibullEstimatorsDistribution
    m_TimeWeibullEstimatorsDistribution__pRemainPromille = ::ecore::Ptr
            < ::ecore::EAttribute > (new ::ecore::EAttribute);
    m_TimeWeibullEstimatorsDistribution__average = ::ecore::Ptr
            < ::ecore::EReference > (new ::ecore::EReference);

    // Feature definitions of TimeBetaDistribution
    m_TimeBetaDistribution__alpha = ::ecore::Ptr < ::ecore::EAttribute
            > (new ::ecore::EAttribute);
    m_TimeBetaDistribution__beta = ::ecore::Ptr < ::ecore::EAttribute
            > (new ::ecore::EAttribute);

    // Feature definitions of IDiscreteValueDeviation

    // Feature definitions of DiscreteValueInterval
    m_DiscreteValueInterval__lowerBound = ::ecore::Ptr < ::ecore::EAttribute
            > (new ::ecore::EAttribute);
    m_DiscreteValueInterval__upperBound = ::ecore::Ptr < ::ecore::EAttribute
            > (new ::ecore::EAttribute);

    // Feature definitions of DiscreteValueConstant
    m_DiscreteValueConstant__value = ::ecore::Ptr < ::ecore::EAttribute
            > (new ::ecore::EAttribute);

    // Feature definitions of DiscreteValueHistogram
    m_DiscreteValueHistogram__entries = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of DiscreteValueHistogramEntry
    m_DiscreteValueHistogramEntry__occurrences = ::ecore::Ptr
            < ::ecore::EAttribute > (new ::ecore::EAttribute);

    // Feature definitions of BoundedDiscreteValueDistribution

    // Feature definitions of TruncatedDiscreteValueDistribution
    m_TruncatedDiscreteValueDistribution__lowerBound = ::ecore::Ptr
            < ::ecore::EAttribute > (new ::ecore::EAttribute);
    m_TruncatedDiscreteValueDistribution__upperBound = ::ecore::Ptr
            < ::ecore::EAttribute > (new ::ecore::EAttribute);

    // Feature definitions of DiscreteValueBoundaries
    m_DiscreteValueBoundaries__samplingType = ::ecore::Ptr < ::ecore::EAttribute
            > (new ::ecore::EAttribute);

    // Feature definitions of DiscreteValueStatistics
    m_DiscreteValueStatistics__average = ::ecore::Ptr < ::ecore::EAttribute
            > (new ::ecore::EAttribute);

    // Feature definitions of DiscreteValueUniformDistribution

    // Feature definitions of DiscreteValueGaussDistribution
    m_DiscreteValueGaussDistribution__mean = ::ecore::Ptr < ::ecore::EAttribute
            > (new ::ecore::EAttribute);
    m_DiscreteValueGaussDistribution__sd = ::ecore::Ptr < ::ecore::EAttribute
            > (new ::ecore::EAttribute);

    // Feature definitions of DiscreteValueWeibullEstimatorsDistribution
    m_DiscreteValueWeibullEstimatorsDistribution__average = ::ecore::Ptr
            < ::ecore::EAttribute > (new ::ecore::EAttribute);
    m_DiscreteValueWeibullEstimatorsDistribution__pRemainPromille = ::ecore::Ptr
            < ::ecore::EAttribute > (new ::ecore::EAttribute);

    // Feature definitions of DiscreteValueBetaDistribution
    m_DiscreteValueBetaDistribution__alpha = ::ecore::Ptr < ::ecore::EAttribute
            > (new ::ecore::EAttribute);
    m_DiscreteValueBetaDistribution__beta = ::ecore::Ptr < ::ecore::EAttribute
            > (new ::ecore::EAttribute);

    // Feature definitions of IContinuousValueDeviation

    // Feature definitions of ContinuousValueInterval
    m_ContinuousValueInterval__lowerBound = ::ecore::Ptr < ::ecore::EAttribute
            > (new ::ecore::EAttribute);
    m_ContinuousValueInterval__upperBound = ::ecore::Ptr < ::ecore::EAttribute
            > (new ::ecore::EAttribute);

    // Feature definitions of ContinuousValueConstant
    m_ContinuousValueConstant__value = ::ecore::Ptr < ::ecore::EAttribute
            > (new ::ecore::EAttribute);

    // Feature definitions of ContinuousValueHistogram
    m_ContinuousValueHistogram__entries = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of ContinuousValueHistogramEntry
    m_ContinuousValueHistogramEntry__occurrences = ::ecore::Ptr
            < ::ecore::EAttribute > (new ::ecore::EAttribute);

    // Feature definitions of BoundedContinuousValueDistribution

    // Feature definitions of TruncatedContinuousValueDistribution
    m_TruncatedContinuousValueDistribution__lowerBound = ::ecore::Ptr
            < ::ecore::EAttribute > (new ::ecore::EAttribute);
    m_TruncatedContinuousValueDistribution__upperBound = ::ecore::Ptr
            < ::ecore::EAttribute > (new ::ecore::EAttribute);

    // Feature definitions of ContinuousValueBoundaries
    m_ContinuousValueBoundaries__samplingType = ::ecore::Ptr
            < ::ecore::EAttribute > (new ::ecore::EAttribute);

    // Feature definitions of ContinuousValueStatistics
    m_ContinuousValueStatistics__average = ::ecore::Ptr < ::ecore::EAttribute
            > (new ::ecore::EAttribute);

    // Feature definitions of ContinuousValueUniformDistribution

    // Feature definitions of ContinuousValueGaussDistribution
    m_ContinuousValueGaussDistribution__mean = ::ecore::Ptr
            < ::ecore::EAttribute > (new ::ecore::EAttribute);
    m_ContinuousValueGaussDistribution__sd = ::ecore::Ptr < ::ecore::EAttribute
            > (new ::ecore::EAttribute);

    // Feature definitions of ContinuousValueWeibullEstimatorsDistribution
    m_ContinuousValueWeibullEstimatorsDistribution__average = ::ecore::Ptr
            < ::ecore::EAttribute > (new ::ecore::EAttribute);
    m_ContinuousValueWeibullEstimatorsDistribution__pRemainPromille =
            ::ecore::Ptr < ::ecore::EAttribute > (new ::ecore::EAttribute);

    // Feature definitions of ContinuousValueBetaDistribution
    m_ContinuousValueBetaDistribution__alpha = ::ecore::Ptr
            < ::ecore::EAttribute > (new ::ecore::EAttribute);
    m_ContinuousValueBetaDistribution__beta = ::ecore::Ptr < ::ecore::EAttribute
            > (new ::ecore::EAttribute);

    // Feature definitions of Mode

    // Feature definitions of NumericMode

    // Feature definitions of EnumMode
    m_EnumMode__literals = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of ModeLiteral
    m_ModeLiteral__containingMode = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of ComponentsModel
    m_ComponentsModel__structures = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_ComponentsModel__systems = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of IComponentContainer
    m_IComponentContainer__components = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of IInterfaceContainer
    m_IInterfaceContainer__interfaces = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of ISystem
    m_ISystem__componentInstances = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_ISystem__connectors = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_ISystem__groundedPorts = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_ISystem__innerPorts = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of ComponentInterface
    m_ComponentInterface__datatype = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_ComponentInterface__subInterfaces = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of MainInterface
    m_MainInterface__version = ::ecore::Ptr < ::ecore::EAttribute
            > (new ::ecore::EAttribute);

    // Feature definitions of SubInterface
    m_SubInterface__containingInterface = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of ComponentPort
    m_ComponentPort__kind = ::ecore::Ptr < ::ecore::EAttribute
            > (new ::ecore::EAttribute);
    m_ComponentPort__containingComponent = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_ComponentPort__interface = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of ComponentStructure
    m_ComponentStructure__structureType = ::ecore::Ptr < ::ecore::EAttribute
            > (new ::ecore::EAttribute);
    m_ComponentStructure__subStructures = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_ComponentStructure__memberObjects = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of IComponentStructureMember
    m_IComponentStructureMember__structure = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of Component
    m_Component__ports = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_Component__processes = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_Component__runnables = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_Component__labels = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_Component__semaphores = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_Component__osEvents = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of Composite

    // Feature definitions of System

    // Feature definitions of ComponentInstance
    m_ComponentInstance__containingSystem = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_ComponentInstance__type = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of Connector
    m_Connector__containingSystem = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_Connector__sourcePort = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_Connector__targetPort = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_Connector__implementedInterfaces = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of InterfaceChannel
    m_InterfaceChannel__key = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_InterfaceChannel__value = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of QualifiedPort
    m_QualifiedPort__instance = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_QualifiedPort__port = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of ConfigModel
    m_ConfigModel__eventsToTrace = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of EventConfig
    m_EventConfig__event = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of ConstraintsModel
    m_ConstraintsModel__eventChains = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_ConstraintsModel__timingConstraints = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_ConstraintsModel__affinityConstraints = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_ConstraintsModel__runnableSequencingConstraints = ::ecore::Ptr
            < ::ecore::EReference > (new ::ecore::EReference);
    m_ConstraintsModel__dataAgeConstraints = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_ConstraintsModel__requirements = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_ConstraintsModel__dataCoherencyGroups = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_ConstraintsModel__dataStabilityGroups = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_ConstraintsModel__physicalSectionConstraints = ::ecore::Ptr
            < ::ecore::EReference > (new ::ecore::EReference);

    // Feature definitions of RunnableSequencingConstraint
    m_RunnableSequencingConstraint__orderType = ::ecore::Ptr
            < ::ecore::EAttribute > (new ::ecore::EAttribute);
    m_RunnableSequencingConstraint__runnableGroups = ::ecore::Ptr
            < ::ecore::EReference > (new ::ecore::EReference);
    m_RunnableSequencingConstraint__processScope = ::ecore::Ptr
            < ::ecore::EReference > (new ::ecore::EReference);

    // Feature definitions of AffinityConstraint

    // Feature definitions of SeparationConstraint

    // Feature definitions of PairingConstraint

    // Feature definitions of ProcessConstraint
    m_ProcessConstraint__target = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of RunnableConstraint
    m_RunnableConstraint__target = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of DataConstraint
    m_DataConstraint__target = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of RunnableSeparationConstraint
    m_RunnableSeparationConstraint__groups = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of ProcessSeparationConstraint
    m_ProcessSeparationConstraint__groups = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of DataSeparationConstraint
    m_DataSeparationConstraint__groups = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of RunnablePairingConstraint
    m_RunnablePairingConstraint__group = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of ProcessPairingConstraint
    m_ProcessPairingConstraint__group = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of DataPairingConstraint
    m_DataPairingConstraint__group = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of RunnableConstraintTarget

    // Feature definitions of ProcessConstraintTarget

    // Feature definitions of DataConstraintTarget

    // Feature definitions of TargetMemory
    m_TargetMemory__memories = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of TargetCore
    m_TargetCore__cores = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of TargetScheduler
    m_TargetScheduler__schedulers = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of LabelGroup

    // Feature definitions of RunnableGroup

    // Feature definitions of ProcessGroup

    // Feature definitions of LabelEntityGroup
    m_LabelEntityGroup__labels = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of RunnableEntityGroup
    m_RunnableEntityGroup__runnables = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of ProcessEntityGroup
    m_ProcessEntityGroup__processes = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of TagGroup
    m_TagGroup__tag = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of AbstractEventChain
    m_AbstractEventChain__itemType = ::ecore::Ptr < ::ecore::EAttribute
            > (new ::ecore::EAttribute);
    m_AbstractEventChain__minItemsCompleted = ::ecore::Ptr < ::ecore::EAttribute
            > (new ::ecore::EAttribute);
    m_AbstractEventChain__stimulus = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_AbstractEventChain__response = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_AbstractEventChain__items = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of EventChain

    // Feature definitions of SubEventChain

    // Feature definitions of EventChainItem

    // Feature definitions of EventChainReference
    m_EventChainReference__eventChain = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of EventChainContainer
    m_EventChainContainer__eventChain = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of TimingConstraint

    // Feature definitions of PhysicalSectionConstraint
    m_PhysicalSectionConstraint__section = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_PhysicalSectionConstraint__memories = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of SynchronizationConstraint
    m_SynchronizationConstraint__multipleOccurrencesAllowed = ::ecore::Ptr
            < ::ecore::EAttribute > (new ::ecore::EAttribute);
    m_SynchronizationConstraint__tolerance = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of EventSynchronizationConstraint
    m_EventSynchronizationConstraint__events = ::ecore::Ptr
            < ::ecore::EReference > (new ::ecore::EReference);

    // Feature definitions of EventChainSynchronizationConstraint
    m_EventChainSynchronizationConstraint__type = ::ecore::Ptr
            < ::ecore::EAttribute > (new ::ecore::EAttribute);
    m_EventChainSynchronizationConstraint__scope = ::ecore::Ptr
            < ::ecore::EReference > (new ::ecore::EReference);

    // Feature definitions of DelayConstraint
    m_DelayConstraint__mappingType = ::ecore::Ptr < ::ecore::EAttribute
            > (new ::ecore::EAttribute);
    m_DelayConstraint__source = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_DelayConstraint__target = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_DelayConstraint__upper = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_DelayConstraint__lower = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of EventChainLatencyConstraint
    m_EventChainLatencyConstraint__type = ::ecore::Ptr < ::ecore::EAttribute
            > (new ::ecore::EAttribute);
    m_EventChainLatencyConstraint__scope = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_EventChainLatencyConstraint__minimum = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_EventChainLatencyConstraint__maximum = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of RepetitionConstraint
    m_RepetitionConstraint__span = ::ecore::Ptr < ::ecore::EAttribute
            > (new ::ecore::EAttribute);
    m_RepetitionConstraint__event = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_RepetitionConstraint__lower = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_RepetitionConstraint__upper = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_RepetitionConstraint__jitter = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_RepetitionConstraint__period = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of DataAgeConstraint
    m_DataAgeConstraint__runnable = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_DataAgeConstraint__label = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_DataAgeConstraint__dataAge = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of DataAge

    // Feature definitions of DataAgeCycle
    m_DataAgeCycle__minimumCycle = ::ecore::Ptr < ::ecore::EAttribute
            > (new ::ecore::EAttribute);
    m_DataAgeCycle__maximumCycle = ::ecore::Ptr < ::ecore::EAttribute
            > (new ::ecore::EAttribute);

    // Feature definitions of DataAgeTime
    m_DataAgeTime__minimumTime = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_DataAgeTime__maximumTime = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of Requirement
    m_Requirement__severity = ::ecore::Ptr < ::ecore::EAttribute
            > (new ::ecore::EAttribute);
    m_Requirement__limit = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of ProcessRequirement
    m_ProcessRequirement__process = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of RunnableRequirement
    m_RunnableRequirement__runnable = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of ArchitectureRequirement
    m_ArchitectureRequirement__component = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of ProcessChainRequirement
    m_ProcessChainRequirement__processChain = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of RequirementLimit
    m_RequirementLimit__limitType = ::ecore::Ptr < ::ecore::EAttribute
            > (new ::ecore::EAttribute);

    // Feature definitions of CPUPercentageRequirementLimit
    m_CPUPercentageRequirementLimit__metric = ::ecore::Ptr < ::ecore::EAttribute
            > (new ::ecore::EAttribute);
    m_CPUPercentageRequirementLimit__limitValue = ::ecore::Ptr
            < ::ecore::EAttribute > (new ::ecore::EAttribute);
    m_CPUPercentageRequirementLimit__hardwareContext = ::ecore::Ptr
            < ::ecore::EReference > (new ::ecore::EReference);

    // Feature definitions of FrequencyRequirementLimit
    m_FrequencyRequirementLimit__metric = ::ecore::Ptr < ::ecore::EAttribute
            > (new ::ecore::EAttribute);
    m_FrequencyRequirementLimit__limitValue = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of PercentageRequirementLimit
    m_PercentageRequirementLimit__metric = ::ecore::Ptr < ::ecore::EAttribute
            > (new ::ecore::EAttribute);
    m_PercentageRequirementLimit__limitValue = ::ecore::Ptr
            < ::ecore::EAttribute > (new ::ecore::EAttribute);

    // Feature definitions of CountRequirementLimit
    m_CountRequirementLimit__metric = ::ecore::Ptr < ::ecore::EAttribute
            > (new ::ecore::EAttribute);
    m_CountRequirementLimit__limitValue = ::ecore::Ptr < ::ecore::EAttribute
            > (new ::ecore::EAttribute);

    // Feature definitions of TimeRequirementLimit
    m_TimeRequirementLimit__metric = ::ecore::Ptr < ::ecore::EAttribute
            > (new ::ecore::EAttribute);
    m_TimeRequirementLimit__limitValue = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of DataCoherencyGroup
    m_DataCoherencyGroup__direction = ::ecore::Ptr < ::ecore::EAttribute
            > (new ::ecore::EAttribute);
    m_DataCoherencyGroup__labels = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_DataCoherencyGroup__scope = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of DataStabilityGroup
    m_DataStabilityGroup__labels = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_DataStabilityGroup__scope = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of DataGroupScope

    // Feature definitions of ProcessScope
    m_ProcessScope__process = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of RunnableScope
    m_RunnableScope__runnable = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of ComponentScope
    m_ComponentScope__component = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of EventModel
    m_EventModel__events = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of Event

    // Feature definitions of EventSet
    m_EventSet__events = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of EntityEvent

    // Feature definitions of TriggerEvent

    // Feature definitions of CustomEvent
    m_CustomEvent__eventType = ::ecore::Ptr < ::ecore::EAttribute
            > (new ::ecore::EAttribute);
    m_CustomEvent__explicitTriggers = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of StimulusEvent
    m_StimulusEvent__entity = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of ProcessEvent
    m_ProcessEvent__eventType = ::ecore::Ptr < ::ecore::EAttribute
            > (new ::ecore::EAttribute);
    m_ProcessEvent__entity = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_ProcessEvent__processingUnit = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of ProcessChainEvent
    m_ProcessChainEvent__eventType = ::ecore::Ptr < ::ecore::EAttribute
            > (new ::ecore::EAttribute);
    m_ProcessChainEvent__entity = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_ProcessChainEvent__processingUnit = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of RunnableEvent
    m_RunnableEvent__eventType = ::ecore::Ptr < ::ecore::EAttribute
            > (new ::ecore::EAttribute);
    m_RunnableEvent__entity = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_RunnableEvent__process = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_RunnableEvent__processingUnit = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of LabelEvent
    m_LabelEvent__eventType = ::ecore::Ptr < ::ecore::EAttribute
            > (new ::ecore::EAttribute);
    m_LabelEvent__entity = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_LabelEvent__runnable = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_LabelEvent__process = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of ChannelEvent
    m_ChannelEvent__eventType = ::ecore::Ptr < ::ecore::EAttribute
            > (new ::ecore::EAttribute);
    m_ChannelEvent__entity = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_ChannelEvent__runnable = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_ChannelEvent__process = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of SemaphoreEvent
    m_SemaphoreEvent__eventType = ::ecore::Ptr < ::ecore::EAttribute
            > (new ::ecore::EAttribute);
    m_SemaphoreEvent__entity = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_SemaphoreEvent__runnable = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_SemaphoreEvent__process = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_SemaphoreEvent__processingUnit = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of ComponentEvent
    m_ComponentEvent__eventType = ::ecore::Ptr < ::ecore::EAttribute
            > (new ::ecore::EAttribute);
    m_ComponentEvent__entity = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of HWModel
    m_HWModel__definitions = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_HWModel__featureCategories = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_HWModel__structures = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_HWModel__domains = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of HwStructure
    m_HwStructure__structureType = ::ecore::Ptr < ::ecore::EAttribute
            > (new ::ecore::EAttribute);
    m_HwStructure__ports = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_HwStructure__structures = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_HwStructure__modules = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_HwStructure__connections = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_HwStructure__innerPorts = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of HwModule
    m_HwModule__ports = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_HwModule__powerDomain = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_HwModule__frequencyDomain = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of HwDomain

    // Feature definitions of FrequencyDomain
    m_FrequencyDomain__clockGating = ::ecore::Ptr < ::ecore::EAttribute
            > (new ::ecore::EAttribute);
    m_FrequencyDomain__defaultValue = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of PowerDomain
    m_PowerDomain__powerGating = ::ecore::Ptr < ::ecore::EAttribute
            > (new ::ecore::EAttribute);
    m_PowerDomain__defaultValue = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of ProcessingUnit
    m_ProcessingUnit__definition = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_ProcessingUnit__accessElements = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_ProcessingUnit__caches = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of Memory
    m_Memory__definition = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_Memory__mappings = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of Cache
    m_Cache__definition = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of HwFeatureCategory
    m_HwFeatureCategory__featureType = ::ecore::Ptr < ::ecore::EAttribute
            > (new ::ecore::EAttribute);
    m_HwFeatureCategory__features = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of HwFeature
    m_HwFeature__value = ::ecore::Ptr < ::ecore::EAttribute
            > (new ::ecore::EAttribute);
    m_HwFeature__containingCategory = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of HwPort
    m_HwPort__bitWidth = ::ecore::Ptr < ::ecore::EAttribute
            > (new ::ecore::EAttribute);
    m_HwPort__priority = ::ecore::Ptr < ::ecore::EAttribute
            > (new ::ecore::EAttribute);
    m_HwPort__portType = ::ecore::Ptr < ::ecore::EAttribute
            > (new ::ecore::EAttribute);
    m_HwPort__portInterface = ::ecore::Ptr < ::ecore::EAttribute
            > (new ::ecore::EAttribute);
    m_HwPort__delegated = ::ecore::Ptr < ::ecore::EAttribute
            > (new ::ecore::EAttribute);
    m_HwPort__connections = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of ConnectionHandler
    m_ConnectionHandler__definition = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_ConnectionHandler__internalConnections = ::ecore::Ptr
            < ::ecore::EReference > (new ::ecore::EReference);

    // Feature definitions of HwConnection
    m_HwConnection__internal = ::ecore::Ptr < ::ecore::EAttribute
            > (new ::ecore::EAttribute);
    m_HwConnection__readLatency = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_HwConnection__writeLatency = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_HwConnection__dataRate = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_HwConnection__port1 = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_HwConnection__port2 = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of HwAccessElement
    m_HwAccessElement__source = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_HwAccessElement__destination = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_HwAccessElement__accessPath = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_HwAccessElement__readLatency = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_HwAccessElement__writeLatency = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_HwAccessElement__dataRate = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of HwDefinition

    // Feature definitions of ProcessingUnitDefinition
    m_ProcessingUnitDefinition__puType = ::ecore::Ptr < ::ecore::EAttribute
            > (new ::ecore::EAttribute);
    m_ProcessingUnitDefinition__features = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_ProcessingUnitDefinition__classifiers = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of ConnectionHandlerDefinition
    m_ConnectionHandlerDefinition__policy = ::ecore::Ptr < ::ecore::EAttribute
            > (new ::ecore::EAttribute);
    m_ConnectionHandlerDefinition__maxBurstSize = ::ecore::Ptr
            < ::ecore::EAttribute > (new ::ecore::EAttribute);
    m_ConnectionHandlerDefinition__maxConcurrentTransfers = ::ecore::Ptr
            < ::ecore::EAttribute > (new ::ecore::EAttribute);
    m_ConnectionHandlerDefinition__readLatency = ::ecore::Ptr
            < ::ecore::EReference > (new ::ecore::EReference);
    m_ConnectionHandlerDefinition__writeLatency = ::ecore::Ptr
            < ::ecore::EReference > (new ::ecore::EReference);
    m_ConnectionHandlerDefinition__dataRate = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of MemoryDefinition
    m_MemoryDefinition__memoryType = ::ecore::Ptr < ::ecore::EAttribute
            > (new ::ecore::EAttribute);
    m_MemoryDefinition__size = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_MemoryDefinition__accessLatency = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_MemoryDefinition__dataRate = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_MemoryDefinition__classifiers = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of CacheDefinition
    m_CacheDefinition__cacheType = ::ecore::Ptr < ::ecore::EAttribute
            > (new ::ecore::EAttribute);
    m_CacheDefinition__writeStrategy = ::ecore::Ptr < ::ecore::EAttribute
            > (new ::ecore::EAttribute);
    m_CacheDefinition__nWays = ::ecore::Ptr < ::ecore::EAttribute
            > (new ::ecore::EAttribute);
    m_CacheDefinition__coherency = ::ecore::Ptr < ::ecore::EAttribute
            > (new ::ecore::EAttribute);
    m_CacheDefinition__exclusive = ::ecore::Ptr < ::ecore::EAttribute
            > (new ::ecore::EAttribute);
    m_CacheDefinition__hitRate = ::ecore::Ptr < ::ecore::EAttribute
            > (new ::ecore::EAttribute);
    m_CacheDefinition__size = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_CacheDefinition__lineSize = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_CacheDefinition__accessLatency = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of HwPath
    m_HwPath__source = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_HwPath__destination = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of HwAccessPath
    m_HwAccessPath__startAddress = ::ecore::Ptr < ::ecore::EAttribute
            > (new ::ecore::EAttribute);
    m_HwAccessPath__endAddress = ::ecore::Ptr < ::ecore::EAttribute
            > (new ::ecore::EAttribute);
    m_HwAccessPath__memOffset = ::ecore::Ptr < ::ecore::EAttribute
            > (new ::ecore::EAttribute);
    m_HwAccessPath__containingAccessElement = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_HwAccessPath__pathElements = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of HwPathElement

    // Feature definitions of HwDestination

    // Feature definitions of MappingModel
    m_MappingModel__addressMappingType = ::ecore::Ptr < ::ecore::EAttribute
            > (new ::ecore::EAttribute);
    m_MappingModel__schedulerAllocation = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_MappingModel__runnableAllocation = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_MappingModel__taskAllocation = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_MappingModel__isrAllocation = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_MappingModel__memoryMapping = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_MappingModel__physicalSectionMapping = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of SchedulerAllocation
    m_SchedulerAllocation__scheduler = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_SchedulerAllocation__responsibility = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_SchedulerAllocation__executingPU = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of TaskAllocation
    m_TaskAllocation__task = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_TaskAllocation__scheduler = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_TaskAllocation__affinity = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_TaskAllocation__schedulingParameters = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_TaskAllocation__parameterExtensions = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of ISRAllocation
    m_ISRAllocation__priority = ::ecore::Ptr < ::ecore::EAttribute
            > (new ::ecore::EAttribute);
    m_ISRAllocation__isr = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_ISRAllocation__controller = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of RunnableAllocation
    m_RunnableAllocation__scheduler = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_RunnableAllocation__entity = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of MemoryMapping
    m_MemoryMapping__memoryPositionAddress = ::ecore::Ptr < ::ecore::EAttribute
            > (new ::ecore::EAttribute);
    m_MemoryMapping__abstractElement = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_MemoryMapping__memory = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of PhysicalSectionMapping
    m_PhysicalSectionMapping__startAddress = ::ecore::Ptr < ::ecore::EAttribute
            > (new ::ecore::EAttribute);
    m_PhysicalSectionMapping__endAddress = ::ecore::Ptr < ::ecore::EAttribute
            > (new ::ecore::EAttribute);
    m_PhysicalSectionMapping__origin = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_PhysicalSectionMapping__memory = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_PhysicalSectionMapping__labels = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_PhysicalSectionMapping__runEntities = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of OSModel
    m_OSModel__semaphores = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_OSModel__operatingSystems = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_OSModel__osOverheads = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of OsDataConsistency
    m_OsDataConsistency__mode = ::ecore::Ptr < ::ecore::EAttribute
            > (new ::ecore::EAttribute);
    m_OsDataConsistency__dataStability = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_OsDataConsistency__nonAtomicDataCoherency = ::ecore::Ptr
            < ::ecore::EReference > (new ::ecore::EReference);

    // Feature definitions of DataStability
    m_DataStability__enabled = ::ecore::Ptr < ::ecore::EAttribute
            > (new ::ecore::EAttribute);
    m_DataStability__algorithm = ::ecore::Ptr < ::ecore::EAttribute
            > (new ::ecore::EAttribute);
    m_DataStability__accessMultiplicity = ::ecore::Ptr < ::ecore::EAttribute
            > (new ::ecore::EAttribute);
    m_DataStability__level = ::ecore::Ptr < ::ecore::EAttribute
            > (new ::ecore::EAttribute);

    // Feature definitions of NonAtomicDataCoherency
    m_NonAtomicDataCoherency__enabled = ::ecore::Ptr < ::ecore::EAttribute
            > (new ::ecore::EAttribute);
    m_NonAtomicDataCoherency__algorithm = ::ecore::Ptr < ::ecore::EAttribute
            > (new ::ecore::EAttribute);
    m_NonAtomicDataCoherency__accessMultiplicity = ::ecore::Ptr
            < ::ecore::EAttribute > (new ::ecore::EAttribute);

    // Feature definitions of Semaphore
    m_Semaphore__semaphoreType = ::ecore::Ptr < ::ecore::EAttribute
            > (new ::ecore::EAttribute);
    m_Semaphore__initialValue = ::ecore::Ptr < ::ecore::EAttribute
            > (new ::ecore::EAttribute);
    m_Semaphore__maxValue = ::ecore::Ptr < ::ecore::EAttribute
            > (new ::ecore::EAttribute);
    m_Semaphore__priorityCeilingProtocol = ::ecore::Ptr < ::ecore::EAttribute
            > (new ::ecore::EAttribute);
    m_Semaphore__semaphoreAccesses = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_Semaphore__referringComponents = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of Scheduler
    m_Scheduler__computationItems = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_Scheduler__schedulerAllocations = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_Scheduler__runnableAllocations = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of TaskScheduler
    m_TaskScheduler__schedulingAlgorithm = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_TaskScheduler__parentAssociation = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_TaskScheduler__childAssociations = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_TaskScheduler__taskAllocations = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_TaskScheduler__parentScheduler = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_TaskScheduler__childSchedulers = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of SchedulerAssociation
    m_SchedulerAssociation__child = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_SchedulerAssociation__parent = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_SchedulerAssociation__schedulingParameters = ::ecore::Ptr
            < ::ecore::EReference > (new ::ecore::EReference);
    m_SchedulerAssociation__parameterExtensions = ::ecore::Ptr
            < ::ecore::EReference > (new ::ecore::EReference);

    // Feature definitions of InterruptController
    m_InterruptController__schedulingAlgorithm = ::ecore::Ptr
            < ::ecore::EReference > (new ::ecore::EReference);
    m_InterruptController__isrAllocations = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of SchedulingParameters
    m_SchedulingParameters__priority = ::ecore::Ptr < ::ecore::EAttribute
            > (new ::ecore::EAttribute);
    m_SchedulingParameters__minBudget = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_SchedulingParameters__maxBudget = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_SchedulingParameters__replenishment = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of ParameterExtension
    m_ParameterExtension__key = ::ecore::Ptr < ::ecore::EAttribute
            > (new ::ecore::EAttribute);
    m_ParameterExtension__value = ::ecore::Ptr < ::ecore::EAttribute
            > (new ::ecore::EAttribute);

    // Feature definitions of Algorithm

    // Feature definitions of InterruptSchedulingAlgorithm

    // Feature definitions of TaskSchedulingAlgorithm

    // Feature definitions of FixedPriority

    // Feature definitions of FixedPriorityPreemptive

    // Feature definitions of FixedPriorityPreemptiveWithBudgetEnforcement

    // Feature definitions of OSEK

    // Feature definitions of DeadlineMonotonic

    // Feature definitions of RateMonotonic

    // Feature definitions of Pfair
    m_Pfair__quantSizeNs = ::ecore::Ptr < ::ecore::EAttribute
            > (new ::ecore::EAttribute);

    // Feature definitions of PfairPD2

    // Feature definitions of PartlyPFairPD2

    // Feature definitions of EarlyReleaseFairPD2

    // Feature definitions of PartlyEarlyReleaseFairPD2

    // Feature definitions of DynamicPriority

    // Feature definitions of LeastLocalRemainingExecutionTimeFirst

    // Feature definitions of EarliestDeadlineFirst

    // Feature definitions of PriorityBasedRoundRobin

    // Feature definitions of ReservationBasedServer

    // Feature definitions of DeferrableServer

    // Feature definitions of PollingPeriodicServer

    // Feature definitions of SporadicServer

    // Feature definitions of ConstantBandwidthServer

    // Feature definitions of ConstantBandwidthServerWithCASH

    // Feature definitions of Grouping

    // Feature definitions of UserSpecificSchedulingAlgorithm
    m_UserSpecificSchedulingAlgorithm__parameterExtensions = ::ecore::Ptr
            < ::ecore::EReference > (new ::ecore::EReference);

    // Feature definitions of PriorityBased

    // Feature definitions of OperatingSystem
    m_OperatingSystem__overhead = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_OperatingSystem__taskSchedulers = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_OperatingSystem__interruptControllers = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_OperatingSystem__osDataConsistency = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of VendorOperatingSystem
    m_VendorOperatingSystem__osName = ::ecore::Ptr < ::ecore::EAttribute
            > (new ::ecore::EAttribute);
    m_VendorOperatingSystem__vendor = ::ecore::Ptr < ::ecore::EAttribute
            > (new ::ecore::EAttribute);
    m_VendorOperatingSystem__version = ::ecore::Ptr < ::ecore::EAttribute
            > (new ::ecore::EAttribute);

    // Feature definitions of OsOverhead
    m_OsOverhead__apiOverhead = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_OsOverhead__isrCategory1Overhead = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_OsOverhead__isrCategory2Overhead = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of OsAPIOverhead
    m_OsAPIOverhead__apiSendMessage = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_OsAPIOverhead__apiTerminateTask = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_OsAPIOverhead__apiSchedule = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_OsAPIOverhead__apiRequestResource = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_OsAPIOverhead__apiReleaseResource = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_OsAPIOverhead__apiSetEvent = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_OsAPIOverhead__apiWaitEvent = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_OsAPIOverhead__apiClearEvent = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_OsAPIOverhead__apiActivateTask = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_OsAPIOverhead__apiEnforcedMigration = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_OsAPIOverhead__apiSuspendOsInterrupts = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_OsAPIOverhead__apiResumeOsInterrupts = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_OsAPIOverhead__apiRequestSpinlock = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_OsAPIOverhead__apiReleaseSpinlock = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_OsAPIOverhead__apiSenderReceiverRead = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_OsAPIOverhead__apiSenderReceiverWrite = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_OsAPIOverhead__apiSynchronousServerCallPoint = ::ecore::Ptr
            < ::ecore::EReference > (new ::ecore::EReference);
    m_OsAPIOverhead__apiIocRead = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_OsAPIOverhead__apiIocWrite = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of OsISROverhead
    m_OsISROverhead__preExecutionOverhead = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_OsISROverhead__postExecutionOverhead = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of PropertyConstraintsModel
    m_PropertyConstraintsModel__allocationConstraints = ::ecore::Ptr
            < ::ecore::EReference > (new ::ecore::EReference);
    m_PropertyConstraintsModel__mappingConstraints = ::ecore::Ptr
            < ::ecore::EReference > (new ::ecore::EReference);

    // Feature definitions of CoreAllocationConstraint
    m_CoreAllocationConstraint__coreClassification = ::ecore::Ptr
            < ::ecore::EReference > (new ::ecore::EReference);

    // Feature definitions of MemoryMappingConstraint
    m_MemoryMappingConstraint__memoryClassification = ::ecore::Ptr
            < ::ecore::EReference > (new ::ecore::EReference);

    // Feature definitions of ProcessAllocationConstraint
    m_ProcessAllocationConstraint__process = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of ProcessPrototypeAllocationConstraint
    m_ProcessPrototypeAllocationConstraint__processPrototype = ::ecore::Ptr
            < ::ecore::EReference > (new ::ecore::EReference);

    // Feature definitions of RunnableAllocationConstraint
    m_RunnableAllocationConstraint__runnable = ::ecore::Ptr
            < ::ecore::EReference > (new ::ecore::EReference);

    // Feature definitions of AbstractElementMappingConstraint
    m_AbstractElementMappingConstraint__abstractElement = ::ecore::Ptr
            < ::ecore::EReference > (new ::ecore::EReference);

    // Feature definitions of Classification
    m_Classification__condition = ::ecore::Ptr < ::ecore::EAttribute
            > (new ::ecore::EAttribute);
    m_Classification__grouping = ::ecore::Ptr < ::ecore::EAttribute
            > (new ::ecore::EAttribute);

    // Feature definitions of CoreClassification
    m_CoreClassification__classifiers = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of MemoryClassification
    m_MemoryClassification__classifiers = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of StimuliModel
    m_StimuliModel__stimuli = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_StimuliModel__clocks = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of Stimulus
    m_Stimulus__setModeValueList = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_Stimulus__executionCondition = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_Stimulus__affectedProcesses = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of ModeValueList
    m_ModeValueList__entries = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of ModeValueMapEntry
    m_ModeValueMapEntry__value = ::ecore::Ptr < ::ecore::EAttribute
            > (new ::ecore::EAttribute);
    m_ModeValueMapEntry__key = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of ModeValue
    m_ModeValue__value = ::ecore::Ptr < ::ecore::EAttribute
            > (new ::ecore::EAttribute);
    m_ModeValue__label = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of ModeAssignment

    // Feature definitions of ModeConditionDisjunction
    m_ModeConditionDisjunction__entries = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of ModeConditionDisjunctionEntry

    // Feature definitions of ModeCondition
    m_ModeCondition__relation = ::ecore::Ptr < ::ecore::EAttribute
            > (new ::ecore::EAttribute);

    // Feature definitions of ModeValueCondition

    // Feature definitions of ModeLabelCondition
    m_ModeLabelCondition__label1 = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_ModeLabelCondition__label2 = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of ModeConditionConjunction
    m_ModeConditionConjunction__entries = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of FixedPeriodic
    m_FixedPeriodic__recurrence = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_FixedPeriodic__offset = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of PeriodicStimulus
    m_PeriodicStimulus__jitter = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_PeriodicStimulus__minDistance = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of RelativePeriodicStimulus
    m_RelativePeriodicStimulus__offset = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_RelativePeriodicStimulus__nextOccurrence = ::ecore::Ptr
            < ::ecore::EReference > (new ::ecore::EReference);

    // Feature definitions of VariableRateStimulus
    m_VariableRateStimulus__maxIncreasePerStep = ::ecore::Ptr
            < ::ecore::EAttribute > (new ::ecore::EAttribute);
    m_VariableRateStimulus__maxDecreasePerStep = ::ecore::Ptr
            < ::ecore::EAttribute > (new ::ecore::EAttribute);
    m_VariableRateStimulus__step = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_VariableRateStimulus__occurrencesPerStep = ::ecore::Ptr
            < ::ecore::EReference > (new ::ecore::EReference);
    m_VariableRateStimulus__scenario = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of Scenario
    m_Scenario__samplingOffset = ::ecore::Ptr < ::ecore::EAttribute
            > (new ::ecore::EAttribute);
    m_Scenario__samplingRecurrence = ::ecore::Ptr < ::ecore::EAttribute
            > (new ::ecore::EAttribute);
    m_Scenario__clock = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of PeriodicSyntheticStimulus
    m_PeriodicSyntheticStimulus__occurrenceTimes = ::ecore::Ptr
            < ::ecore::EReference > (new ::ecore::EReference);

    // Feature definitions of CustomStimulus

    // Feature definitions of SingleStimulus
    m_SingleStimulus__occurrence = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of InterProcessStimulus
    m_InterProcessStimulus__counter = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_InterProcessStimulus__explicitTriggers = ::ecore::Ptr
            < ::ecore::EReference > (new ::ecore::EReference);

    // Feature definitions of PeriodicBurstStimulus
    m_PeriodicBurstStimulus__occurrenceCount = ::ecore::Ptr
            < ::ecore::EAttribute > (new ::ecore::EAttribute);
    m_PeriodicBurstStimulus__burstLength = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_PeriodicBurstStimulus__occurrenceMinDistance = ::ecore::Ptr
            < ::ecore::EReference > (new ::ecore::EReference);

    // Feature definitions of EventStimulus
    m_EventStimulus__triggeringEvents = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_EventStimulus__counter = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of ArrivalCurveStimulus
    m_ArrivalCurveStimulus__entries = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of ArrivalCurveEntry
    m_ArrivalCurveEntry__numberOfOccurrences = ::ecore::Ptr
            < ::ecore::EAttribute > (new ::ecore::EAttribute);
    m_ArrivalCurveEntry__lowerTimeBorder = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_ArrivalCurveEntry__upperTimeBorder = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of Clock

    // Feature definitions of ClockFunction
    m_ClockFunction__curveType = ::ecore::Ptr < ::ecore::EAttribute
            > (new ::ecore::EAttribute);
    m_ClockFunction__period = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_ClockFunction__peakToPeak = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_ClockFunction__xOffset = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_ClockFunction__yOffset = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of ClockStepList
    m_ClockStepList__entries = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_ClockStepList__period = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of ClockStep
    m_ClockStep__frequency = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_ClockStep__time = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of SWModel
    m_SWModel__isrs = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_SWModel__tasks = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_SWModel__runnables = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_SWModel__labels = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_SWModel__channels = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_SWModel__processPrototypes = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_SWModel__sections = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_SWModel__activations = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_SWModel__events = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_SWModel__typeDefinitions = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_SWModel__customEntities = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_SWModel__processChains = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_SWModel__modes = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_SWModel__modeLabels = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of AbstractMemoryElement
    m_AbstractMemoryElement__size = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_AbstractMemoryElement__mappings = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of AbstractProcess
    m_AbstractProcess__referringComponents = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of CustomEntity
    m_CustomEntity__typeName = ::ecore::Ptr < ::ecore::EAttribute
            > (new ::ecore::EAttribute);

    // Feature definitions of ProcessChain
    m_ProcessChain__processes = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of Process
    m_Process__activityGraph = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_Process__stimuli = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of IActivityGraphItemContainer
    m_IActivityGraphItemContainer__items = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of ActivityGraph

    // Feature definitions of ActivityGraphItem
    m_ActivityGraphItem__containingProcess = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_ActivityGraphItem__containingRunnable = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_ActivityGraphItem__containingActivityGraph = ::ecore::Ptr
            < ::ecore::EReference > (new ::ecore::EReference);

    // Feature definitions of ModeSwitch
    m_ModeSwitch__entries = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_ModeSwitch__defaultEntry = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of ModeSwitchEntry
    m_ModeSwitchEntry__condition = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of ModeSwitchDefault

    // Feature definitions of ProbabilitySwitch
    m_ProbabilitySwitch__entries = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of ProbabilitySwitchEntry
    m_ProbabilitySwitchEntry__probability = ::ecore::Ptr < ::ecore::EAttribute
            > (new ::ecore::EAttribute);

    // Feature definitions of Counter
    m_Counter__prescaler = ::ecore::Ptr < ::ecore::EAttribute
            > (new ::ecore::EAttribute);
    m_Counter__offset = ::ecore::Ptr < ::ecore::EAttribute
            > (new ::ecore::EAttribute);

    // Feature definitions of WaitEvent
    m_WaitEvent__maskType = ::ecore::Ptr < ::ecore::EAttribute
            > (new ::ecore::EAttribute);
    m_WaitEvent__waitingBehaviour = ::ecore::Ptr < ::ecore::EAttribute
            > (new ::ecore::EAttribute);
    m_WaitEvent__eventMask = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_WaitEvent__counter = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of SetEvent
    m_SetEvent__eventMask = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_SetEvent__process = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_SetEvent__counter = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of ClearEvent
    m_ClearEvent__eventMask = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_ClearEvent__counter = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of EventMask
    m_EventMask__events = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of OsEvent
    m_OsEvent__communicationOverheadInBit = ::ecore::Ptr < ::ecore::EAttribute
            > (new ::ecore::EAttribute);
    m_OsEvent__referringComponents = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of InterProcessTrigger
    m_InterProcessTrigger__stimulus = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_InterProcessTrigger__counter = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of EnforcedMigration
    m_EnforcedMigration__resourceOwner = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of SchedulePoint

    // Feature definitions of TerminateProcess
    m_TerminateProcess__counter = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of Task
    m_Task__preemption = ::ecore::Ptr < ::ecore::EAttribute
            > (new ::ecore::EAttribute);
    m_Task__multipleTaskActivationLimit = ::ecore::Ptr < ::ecore::EAttribute
            > (new ::ecore::EAttribute);

    // Feature definitions of ISR
    m_ISR__category = ::ecore::Ptr < ::ecore::EAttribute
            > (new ::ecore::EAttribute);

    // Feature definitions of ProcessPrototype
    m_ProcessPrototype__preemption = ::ecore::Ptr < ::ecore::EAttribute
            > (new ::ecore::EAttribute);
    m_ProcessPrototype__firstRunnable = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_ProcessPrototype__lastRunnable = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_ProcessPrototype__accessPrecedenceSpec = ::ecore::Ptr
            < ::ecore::EReference > (new ::ecore::EReference);
    m_ProcessPrototype__orderPrecedenceSpec = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_ProcessPrototype__chainedPrototypes = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_ProcessPrototype__activation = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_ProcessPrototype__runnableCalls = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of ChainedProcessPrototype
    m_ChainedProcessPrototype__apply = ::ecore::Ptr < ::ecore::EAttribute
            > (new ::ecore::EAttribute);
    m_ChainedProcessPrototype__offset = ::ecore::Ptr < ::ecore::EAttribute
            > (new ::ecore::EAttribute);
    m_ChainedProcessPrototype__prototype = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of GeneralPrecedence
    m_GeneralPrecedence__origin = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_GeneralPrecedence__target = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of AccessPrecedenceSpec
    m_AccessPrecedenceSpec__orderType = ::ecore::Ptr < ::ecore::EAttribute
            > (new ::ecore::EAttribute);
    m_AccessPrecedenceSpec__label = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of OrderPrecedenceSpec
    m_OrderPrecedenceSpec__orderType = ::ecore::Ptr < ::ecore::EAttribute
            > (new ::ecore::EAttribute);

    // Feature definitions of IDependsOn
    m_IDependsOn__dependsOn = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of DataDependency
    m_DataDependency__labels = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_DataDependency__parameters = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_DataDependency__callArguments = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_DataDependency__containingRunnable = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of RunnableParameter
    m_RunnableParameter__direction = ::ecore::Ptr < ::ecore::EAttribute
            > (new ::ecore::EAttribute);
    m_RunnableParameter__containingRunnable = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_RunnableParameter__dataType = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of Runnable
    m_Runnable__callback = ::ecore::Ptr < ::ecore::EAttribute
            > (new ::ecore::EAttribute);
    m_Runnable__service = ::ecore::Ptr < ::ecore::EAttribute
            > (new ::ecore::EAttribute);
    m_Runnable__asilLevel = ::ecore::Ptr < ::ecore::EAttribute
            > (new ::ecore::EAttribute);
    m_Runnable__executionCondition = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_Runnable__parameters = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_Runnable__activityGraph = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_Runnable__activations = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_Runnable__section = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_Runnable__runnableCalls = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_Runnable__referringComponents = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of Label
    m_Label__constant = ::ecore::Ptr < ::ecore::EAttribute
            > (new ::ecore::EAttribute);
    m_Label__bVolatile = ::ecore::Ptr < ::ecore::EAttribute
            > (new ::ecore::EAttribute);
    m_Label__dataStability = ::ecore::Ptr < ::ecore::EAttribute
            > (new ::ecore::EAttribute);
    m_Label__stabilityLevel = ::ecore::Ptr < ::ecore::EAttribute
            > (new ::ecore::EAttribute);
    m_Label__dataType = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_Label__section = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_Label__labelAccesses = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_Label__referringComponents = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of Channel
    m_Channel__defaultElements = ::ecore::Ptr < ::ecore::EAttribute
            > (new ::ecore::EAttribute);
    m_Channel__maxElements = ::ecore::Ptr < ::ecore::EAttribute
            > (new ::ecore::EAttribute);
    m_Channel__elementType = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_Channel__channelAccesses = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of ModeLabel
    m_ModeLabel__initialValue = ::ecore::Ptr < ::ecore::EAttribute
            > (new ::ecore::EAttribute);
    m_ModeLabel__mode = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of Section
    m_Section__asilLevel = ::ecore::Ptr < ::ecore::EAttribute
            > (new ::ecore::EAttribute);
    m_Section__labels = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_Section__runnables = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of ComputationItem

    // Feature definitions of ExecutionNeed
    m_ExecutionNeed__needs = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of NeedEntry
    m_NeedEntry__key = ::ecore::Ptr < ::ecore::EAttribute
            > (new ::ecore::EAttribute);
    m_NeedEntry__value = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of Ticks
    m_Ticks__default = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_Ticks__extended = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of TicksEntry
    m_TicksEntry__key = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_TicksEntry__value = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of ModeLabelAccess
    m_ModeLabelAccess__access = ::ecore::Ptr < ::ecore::EAttribute
            > (new ::ecore::EAttribute);
    m_ModeLabelAccess__value = ::ecore::Ptr < ::ecore::EAttribute
            > (new ::ecore::EAttribute);
    m_ModeLabelAccess__step = ::ecore::Ptr < ::ecore::EAttribute
            > (new ::ecore::EAttribute);
    m_ModeLabelAccess__data = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of LabelAccess
    m_LabelAccess__access = ::ecore::Ptr < ::ecore::EAttribute
            > (new ::ecore::EAttribute);
    m_LabelAccess__dataStability = ::ecore::Ptr < ::ecore::EAttribute
            > (new ::ecore::EAttribute);
    m_LabelAccess__implementation = ::ecore::Ptr < ::ecore::EAttribute
            > (new ::ecore::EAttribute);
    m_LabelAccess__data = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_LabelAccess__statistic = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_LabelAccess__transmissionPolicy = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of ChannelAccess
    m_ChannelAccess__elements = ::ecore::Ptr < ::ecore::EAttribute
            > (new ::ecore::EAttribute);
    m_ChannelAccess__data = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_ChannelAccess__transmissionPolicy = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of ChannelSend

    // Feature definitions of ChannelReceive
    m_ChannelReceive__receiveOperation = ::ecore::Ptr < ::ecore::EAttribute
            > (new ::ecore::EAttribute);
    m_ChannelReceive__dataMustBeNew = ::ecore::Ptr < ::ecore::EAttribute
            > (new ::ecore::EAttribute);
    m_ChannelReceive__elementIndex = ::ecore::Ptr < ::ecore::EAttribute
            > (new ::ecore::EAttribute);
    m_ChannelReceive__lowerBound = ::ecore::Ptr < ::ecore::EAttribute
            > (new ::ecore::EAttribute);

    // Feature definitions of SemaphoreAccess
    m_SemaphoreAccess__access = ::ecore::Ptr < ::ecore::EAttribute
            > (new ::ecore::EAttribute);
    m_SemaphoreAccess__waitingBehaviour = ::ecore::Ptr < ::ecore::EAttribute
            > (new ::ecore::EAttribute);
    m_SemaphoreAccess__semaphore = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of SenderReceiverCommunication
    m_SenderReceiverCommunication__buffered = ::ecore::Ptr < ::ecore::EAttribute
            > (new ::ecore::EAttribute);
    m_SenderReceiverCommunication__label = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_SenderReceiverCommunication__port = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of SenderReceiverRead

    // Feature definitions of SenderReceiverWrite
    m_SenderReceiverWrite__notifiedRunnables = ::ecore::Ptr
            < ::ecore::EReference > (new ::ecore::EReference);

    // Feature definitions of ServerCall
    m_ServerCall__serverRunnable = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_ServerCall__port = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of SynchronousServerCall
    m_SynchronousServerCall__waitingBehaviour = ::ecore::Ptr
            < ::ecore::EAttribute > (new ::ecore::EAttribute);

    // Feature definitions of AsynchronousServerCall
    m_AsynchronousServerCall__resultRunnable = ::ecore::Ptr
            < ::ecore::EReference > (new ::ecore::EReference);

    // Feature definitions of GetResultServerCall
    m_GetResultServerCall__blockingType = ::ecore::Ptr < ::ecore::EAttribute
            > (new ::ecore::EAttribute);

    // Feature definitions of Group
    m_Group__ordered = ::ecore::Ptr < ::ecore::EAttribute
            > (new ::ecore::EAttribute);

    // Feature definitions of CallArgument
    m_CallArgument__containingCall = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_CallArgument__parameter = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of RunnableCall
    m_RunnableCall__runnable = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_RunnableCall__arguments = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_RunnableCall__counter = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_RunnableCall__statistic = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of CustomEventTrigger
    m_CustomEventTrigger__event = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of DataType

    // Feature definitions of CompoundType

    // Feature definitions of Struct
    m_Struct__entries = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of StructEntry
    m_StructEntry__dataType = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of Array
    m_Array__numberElements = ::ecore::Ptr < ::ecore::EAttribute
            > (new ::ecore::EAttribute);
    m_Array__dataType = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of Pointer
    m_Pointer__dataType = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of TypeRef
    m_TypeRef__typeDef = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of Alias
    m_Alias__target = ::ecore::Ptr < ::ecore::EAttribute
            > (new ::ecore::EAttribute);
    m_Alias__alias = ::ecore::Ptr < ::ecore::EAttribute
            > (new ::ecore::EAttribute);

    // Feature definitions of TypeDefinition
    m_TypeDefinition__size = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of DataTypeDefinition
    m_DataTypeDefinition__dataType = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of BaseTypeDefinition
    m_BaseTypeDefinition__aliases = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of Activation

    // Feature definitions of PeriodicActivation
    m_PeriodicActivation__min = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_PeriodicActivation__max = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_PeriodicActivation__recurrence = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_PeriodicActivation__offset = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of VariableRateActivation
    m_VariableRateActivation__step = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_VariableRateActivation__occurrencesPerStep = ::ecore::Ptr
            < ::ecore::EReference > (new ::ecore::EReference);

    // Feature definitions of SporadicActivation
    m_SporadicActivation__occurrence = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of SingleActivation
    m_SingleActivation__min = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_SingleActivation__max = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of EventActivation
    m_EventActivation__triggeringEvents = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_EventActivation__counter = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of CustomActivation

    // Feature definitions of LabelAccessStatistic
    m_LabelAccessStatistic__value = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);
    m_LabelAccessStatistic__cacheMisses = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

    // Feature definitions of RunEntityCallStatistic
    m_RunEntityCallStatistic__statistic = ::ecore::Ptr < ::ecore::EReference
            > (new ::ecore::EReference);

}

void AmaltheaPackage::_initPackage()
{
    // Factory
    {
        ::ecore::EFactory_ptr _fa = AmaltheaFactory::_instance();
        setEFactoryInstance(_fa);
        _fa->setEPackage(_this());
    }

    // Create classes and their features

    // Amalthea
    {
        m_AmaltheaEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_AmaltheaEClass->setClassifierID(AMALTHEA);
        m_AmaltheaEClass->setEPackage(_this());
        getEClassifiers().push_back(m_AmaltheaEClass);
    }
    // m_Amalthea__version has already been allocated above
    m_Amalthea__version->setFeatureID(
            ::amalthea::AmaltheaPackage::AMALTHEA__VERSION);
    m_AmaltheaEClass->getEStructuralFeatures().push_back(m_Amalthea__version);
    // m_Amalthea__commonElements has already been allocated above
    m_Amalthea__commonElements->setFeatureID(
            ::amalthea::AmaltheaPackage::AMALTHEA__COMMONELEMENTS);
    m_AmaltheaEClass->getEStructuralFeatures().push_back(
            m_Amalthea__commonElements);
    // m_Amalthea__swModel has already been allocated above
    m_Amalthea__swModel->setFeatureID(
            ::amalthea::AmaltheaPackage::AMALTHEA__SWMODEL);
    m_AmaltheaEClass->getEStructuralFeatures().push_back(m_Amalthea__swModel);
    // m_Amalthea__hwModel has already been allocated above
    m_Amalthea__hwModel->setFeatureID(
            ::amalthea::AmaltheaPackage::AMALTHEA__HWMODEL);
    m_AmaltheaEClass->getEStructuralFeatures().push_back(m_Amalthea__hwModel);
    // m_Amalthea__osModel has already been allocated above
    m_Amalthea__osModel->setFeatureID(
            ::amalthea::AmaltheaPackage::AMALTHEA__OSMODEL);
    m_AmaltheaEClass->getEStructuralFeatures().push_back(m_Amalthea__osModel);
    // m_Amalthea__stimuliModel has already been allocated above
    m_Amalthea__stimuliModel->setFeatureID(
            ::amalthea::AmaltheaPackage::AMALTHEA__STIMULIMODEL);
    m_AmaltheaEClass->getEStructuralFeatures().push_back(
            m_Amalthea__stimuliModel);
    // m_Amalthea__eventModel has already been allocated above
    m_Amalthea__eventModel->setFeatureID(
            ::amalthea::AmaltheaPackage::AMALTHEA__EVENTMODEL);
    m_AmaltheaEClass->getEStructuralFeatures().push_back(
            m_Amalthea__eventModel);
    // m_Amalthea__constraintsModel has already been allocated above
    m_Amalthea__constraintsModel->setFeatureID(
            ::amalthea::AmaltheaPackage::AMALTHEA__CONSTRAINTSMODEL);
    m_AmaltheaEClass->getEStructuralFeatures().push_back(
            m_Amalthea__constraintsModel);
    // m_Amalthea__propertyConstraintsModel has already been allocated above
    m_Amalthea__propertyConstraintsModel->setFeatureID(
            ::amalthea::AmaltheaPackage::AMALTHEA__PROPERTYCONSTRAINTSMODEL);
    m_AmaltheaEClass->getEStructuralFeatures().push_back(
            m_Amalthea__propertyConstraintsModel);
    // m_Amalthea__mappingModel has already been allocated above
    m_Amalthea__mappingModel->setFeatureID(
            ::amalthea::AmaltheaPackage::AMALTHEA__MAPPINGMODEL);
    m_AmaltheaEClass->getEStructuralFeatures().push_back(
            m_Amalthea__mappingModel);
    // m_Amalthea__componentsModel has already been allocated above
    m_Amalthea__componentsModel->setFeatureID(
            ::amalthea::AmaltheaPackage::AMALTHEA__COMPONENTSMODEL);
    m_AmaltheaEClass->getEStructuralFeatures().push_back(
            m_Amalthea__componentsModel);
    // m_Amalthea__configModel has already been allocated above
    m_Amalthea__configModel->setFeatureID(
            ::amalthea::AmaltheaPackage::AMALTHEA__CONFIGMODEL);
    m_AmaltheaEClass->getEStructuralFeatures().push_back(
            m_Amalthea__configModel);

    // CommonElements
    {
        m_CommonElementsEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_CommonElementsEClass->setClassifierID(COMMONELEMENTS);
        m_CommonElementsEClass->setEPackage(_this());
        getEClassifiers().push_back(m_CommonElementsEClass);
    }
    // m_CommonElements__tags has already been allocated above
    m_CommonElements__tags->setFeatureID(
            ::amalthea::AmaltheaPackage::COMMONELEMENTS__TAGS);
    m_CommonElementsEClass->getEStructuralFeatures().push_back(
            m_CommonElements__tags);
    // m_CommonElements__namespaces has already been allocated above
    m_CommonElements__namespaces->setFeatureID(
            ::amalthea::AmaltheaPackage::COMMONELEMENTS__NAMESPACES);
    m_CommonElementsEClass->getEStructuralFeatures().push_back(
            m_CommonElements__namespaces);
    // m_CommonElements__coreClassifiers has already been allocated above
    m_CommonElements__coreClassifiers->setFeatureID(
            ::amalthea::AmaltheaPackage::COMMONELEMENTS__CORECLASSIFIERS);
    m_CommonElementsEClass->getEStructuralFeatures().push_back(
            m_CommonElements__coreClassifiers);
    // m_CommonElements__memoryClassifiers has already been allocated above
    m_CommonElements__memoryClassifiers->setFeatureID(
            ::amalthea::AmaltheaPackage::COMMONELEMENTS__MEMORYCLASSIFIERS);
    m_CommonElementsEClass->getEStructuralFeatures().push_back(
            m_CommonElements__memoryClassifiers);

    // BaseObject
    {
        m_BaseObjectEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_BaseObjectEClass->setClassifierID(BASEOBJECT);
        m_BaseObjectEClass->setEPackage(_this());
        getEClassifiers().push_back(m_BaseObjectEClass);
    }

    // ReferableObject
    {
        m_ReferableObjectEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_ReferableObjectEClass->setClassifierID(REFERABLEOBJECT);
        m_ReferableObjectEClass->setEPackage(_this());
        getEClassifiers().push_back(m_ReferableObjectEClass);
    }

    // ReferableBaseObject
    {
        m_ReferableBaseObjectEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_ReferableBaseObjectEClass->setClassifierID(REFERABLEBASEOBJECT);
        m_ReferableBaseObjectEClass->setEPackage(_this());
        getEClassifiers().push_back(m_ReferableBaseObjectEClass);
    }

    // IAnnotatable
    {
        m_IAnnotatableEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_IAnnotatableEClass->setClassifierID(IANNOTATABLE);
        m_IAnnotatableEClass->setEPackage(_this());
        getEClassifiers().push_back(m_IAnnotatableEClass);
    }
    // m_IAnnotatable__customProperties has already been allocated above
    m_IAnnotatable__customProperties->setFeatureID(
            ::amalthea::AmaltheaPackage::IANNOTATABLE__CUSTOMPROPERTIES);
    m_IAnnotatableEClass->getEStructuralFeatures().push_back(
            m_IAnnotatable__customProperties);

    // ITaggable
    {
        m_ITaggableEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_ITaggableEClass->setClassifierID(ITAGGABLE);
        m_ITaggableEClass->setEPackage(_this());
        getEClassifiers().push_back(m_ITaggableEClass);
    }
    // m_ITaggable__tags has already been allocated above
    m_ITaggable__tags->setFeatureID(
            ::amalthea::AmaltheaPackage::ITAGGABLE__TAGS);
    m_ITaggableEClass->getEStructuralFeatures().push_back(m_ITaggable__tags);

    // INamed
    {
        m_INamedEClass = ::ecore::Ptr < ::ecore::EClass > (new ::ecore::EClass);
        m_INamedEClass->setClassifierID(INAMED);
        m_INamedEClass->setEPackage(_this());
        getEClassifiers().push_back(m_INamedEClass);
    }
    // m_INamed__name has already been allocated above
    m_INamed__name->setFeatureID(::amalthea::AmaltheaPackage::INAMED__NAME);
    m_INamedEClass->getEStructuralFeatures().push_back(m_INamed__name);
    // m_INamed__qualifiedName has already been allocated above
    m_INamed__qualifiedName->setFeatureID(
            ::amalthea::AmaltheaPackage::INAMED__QUALIFIEDNAME);
    m_INamedEClass->getEStructuralFeatures().push_back(m_INamed__qualifiedName);

    // IReferable
    {
        m_IReferableEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_IReferableEClass->setClassifierID(IREFERABLE);
        m_IReferableEClass->setEPackage(_this());
        getEClassifiers().push_back(m_IReferableEClass);
    }
    // m_IReferable__uniqueName has already been allocated above
    m_IReferable__uniqueName->setFeatureID(
            ::amalthea::AmaltheaPackage::IREFERABLE__UNIQUENAME);
    m_IReferableEClass->getEStructuralFeatures().push_back(
            m_IReferable__uniqueName);

    // IDisplayName
    {
        m_IDisplayNameEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_IDisplayNameEClass->setClassifierID(IDISPLAYNAME);
        m_IDisplayNameEClass->setEPackage(_this());
        getEClassifiers().push_back(m_IDisplayNameEClass);
    }
    // m_IDisplayName__displayName has already been allocated above
    m_IDisplayName__displayName->setFeatureID(
            ::amalthea::AmaltheaPackage::IDISPLAYNAME__DISPLAYNAME);
    m_IDisplayNameEClass->getEStructuralFeatures().push_back(
            m_IDisplayName__displayName);

    // IDescription
    {
        m_IDescriptionEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_IDescriptionEClass->setClassifierID(IDESCRIPTION);
        m_IDescriptionEClass->setEPackage(_this());
        getEClassifiers().push_back(m_IDescriptionEClass);
    }
    // m_IDescription__description has already been allocated above
    m_IDescription__description->setFeatureID(
            ::amalthea::AmaltheaPackage::IDESCRIPTION__DESCRIPTION);
    m_IDescriptionEClass->getEStructuralFeatures().push_back(
            m_IDescription__description);

    // INamespaceMember
    {
        m_INamespaceMemberEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_INamespaceMemberEClass->setClassifierID(INAMESPACEMEMBER);
        m_INamespaceMemberEClass->setEPackage(_this());
        getEClassifiers().push_back(m_INamespaceMemberEClass);
    }
    // m_INamespaceMember__namespace has already been allocated above
    m_INamespaceMember__namespace->setFeatureID(
            ::amalthea::AmaltheaPackage::INAMESPACEMEMBER__NAMESPACE);
    m_INamespaceMemberEClass->getEStructuralFeatures().push_back(
            m_INamespaceMember__namespace);

    // Tag
    {
        m_TagEClass = ::ecore::Ptr < ::ecore::EClass > (new ::ecore::EClass);
        m_TagEClass->setClassifierID(TAG);
        m_TagEClass->setEPackage(_this());
        getEClassifiers().push_back(m_TagEClass);
    }
    // m_Tag__tagType has already been allocated above
    m_Tag__tagType->setFeatureID(::amalthea::AmaltheaPackage::TAG__TAGTYPE);
    m_TagEClass->getEStructuralFeatures().push_back(m_Tag__tagType);
    // m_Tag__taggedObjects has already been allocated above
    m_Tag__taggedObjects->setFeatureID(
            ::amalthea::AmaltheaPackage::TAG__TAGGEDOBJECTS);
    m_TagEClass->getEStructuralFeatures().push_back(m_Tag__taggedObjects);

    // Namespace
    {
        m_NamespaceEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_NamespaceEClass->setClassifierID(NAMESPACE);
        m_NamespaceEClass->setEPackage(_this());
        getEClassifiers().push_back(m_NamespaceEClass);
    }
    // m_Namespace__nextSegments has already been allocated above
    m_Namespace__nextSegments->setFeatureID(
            ::amalthea::AmaltheaPackage::NAMESPACE__NEXTSEGMENTS);
    m_NamespaceEClass->getEStructuralFeatures().push_back(
            m_Namespace__nextSegments);
    // m_Namespace__previousSegment has already been allocated above
    m_Namespace__previousSegment->setFeatureID(
            ::amalthea::AmaltheaPackage::NAMESPACE__PREVIOUSSEGMENT);
    m_NamespaceEClass->getEStructuralFeatures().push_back(
            m_Namespace__previousSegment);
    // m_Namespace__memberObjects has already been allocated above
    m_Namespace__memberObjects->setFeatureID(
            ::amalthea::AmaltheaPackage::NAMESPACE__MEMBEROBJECTS);
    m_NamespaceEClass->getEStructuralFeatures().push_back(
            m_Namespace__memberObjects);

    // Classifier
    {
        m_ClassifierEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_ClassifierEClass->setClassifierID(CLASSIFIER);
        m_ClassifierEClass->setEPackage(_this());
        getEClassifiers().push_back(m_ClassifierEClass);
    }

    // CoreClassifier
    {
        m_CoreClassifierEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_CoreClassifierEClass->setClassifierID(CORECLASSIFIER);
        m_CoreClassifierEClass->setEPackage(_this());
        getEClassifiers().push_back(m_CoreClassifierEClass);
    }

    // MemoryClassifier
    {
        m_MemoryClassifierEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_MemoryClassifierEClass->setClassifierID(MEMORYCLASSIFIER);
        m_MemoryClassifierEClass->setEPackage(_this());
        getEClassifiers().push_back(m_MemoryClassifierEClass);
    }

    // TransmissionPolicy
    {
        m_TransmissionPolicyEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_TransmissionPolicyEClass->setClassifierID(TRANSMISSIONPOLICY);
        m_TransmissionPolicyEClass->setEPackage(_this());
        getEClassifiers().push_back(m_TransmissionPolicyEClass);
    }
    // m_TransmissionPolicy__chunkProcessingTicks has already been allocated above
    m_TransmissionPolicy__chunkProcessingTicks->setFeatureID(
            ::amalthea::AmaltheaPackage::TRANSMISSIONPOLICY__CHUNKPROCESSINGTICKS);
    m_TransmissionPolicyEClass->getEStructuralFeatures().push_back(
            m_TransmissionPolicy__chunkProcessingTicks);
    // m_TransmissionPolicy__transmitRatio has already been allocated above
    m_TransmissionPolicy__transmitRatio->setFeatureID(
            ::amalthea::AmaltheaPackage::TRANSMISSIONPOLICY__TRANSMITRATIO);
    m_TransmissionPolicyEClass->getEStructuralFeatures().push_back(
            m_TransmissionPolicy__transmitRatio);
    // m_TransmissionPolicy__chunkSize has already been allocated above
    m_TransmissionPolicy__chunkSize->setFeatureID(
            ::amalthea::AmaltheaPackage::TRANSMISSIONPOLICY__CHUNKSIZE);
    m_TransmissionPolicyEClass->getEStructuralFeatures().push_back(
            m_TransmissionPolicy__chunkSize);

    // Quantity
    {
        m_QuantityEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_QuantityEClass->setClassifierID(QUANTITY);
        m_QuantityEClass->setEPackage(_this());
        getEClassifiers().push_back(m_QuantityEClass);
    }

    // TimeComparable
    {
        m_TimeComparableEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_TimeComparableEClass->setClassifierID(TIMECOMPARABLE);
        m_TimeComparableEClass->setEPackage(_this());
        getEClassifiers().push_back(m_TimeComparableEClass);
    }

    // Time
    {
        m_TimeEClass = ::ecore::Ptr < ::ecore::EClass > (new ::ecore::EClass);
        m_TimeEClass->setClassifierID(TIME);
        m_TimeEClass->setEPackage(_this());
        getEClassifiers().push_back(m_TimeEClass);
    }
    // m_Time__value has already been allocated above
    m_Time__value->setFeatureID(::amalthea::AmaltheaPackage::TIME__VALUE);
    m_TimeEClass->getEStructuralFeatures().push_back(m_Time__value);
    // m_Time__unit has already been allocated above
    m_Time__unit->setFeatureID(::amalthea::AmaltheaPackage::TIME__UNIT);
    m_TimeEClass->getEStructuralFeatures().push_back(m_Time__unit);

    // Frequency
    {
        m_FrequencyEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_FrequencyEClass->setClassifierID(FREQUENCY);
        m_FrequencyEClass->setEPackage(_this());
        getEClassifiers().push_back(m_FrequencyEClass);
    }
    // m_Frequency__value has already been allocated above
    m_Frequency__value->setFeatureID(
            ::amalthea::AmaltheaPackage::FREQUENCY__VALUE);
    m_FrequencyEClass->getEStructuralFeatures().push_back(m_Frequency__value);
    // m_Frequency__unit has already been allocated above
    m_Frequency__unit->setFeatureID(
            ::amalthea::AmaltheaPackage::FREQUENCY__UNIT);
    m_FrequencyEClass->getEStructuralFeatures().push_back(m_Frequency__unit);

    // Voltage
    {
        m_VoltageEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_VoltageEClass->setClassifierID(VOLTAGE);
        m_VoltageEClass->setEPackage(_this());
        getEClassifiers().push_back(m_VoltageEClass);
    }
    // m_Voltage__value has already been allocated above
    m_Voltage__value->setFeatureID(::amalthea::AmaltheaPackage::VOLTAGE__VALUE);
    m_VoltageEClass->getEStructuralFeatures().push_back(m_Voltage__value);
    // m_Voltage__unit has already been allocated above
    m_Voltage__unit->setFeatureID(::amalthea::AmaltheaPackage::VOLTAGE__UNIT);
    m_VoltageEClass->getEStructuralFeatures().push_back(m_Voltage__unit);

    // DataSize
    {
        m_DataSizeEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_DataSizeEClass->setClassifierID(DATASIZE);
        m_DataSizeEClass->setEPackage(_this());
        getEClassifiers().push_back(m_DataSizeEClass);
    }
    // m_DataSize__value has already been allocated above
    m_DataSize__value->setFeatureID(
            ::amalthea::AmaltheaPackage::DATASIZE__VALUE);
    m_DataSizeEClass->getEStructuralFeatures().push_back(m_DataSize__value);
    // m_DataSize__unit has already been allocated above
    m_DataSize__unit->setFeatureID(::amalthea::AmaltheaPackage::DATASIZE__UNIT);
    m_DataSizeEClass->getEStructuralFeatures().push_back(m_DataSize__unit);

    // DataRateComparable
    {
        m_DataRateComparableEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_DataRateComparableEClass->setClassifierID(DATARATECOMPARABLE);
        m_DataRateComparableEClass->setEPackage(_this());
        getEClassifiers().push_back(m_DataRateComparableEClass);
    }

    // DataRate
    {
        m_DataRateEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_DataRateEClass->setClassifierID(DATARATE);
        m_DataRateEClass->setEPackage(_this());
        getEClassifiers().push_back(m_DataRateEClass);
    }
    // m_DataRate__value has already been allocated above
    m_DataRate__value->setFeatureID(
            ::amalthea::AmaltheaPackage::DATARATE__VALUE);
    m_DataRateEClass->getEStructuralFeatures().push_back(m_DataRate__value);
    // m_DataRate__unit has already been allocated above
    m_DataRate__unit->setFeatureID(::amalthea::AmaltheaPackage::DATARATE__UNIT);
    m_DataRateEClass->getEStructuralFeatures().push_back(m_DataRate__unit);

    // CustomProperty
    {
        m_CustomPropertyEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_CustomPropertyEClass->setClassifierID(CUSTOMPROPERTY);
        m_CustomPropertyEClass->setEPackage(_this());
        getEClassifiers().push_back(m_CustomPropertyEClass);
    }
    // m_CustomProperty__key has already been allocated above
    m_CustomProperty__key->setFeatureID(
            ::amalthea::AmaltheaPackage::CUSTOMPROPERTY__KEY);
    m_CustomPropertyEClass->getEStructuralFeatures().push_back(
            m_CustomProperty__key);
    // m_CustomProperty__value has already been allocated above
    m_CustomProperty__value->setFeatureID(
            ::amalthea::AmaltheaPackage::CUSTOMPROPERTY__VALUE);
    m_CustomPropertyEClass->getEStructuralFeatures().push_back(
            m_CustomProperty__value);

    // Value
    {
        m_ValueEClass = ::ecore::Ptr < ::ecore::EClass > (new ::ecore::EClass);
        m_ValueEClass->setClassifierID(VALUE);
        m_ValueEClass->setEPackage(_this());
        getEClassifiers().push_back(m_ValueEClass);
    }

    // ListObject
    {
        m_ListObjectEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_ListObjectEClass->setClassifierID(LISTOBJECT);
        m_ListObjectEClass->setEPackage(_this());
        getEClassifiers().push_back(m_ListObjectEClass);
    }
    // m_ListObject__values has already been allocated above
    m_ListObject__values->setFeatureID(
            ::amalthea::AmaltheaPackage::LISTOBJECT__VALUES);
    m_ListObjectEClass->getEStructuralFeatures().push_back(
            m_ListObject__values);

    // StringObject
    {
        m_StringObjectEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_StringObjectEClass->setClassifierID(STRINGOBJECT);
        m_StringObjectEClass->setEPackage(_this());
        getEClassifiers().push_back(m_StringObjectEClass);
    }
    // m_StringObject__value has already been allocated above
    m_StringObject__value->setFeatureID(
            ::amalthea::AmaltheaPackage::STRINGOBJECT__VALUE);
    m_StringObjectEClass->getEStructuralFeatures().push_back(
            m_StringObject__value);

    // BigIntegerObject
    {
        m_BigIntegerObjectEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_BigIntegerObjectEClass->setClassifierID(BIGINTEGEROBJECT);
        m_BigIntegerObjectEClass->setEPackage(_this());
        getEClassifiers().push_back(m_BigIntegerObjectEClass);
    }
    // m_BigIntegerObject__value has already been allocated above
    m_BigIntegerObject__value->setFeatureID(
            ::amalthea::AmaltheaPackage::BIGINTEGEROBJECT__VALUE);
    m_BigIntegerObjectEClass->getEStructuralFeatures().push_back(
            m_BigIntegerObject__value);

    // ReferenceObject
    {
        m_ReferenceObjectEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_ReferenceObjectEClass->setClassifierID(REFERENCEOBJECT);
        m_ReferenceObjectEClass->setEPackage(_this());
        getEClassifiers().push_back(m_ReferenceObjectEClass);
    }
    // m_ReferenceObject__value has already been allocated above
    m_ReferenceObject__value->setFeatureID(
            ::amalthea::AmaltheaPackage::REFERENCEOBJECT__VALUE);
    m_ReferenceObjectEClass->getEStructuralFeatures().push_back(
            m_ReferenceObject__value);

    // IntegerObject
    {
        m_IntegerObjectEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_IntegerObjectEClass->setClassifierID(INTEGEROBJECT);
        m_IntegerObjectEClass->setEPackage(_this());
        getEClassifiers().push_back(m_IntegerObjectEClass);
    }
    // m_IntegerObject__value has already been allocated above
    m_IntegerObject__value->setFeatureID(
            ::amalthea::AmaltheaPackage::INTEGEROBJECT__VALUE);
    m_IntegerObjectEClass->getEStructuralFeatures().push_back(
            m_IntegerObject__value);

    // LongObject
    {
        m_LongObjectEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_LongObjectEClass->setClassifierID(LONGOBJECT);
        m_LongObjectEClass->setEPackage(_this());
        getEClassifiers().push_back(m_LongObjectEClass);
    }
    // m_LongObject__value has already been allocated above
    m_LongObject__value->setFeatureID(
            ::amalthea::AmaltheaPackage::LONGOBJECT__VALUE);
    m_LongObjectEClass->getEStructuralFeatures().push_back(m_LongObject__value);

    // FloatObject
    {
        m_FloatObjectEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_FloatObjectEClass->setClassifierID(FLOATOBJECT);
        m_FloatObjectEClass->setEPackage(_this());
        getEClassifiers().push_back(m_FloatObjectEClass);
    }
    // m_FloatObject__value has already been allocated above
    m_FloatObject__value->setFeatureID(
            ::amalthea::AmaltheaPackage::FLOATOBJECT__VALUE);
    m_FloatObjectEClass->getEStructuralFeatures().push_back(
            m_FloatObject__value);

    // DoubleObject
    {
        m_DoubleObjectEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_DoubleObjectEClass->setClassifierID(DOUBLEOBJECT);
        m_DoubleObjectEClass->setEPackage(_this());
        getEClassifiers().push_back(m_DoubleObjectEClass);
    }
    // m_DoubleObject__value has already been allocated above
    m_DoubleObject__value->setFeatureID(
            ::amalthea::AmaltheaPackage::DOUBLEOBJECT__VALUE);
    m_DoubleObjectEClass->getEStructuralFeatures().push_back(
            m_DoubleObject__value);

    // BooleanObject
    {
        m_BooleanObjectEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_BooleanObjectEClass->setClassifierID(BOOLEANOBJECT);
        m_BooleanObjectEClass->setEPackage(_this());
        getEClassifiers().push_back(m_BooleanObjectEClass);
    }
    // m_BooleanObject__value has already been allocated above
    m_BooleanObject__value->setFeatureID(
            ::amalthea::AmaltheaPackage::BOOLEANOBJECT__VALUE);
    m_BooleanObjectEClass->getEStructuralFeatures().push_back(
            m_BooleanObject__value);

    // NumericStatistic
    {
        m_NumericStatisticEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_NumericStatisticEClass->setClassifierID(NUMERICSTATISTIC);
        m_NumericStatisticEClass->setEPackage(_this());
        getEClassifiers().push_back(m_NumericStatisticEClass);
    }

    // MinAvgMaxStatistic
    {
        m_MinAvgMaxStatisticEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_MinAvgMaxStatisticEClass->setClassifierID(MINAVGMAXSTATISTIC);
        m_MinAvgMaxStatisticEClass->setEPackage(_this());
        getEClassifiers().push_back(m_MinAvgMaxStatisticEClass);
    }
    // m_MinAvgMaxStatistic__min has already been allocated above
    m_MinAvgMaxStatistic__min->setFeatureID(
            ::amalthea::AmaltheaPackage::MINAVGMAXSTATISTIC__MIN);
    m_MinAvgMaxStatisticEClass->getEStructuralFeatures().push_back(
            m_MinAvgMaxStatistic__min);
    // m_MinAvgMaxStatistic__avg has already been allocated above
    m_MinAvgMaxStatistic__avg->setFeatureID(
            ::amalthea::AmaltheaPackage::MINAVGMAXSTATISTIC__AVG);
    m_MinAvgMaxStatisticEClass->getEStructuralFeatures().push_back(
            m_MinAvgMaxStatistic__avg);
    // m_MinAvgMaxStatistic__max has already been allocated above
    m_MinAvgMaxStatistic__max->setFeatureID(
            ::amalthea::AmaltheaPackage::MINAVGMAXSTATISTIC__MAX);
    m_MinAvgMaxStatisticEClass->getEStructuralFeatures().push_back(
            m_MinAvgMaxStatistic__max);

    // SingleValueStatistic
    {
        m_SingleValueStatisticEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_SingleValueStatisticEClass->setClassifierID(SINGLEVALUESTATISTIC);
        m_SingleValueStatisticEClass->setEPackage(_this());
        getEClassifiers().push_back(m_SingleValueStatisticEClass);
    }
    // m_SingleValueStatistic__value has already been allocated above
    m_SingleValueStatistic__value->setFeatureID(
            ::amalthea::AmaltheaPackage::SINGLEVALUESTATISTIC__VALUE);
    m_SingleValueStatisticEClass->getEStructuralFeatures().push_back(
            m_SingleValueStatistic__value);

    // ITimeDeviation
    {
        m_ITimeDeviationEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_ITimeDeviationEClass->setClassifierID(ITIMEDEVIATION);
        m_ITimeDeviationEClass->setEPackage(_this());
        getEClassifiers().push_back(m_ITimeDeviationEClass);
    }

    // TimeInterval
    {
        m_TimeIntervalEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_TimeIntervalEClass->setClassifierID(TIMEINTERVAL);
        m_TimeIntervalEClass->setEPackage(_this());
        getEClassifiers().push_back(m_TimeIntervalEClass);
    }
    // m_TimeInterval__lowerBound has already been allocated above
    m_TimeInterval__lowerBound->setFeatureID(
            ::amalthea::AmaltheaPackage::TIMEINTERVAL__LOWERBOUND);
    m_TimeIntervalEClass->getEStructuralFeatures().push_back(
            m_TimeInterval__lowerBound);
    // m_TimeInterval__upperBound has already been allocated above
    m_TimeInterval__upperBound->setFeatureID(
            ::amalthea::AmaltheaPackage::TIMEINTERVAL__UPPERBOUND);
    m_TimeIntervalEClass->getEStructuralFeatures().push_back(
            m_TimeInterval__upperBound);

    // TimeConstant
    {
        m_TimeConstantEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_TimeConstantEClass->setClassifierID(TIMECONSTANT);
        m_TimeConstantEClass->setEPackage(_this());
        getEClassifiers().push_back(m_TimeConstantEClass);
    }
    // m_TimeConstant__value has already been allocated above
    m_TimeConstant__value->setFeatureID(
            ::amalthea::AmaltheaPackage::TIMECONSTANT__VALUE);
    m_TimeConstantEClass->getEStructuralFeatures().push_back(
            m_TimeConstant__value);

    // TimeHistogram
    {
        m_TimeHistogramEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_TimeHistogramEClass->setClassifierID(TIMEHISTOGRAM);
        m_TimeHistogramEClass->setEPackage(_this());
        getEClassifiers().push_back(m_TimeHistogramEClass);
    }
    // m_TimeHistogram__entries has already been allocated above
    m_TimeHistogram__entries->setFeatureID(
            ::amalthea::AmaltheaPackage::TIMEHISTOGRAM__ENTRIES);
    m_TimeHistogramEClass->getEStructuralFeatures().push_back(
            m_TimeHistogram__entries);

    // TimeHistogramEntry
    {
        m_TimeHistogramEntryEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_TimeHistogramEntryEClass->setClassifierID(TIMEHISTOGRAMENTRY);
        m_TimeHistogramEntryEClass->setEPackage(_this());
        getEClassifiers().push_back(m_TimeHistogramEntryEClass);
    }
    // m_TimeHistogramEntry__occurrences has already been allocated above
    m_TimeHistogramEntry__occurrences->setFeatureID(
            ::amalthea::AmaltheaPackage::TIMEHISTOGRAMENTRY__OCCURRENCES);
    m_TimeHistogramEntryEClass->getEStructuralFeatures().push_back(
            m_TimeHistogramEntry__occurrences);

    // BoundedTimeDistribution
    {
        m_BoundedTimeDistributionEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_BoundedTimeDistributionEClass->setClassifierID(
                BOUNDEDTIMEDISTRIBUTION);
        m_BoundedTimeDistributionEClass->setEPackage(_this());
        getEClassifiers().push_back(m_BoundedTimeDistributionEClass);
    }

    // TruncatedTimeDistribution
    {
        m_TruncatedTimeDistributionEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_TruncatedTimeDistributionEClass->setClassifierID(
                TRUNCATEDTIMEDISTRIBUTION);
        m_TruncatedTimeDistributionEClass->setEPackage(_this());
        getEClassifiers().push_back(m_TruncatedTimeDistributionEClass);
    }
    // m_TruncatedTimeDistribution__lowerBound has already been allocated above
    m_TruncatedTimeDistribution__lowerBound->setFeatureID(
            ::amalthea::AmaltheaPackage::TRUNCATEDTIMEDISTRIBUTION__LOWERBOUND);
    m_TruncatedTimeDistributionEClass->getEStructuralFeatures().push_back(
            m_TruncatedTimeDistribution__lowerBound);
    // m_TruncatedTimeDistribution__upperBound has already been allocated above
    m_TruncatedTimeDistribution__upperBound->setFeatureID(
            ::amalthea::AmaltheaPackage::TRUNCATEDTIMEDISTRIBUTION__UPPERBOUND);
    m_TruncatedTimeDistributionEClass->getEStructuralFeatures().push_back(
            m_TruncatedTimeDistribution__upperBound);

    // TimeBoundaries
    {
        m_TimeBoundariesEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_TimeBoundariesEClass->setClassifierID(TIMEBOUNDARIES);
        m_TimeBoundariesEClass->setEPackage(_this());
        getEClassifiers().push_back(m_TimeBoundariesEClass);
    }
    // m_TimeBoundaries__samplingType has already been allocated above
    m_TimeBoundaries__samplingType->setFeatureID(
            ::amalthea::AmaltheaPackage::TIMEBOUNDARIES__SAMPLINGTYPE);
    m_TimeBoundariesEClass->getEStructuralFeatures().push_back(
            m_TimeBoundaries__samplingType);

    // TimeStatistics
    {
        m_TimeStatisticsEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_TimeStatisticsEClass->setClassifierID(TIMESTATISTICS);
        m_TimeStatisticsEClass->setEPackage(_this());
        getEClassifiers().push_back(m_TimeStatisticsEClass);
    }
    // m_TimeStatistics__average has already been allocated above
    m_TimeStatistics__average->setFeatureID(
            ::amalthea::AmaltheaPackage::TIMESTATISTICS__AVERAGE);
    m_TimeStatisticsEClass->getEStructuralFeatures().push_back(
            m_TimeStatistics__average);

    // TimeUniformDistribution
    {
        m_TimeUniformDistributionEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_TimeUniformDistributionEClass->setClassifierID(
                TIMEUNIFORMDISTRIBUTION);
        m_TimeUniformDistributionEClass->setEPackage(_this());
        getEClassifiers().push_back(m_TimeUniformDistributionEClass);
    }

    // TimeGaussDistribution
    {
        m_TimeGaussDistributionEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_TimeGaussDistributionEClass->setClassifierID(TIMEGAUSSDISTRIBUTION);
        m_TimeGaussDistributionEClass->setEPackage(_this());
        getEClassifiers().push_back(m_TimeGaussDistributionEClass);
    }
    // m_TimeGaussDistribution__mean has already been allocated above
    m_TimeGaussDistribution__mean->setFeatureID(
            ::amalthea::AmaltheaPackage::TIMEGAUSSDISTRIBUTION__MEAN);
    m_TimeGaussDistributionEClass->getEStructuralFeatures().push_back(
            m_TimeGaussDistribution__mean);
    // m_TimeGaussDistribution__sd has already been allocated above
    m_TimeGaussDistribution__sd->setFeatureID(
            ::amalthea::AmaltheaPackage::TIMEGAUSSDISTRIBUTION__SD);
    m_TimeGaussDistributionEClass->getEStructuralFeatures().push_back(
            m_TimeGaussDistribution__sd);

    // TimeWeibullEstimatorsDistribution
    {
        m_TimeWeibullEstimatorsDistributionEClass = ::ecore::Ptr
                < ::ecore::EClass > (new ::ecore::EClass);
        m_TimeWeibullEstimatorsDistributionEClass->setClassifierID(
                TIMEWEIBULLESTIMATORSDISTRIBUTION);
        m_TimeWeibullEstimatorsDistributionEClass->setEPackage(_this());
        getEClassifiers().push_back(m_TimeWeibullEstimatorsDistributionEClass);
    }
    // m_TimeWeibullEstimatorsDistribution__pRemainPromille has already been allocated above
    m_TimeWeibullEstimatorsDistribution__pRemainPromille->setFeatureID(
            ::amalthea::AmaltheaPackage::TIMEWEIBULLESTIMATORSDISTRIBUTION__PREMAINPROMILLE);
    m_TimeWeibullEstimatorsDistributionEClass->getEStructuralFeatures().push_back(
            m_TimeWeibullEstimatorsDistribution__pRemainPromille);
    // m_TimeWeibullEstimatorsDistribution__average has already been allocated above
    m_TimeWeibullEstimatorsDistribution__average->setFeatureID(
            ::amalthea::AmaltheaPackage::TIMEWEIBULLESTIMATORSDISTRIBUTION__AVERAGE);
    m_TimeWeibullEstimatorsDistributionEClass->getEStructuralFeatures().push_back(
            m_TimeWeibullEstimatorsDistribution__average);

    // TimeBetaDistribution
    {
        m_TimeBetaDistributionEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_TimeBetaDistributionEClass->setClassifierID(TIMEBETADISTRIBUTION);
        m_TimeBetaDistributionEClass->setEPackage(_this());
        getEClassifiers().push_back(m_TimeBetaDistributionEClass);
    }
    // m_TimeBetaDistribution__alpha has already been allocated above
    m_TimeBetaDistribution__alpha->setFeatureID(
            ::amalthea::AmaltheaPackage::TIMEBETADISTRIBUTION__ALPHA);
    m_TimeBetaDistributionEClass->getEStructuralFeatures().push_back(
            m_TimeBetaDistribution__alpha);
    // m_TimeBetaDistribution__beta has already been allocated above
    m_TimeBetaDistribution__beta->setFeatureID(
            ::amalthea::AmaltheaPackage::TIMEBETADISTRIBUTION__BETA);
    m_TimeBetaDistributionEClass->getEStructuralFeatures().push_back(
            m_TimeBetaDistribution__beta);

    // IDiscreteValueDeviation
    {
        m_IDiscreteValueDeviationEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_IDiscreteValueDeviationEClass->setClassifierID(
                IDISCRETEVALUEDEVIATION);
        m_IDiscreteValueDeviationEClass->setEPackage(_this());
        getEClassifiers().push_back(m_IDiscreteValueDeviationEClass);
    }

    // DiscreteValueInterval
    {
        m_DiscreteValueIntervalEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_DiscreteValueIntervalEClass->setClassifierID(DISCRETEVALUEINTERVAL);
        m_DiscreteValueIntervalEClass->setEPackage(_this());
        getEClassifiers().push_back(m_DiscreteValueIntervalEClass);
    }
    // m_DiscreteValueInterval__lowerBound has already been allocated above
    m_DiscreteValueInterval__lowerBound->setFeatureID(
            ::amalthea::AmaltheaPackage::DISCRETEVALUEINTERVAL__LOWERBOUND);
    m_DiscreteValueIntervalEClass->getEStructuralFeatures().push_back(
            m_DiscreteValueInterval__lowerBound);
    // m_DiscreteValueInterval__upperBound has already been allocated above
    m_DiscreteValueInterval__upperBound->setFeatureID(
            ::amalthea::AmaltheaPackage::DISCRETEVALUEINTERVAL__UPPERBOUND);
    m_DiscreteValueIntervalEClass->getEStructuralFeatures().push_back(
            m_DiscreteValueInterval__upperBound);

    // DiscreteValueConstant
    {
        m_DiscreteValueConstantEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_DiscreteValueConstantEClass->setClassifierID(DISCRETEVALUECONSTANT);
        m_DiscreteValueConstantEClass->setEPackage(_this());
        getEClassifiers().push_back(m_DiscreteValueConstantEClass);
    }
    // m_DiscreteValueConstant__value has already been allocated above
    m_DiscreteValueConstant__value->setFeatureID(
            ::amalthea::AmaltheaPackage::DISCRETEVALUECONSTANT__VALUE);
    m_DiscreteValueConstantEClass->getEStructuralFeatures().push_back(
            m_DiscreteValueConstant__value);

    // DiscreteValueHistogram
    {
        m_DiscreteValueHistogramEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_DiscreteValueHistogramEClass->setClassifierID(DISCRETEVALUEHISTOGRAM);
        m_DiscreteValueHistogramEClass->setEPackage(_this());
        getEClassifiers().push_back(m_DiscreteValueHistogramEClass);
    }
    // m_DiscreteValueHistogram__entries has already been allocated above
    m_DiscreteValueHistogram__entries->setFeatureID(
            ::amalthea::AmaltheaPackage::DISCRETEVALUEHISTOGRAM__ENTRIES);
    m_DiscreteValueHistogramEClass->getEStructuralFeatures().push_back(
            m_DiscreteValueHistogram__entries);

    // DiscreteValueHistogramEntry
    {
        m_DiscreteValueHistogramEntryEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_DiscreteValueHistogramEntryEClass->setClassifierID(
                DISCRETEVALUEHISTOGRAMENTRY);
        m_DiscreteValueHistogramEntryEClass->setEPackage(_this());
        getEClassifiers().push_back(m_DiscreteValueHistogramEntryEClass);
    }
    // m_DiscreteValueHistogramEntry__occurrences has already been allocated above
    m_DiscreteValueHistogramEntry__occurrences->setFeatureID(
            ::amalthea::AmaltheaPackage::DISCRETEVALUEHISTOGRAMENTRY__OCCURRENCES);
    m_DiscreteValueHistogramEntryEClass->getEStructuralFeatures().push_back(
            m_DiscreteValueHistogramEntry__occurrences);

    // BoundedDiscreteValueDistribution
    {
        m_BoundedDiscreteValueDistributionEClass = ::ecore::Ptr
                < ::ecore::EClass > (new ::ecore::EClass);
        m_BoundedDiscreteValueDistributionEClass->setClassifierID(
                BOUNDEDDISCRETEVALUEDISTRIBUTION);
        m_BoundedDiscreteValueDistributionEClass->setEPackage(_this());
        getEClassifiers().push_back(m_BoundedDiscreteValueDistributionEClass);
    }

    // TruncatedDiscreteValueDistribution
    {
        m_TruncatedDiscreteValueDistributionEClass = ::ecore::Ptr
                < ::ecore::EClass > (new ::ecore::EClass);
        m_TruncatedDiscreteValueDistributionEClass->setClassifierID(
                TRUNCATEDDISCRETEVALUEDISTRIBUTION);
        m_TruncatedDiscreteValueDistributionEClass->setEPackage(_this());
        getEClassifiers().push_back(m_TruncatedDiscreteValueDistributionEClass);
    }
    // m_TruncatedDiscreteValueDistribution__lowerBound has already been allocated above
    m_TruncatedDiscreteValueDistribution__lowerBound->setFeatureID(
            ::amalthea::AmaltheaPackage::TRUNCATEDDISCRETEVALUEDISTRIBUTION__LOWERBOUND);
    m_TruncatedDiscreteValueDistributionEClass->getEStructuralFeatures().push_back(
            m_TruncatedDiscreteValueDistribution__lowerBound);
    // m_TruncatedDiscreteValueDistribution__upperBound has already been allocated above
    m_TruncatedDiscreteValueDistribution__upperBound->setFeatureID(
            ::amalthea::AmaltheaPackage::TRUNCATEDDISCRETEVALUEDISTRIBUTION__UPPERBOUND);
    m_TruncatedDiscreteValueDistributionEClass->getEStructuralFeatures().push_back(
            m_TruncatedDiscreteValueDistribution__upperBound);

    // DiscreteValueBoundaries
    {
        m_DiscreteValueBoundariesEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_DiscreteValueBoundariesEClass->setClassifierID(
                DISCRETEVALUEBOUNDARIES);
        m_DiscreteValueBoundariesEClass->setEPackage(_this());
        getEClassifiers().push_back(m_DiscreteValueBoundariesEClass);
    }
    // m_DiscreteValueBoundaries__samplingType has already been allocated above
    m_DiscreteValueBoundaries__samplingType->setFeatureID(
            ::amalthea::AmaltheaPackage::DISCRETEVALUEBOUNDARIES__SAMPLINGTYPE);
    m_DiscreteValueBoundariesEClass->getEStructuralFeatures().push_back(
            m_DiscreteValueBoundaries__samplingType);

    // DiscreteValueStatistics
    {
        m_DiscreteValueStatisticsEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_DiscreteValueStatisticsEClass->setClassifierID(
                DISCRETEVALUESTATISTICS);
        m_DiscreteValueStatisticsEClass->setEPackage(_this());
        getEClassifiers().push_back(m_DiscreteValueStatisticsEClass);
    }
    // m_DiscreteValueStatistics__average has already been allocated above
    m_DiscreteValueStatistics__average->setFeatureID(
            ::amalthea::AmaltheaPackage::DISCRETEVALUESTATISTICS__AVERAGE);
    m_DiscreteValueStatisticsEClass->getEStructuralFeatures().push_back(
            m_DiscreteValueStatistics__average);

    // DiscreteValueUniformDistribution
    {
        m_DiscreteValueUniformDistributionEClass = ::ecore::Ptr
                < ::ecore::EClass > (new ::ecore::EClass);
        m_DiscreteValueUniformDistributionEClass->setClassifierID(
                DISCRETEVALUEUNIFORMDISTRIBUTION);
        m_DiscreteValueUniformDistributionEClass->setEPackage(_this());
        getEClassifiers().push_back(m_DiscreteValueUniformDistributionEClass);
    }

    // DiscreteValueGaussDistribution
    {
        m_DiscreteValueGaussDistributionEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_DiscreteValueGaussDistributionEClass->setClassifierID(
                DISCRETEVALUEGAUSSDISTRIBUTION);
        m_DiscreteValueGaussDistributionEClass->setEPackage(_this());
        getEClassifiers().push_back(m_DiscreteValueGaussDistributionEClass);
    }
    // m_DiscreteValueGaussDistribution__mean has already been allocated above
    m_DiscreteValueGaussDistribution__mean->setFeatureID(
            ::amalthea::AmaltheaPackage::DISCRETEVALUEGAUSSDISTRIBUTION__MEAN);
    m_DiscreteValueGaussDistributionEClass->getEStructuralFeatures().push_back(
            m_DiscreteValueGaussDistribution__mean);
    // m_DiscreteValueGaussDistribution__sd has already been allocated above
    m_DiscreteValueGaussDistribution__sd->setFeatureID(
            ::amalthea::AmaltheaPackage::DISCRETEVALUEGAUSSDISTRIBUTION__SD);
    m_DiscreteValueGaussDistributionEClass->getEStructuralFeatures().push_back(
            m_DiscreteValueGaussDistribution__sd);

    // DiscreteValueWeibullEstimatorsDistribution
    {
        m_DiscreteValueWeibullEstimatorsDistributionEClass = ::ecore::Ptr
                < ::ecore::EClass > (new ::ecore::EClass);
        m_DiscreteValueWeibullEstimatorsDistributionEClass->setClassifierID(
                DISCRETEVALUEWEIBULLESTIMATORSDISTRIBUTION);
        m_DiscreteValueWeibullEstimatorsDistributionEClass->setEPackage(
                _this());
        getEClassifiers().push_back(
                m_DiscreteValueWeibullEstimatorsDistributionEClass);
    }
    // m_DiscreteValueWeibullEstimatorsDistribution__average has already been allocated above
    m_DiscreteValueWeibullEstimatorsDistribution__average->setFeatureID(
            ::amalthea::AmaltheaPackage::DISCRETEVALUEWEIBULLESTIMATORSDISTRIBUTION__AVERAGE);
    m_DiscreteValueWeibullEstimatorsDistributionEClass->getEStructuralFeatures().push_back(
            m_DiscreteValueWeibullEstimatorsDistribution__average);
    // m_DiscreteValueWeibullEstimatorsDistribution__pRemainPromille has already been allocated above
    m_DiscreteValueWeibullEstimatorsDistribution__pRemainPromille->setFeatureID(
            ::amalthea::AmaltheaPackage::DISCRETEVALUEWEIBULLESTIMATORSDISTRIBUTION__PREMAINPROMILLE);
    m_DiscreteValueWeibullEstimatorsDistributionEClass->getEStructuralFeatures().push_back(
            m_DiscreteValueWeibullEstimatorsDistribution__pRemainPromille);

    // DiscreteValueBetaDistribution
    {
        m_DiscreteValueBetaDistributionEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_DiscreteValueBetaDistributionEClass->setClassifierID(
                DISCRETEVALUEBETADISTRIBUTION);
        m_DiscreteValueBetaDistributionEClass->setEPackage(_this());
        getEClassifiers().push_back(m_DiscreteValueBetaDistributionEClass);
    }
    // m_DiscreteValueBetaDistribution__alpha has already been allocated above
    m_DiscreteValueBetaDistribution__alpha->setFeatureID(
            ::amalthea::AmaltheaPackage::DISCRETEVALUEBETADISTRIBUTION__ALPHA);
    m_DiscreteValueBetaDistributionEClass->getEStructuralFeatures().push_back(
            m_DiscreteValueBetaDistribution__alpha);
    // m_DiscreteValueBetaDistribution__beta has already been allocated above
    m_DiscreteValueBetaDistribution__beta->setFeatureID(
            ::amalthea::AmaltheaPackage::DISCRETEVALUEBETADISTRIBUTION__BETA);
    m_DiscreteValueBetaDistributionEClass->getEStructuralFeatures().push_back(
            m_DiscreteValueBetaDistribution__beta);

    // IContinuousValueDeviation
    {
        m_IContinuousValueDeviationEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_IContinuousValueDeviationEClass->setClassifierID(
                ICONTINUOUSVALUEDEVIATION);
        m_IContinuousValueDeviationEClass->setEPackage(_this());
        getEClassifiers().push_back(m_IContinuousValueDeviationEClass);
    }

    // ContinuousValueInterval
    {
        m_ContinuousValueIntervalEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_ContinuousValueIntervalEClass->setClassifierID(
                CONTINUOUSVALUEINTERVAL);
        m_ContinuousValueIntervalEClass->setEPackage(_this());
        getEClassifiers().push_back(m_ContinuousValueIntervalEClass);
    }
    // m_ContinuousValueInterval__lowerBound has already been allocated above
    m_ContinuousValueInterval__lowerBound->setFeatureID(
            ::amalthea::AmaltheaPackage::CONTINUOUSVALUEINTERVAL__LOWERBOUND);
    m_ContinuousValueIntervalEClass->getEStructuralFeatures().push_back(
            m_ContinuousValueInterval__lowerBound);
    // m_ContinuousValueInterval__upperBound has already been allocated above
    m_ContinuousValueInterval__upperBound->setFeatureID(
            ::amalthea::AmaltheaPackage::CONTINUOUSVALUEINTERVAL__UPPERBOUND);
    m_ContinuousValueIntervalEClass->getEStructuralFeatures().push_back(
            m_ContinuousValueInterval__upperBound);

    // ContinuousValueConstant
    {
        m_ContinuousValueConstantEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_ContinuousValueConstantEClass->setClassifierID(
                CONTINUOUSVALUECONSTANT);
        m_ContinuousValueConstantEClass->setEPackage(_this());
        getEClassifiers().push_back(m_ContinuousValueConstantEClass);
    }
    // m_ContinuousValueConstant__value has already been allocated above
    m_ContinuousValueConstant__value->setFeatureID(
            ::amalthea::AmaltheaPackage::CONTINUOUSVALUECONSTANT__VALUE);
    m_ContinuousValueConstantEClass->getEStructuralFeatures().push_back(
            m_ContinuousValueConstant__value);

    // ContinuousValueHistogram
    {
        m_ContinuousValueHistogramEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_ContinuousValueHistogramEClass->setClassifierID(
                CONTINUOUSVALUEHISTOGRAM);
        m_ContinuousValueHistogramEClass->setEPackage(_this());
        getEClassifiers().push_back(m_ContinuousValueHistogramEClass);
    }
    // m_ContinuousValueHistogram__entries has already been allocated above
    m_ContinuousValueHistogram__entries->setFeatureID(
            ::amalthea::AmaltheaPackage::CONTINUOUSVALUEHISTOGRAM__ENTRIES);
    m_ContinuousValueHistogramEClass->getEStructuralFeatures().push_back(
            m_ContinuousValueHistogram__entries);

    // ContinuousValueHistogramEntry
    {
        m_ContinuousValueHistogramEntryEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_ContinuousValueHistogramEntryEClass->setClassifierID(
                CONTINUOUSVALUEHISTOGRAMENTRY);
        m_ContinuousValueHistogramEntryEClass->setEPackage(_this());
        getEClassifiers().push_back(m_ContinuousValueHistogramEntryEClass);
    }
    // m_ContinuousValueHistogramEntry__occurrences has already been allocated above
    m_ContinuousValueHistogramEntry__occurrences->setFeatureID(
            ::amalthea::AmaltheaPackage::CONTINUOUSVALUEHISTOGRAMENTRY__OCCURRENCES);
    m_ContinuousValueHistogramEntryEClass->getEStructuralFeatures().push_back(
            m_ContinuousValueHistogramEntry__occurrences);

    // BoundedContinuousValueDistribution
    {
        m_BoundedContinuousValueDistributionEClass = ::ecore::Ptr
                < ::ecore::EClass > (new ::ecore::EClass);
        m_BoundedContinuousValueDistributionEClass->setClassifierID(
                BOUNDEDCONTINUOUSVALUEDISTRIBUTION);
        m_BoundedContinuousValueDistributionEClass->setEPackage(_this());
        getEClassifiers().push_back(m_BoundedContinuousValueDistributionEClass);
    }

    // TruncatedContinuousValueDistribution
    {
        m_TruncatedContinuousValueDistributionEClass = ::ecore::Ptr
                < ::ecore::EClass > (new ::ecore::EClass);
        m_TruncatedContinuousValueDistributionEClass->setClassifierID(
                TRUNCATEDCONTINUOUSVALUEDISTRIBUTION);
        m_TruncatedContinuousValueDistributionEClass->setEPackage(_this());
        getEClassifiers().push_back(
                m_TruncatedContinuousValueDistributionEClass);
    }
    // m_TruncatedContinuousValueDistribution__lowerBound has already been allocated above
    m_TruncatedContinuousValueDistribution__lowerBound->setFeatureID(
            ::amalthea::AmaltheaPackage::TRUNCATEDCONTINUOUSVALUEDISTRIBUTION__LOWERBOUND);
    m_TruncatedContinuousValueDistributionEClass->getEStructuralFeatures().push_back(
            m_TruncatedContinuousValueDistribution__lowerBound);
    // m_TruncatedContinuousValueDistribution__upperBound has already been allocated above
    m_TruncatedContinuousValueDistribution__upperBound->setFeatureID(
            ::amalthea::AmaltheaPackage::TRUNCATEDCONTINUOUSVALUEDISTRIBUTION__UPPERBOUND);
    m_TruncatedContinuousValueDistributionEClass->getEStructuralFeatures().push_back(
            m_TruncatedContinuousValueDistribution__upperBound);

    // ContinuousValueBoundaries
    {
        m_ContinuousValueBoundariesEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_ContinuousValueBoundariesEClass->setClassifierID(
                CONTINUOUSVALUEBOUNDARIES);
        m_ContinuousValueBoundariesEClass->setEPackage(_this());
        getEClassifiers().push_back(m_ContinuousValueBoundariesEClass);
    }
    // m_ContinuousValueBoundaries__samplingType has already been allocated above
    m_ContinuousValueBoundaries__samplingType->setFeatureID(
            ::amalthea::AmaltheaPackage::CONTINUOUSVALUEBOUNDARIES__SAMPLINGTYPE);
    m_ContinuousValueBoundariesEClass->getEStructuralFeatures().push_back(
            m_ContinuousValueBoundaries__samplingType);

    // ContinuousValueStatistics
    {
        m_ContinuousValueStatisticsEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_ContinuousValueStatisticsEClass->setClassifierID(
                CONTINUOUSVALUESTATISTICS);
        m_ContinuousValueStatisticsEClass->setEPackage(_this());
        getEClassifiers().push_back(m_ContinuousValueStatisticsEClass);
    }
    // m_ContinuousValueStatistics__average has already been allocated above
    m_ContinuousValueStatistics__average->setFeatureID(
            ::amalthea::AmaltheaPackage::CONTINUOUSVALUESTATISTICS__AVERAGE);
    m_ContinuousValueStatisticsEClass->getEStructuralFeatures().push_back(
            m_ContinuousValueStatistics__average);

    // ContinuousValueUniformDistribution
    {
        m_ContinuousValueUniformDistributionEClass = ::ecore::Ptr
                < ::ecore::EClass > (new ::ecore::EClass);
        m_ContinuousValueUniformDistributionEClass->setClassifierID(
                CONTINUOUSVALUEUNIFORMDISTRIBUTION);
        m_ContinuousValueUniformDistributionEClass->setEPackage(_this());
        getEClassifiers().push_back(m_ContinuousValueUniformDistributionEClass);
    }

    // ContinuousValueGaussDistribution
    {
        m_ContinuousValueGaussDistributionEClass = ::ecore::Ptr
                < ::ecore::EClass > (new ::ecore::EClass);
        m_ContinuousValueGaussDistributionEClass->setClassifierID(
                CONTINUOUSVALUEGAUSSDISTRIBUTION);
        m_ContinuousValueGaussDistributionEClass->setEPackage(_this());
        getEClassifiers().push_back(m_ContinuousValueGaussDistributionEClass);
    }
    // m_ContinuousValueGaussDistribution__mean has already been allocated above
    m_ContinuousValueGaussDistribution__mean->setFeatureID(
            ::amalthea::AmaltheaPackage::CONTINUOUSVALUEGAUSSDISTRIBUTION__MEAN);
    m_ContinuousValueGaussDistributionEClass->getEStructuralFeatures().push_back(
            m_ContinuousValueGaussDistribution__mean);
    // m_ContinuousValueGaussDistribution__sd has already been allocated above
    m_ContinuousValueGaussDistribution__sd->setFeatureID(
            ::amalthea::AmaltheaPackage::CONTINUOUSVALUEGAUSSDISTRIBUTION__SD);
    m_ContinuousValueGaussDistributionEClass->getEStructuralFeatures().push_back(
            m_ContinuousValueGaussDistribution__sd);

    // ContinuousValueWeibullEstimatorsDistribution
    {
        m_ContinuousValueWeibullEstimatorsDistributionEClass = ::ecore::Ptr
                < ::ecore::EClass > (new ::ecore::EClass);
        m_ContinuousValueWeibullEstimatorsDistributionEClass->setClassifierID(
                CONTINUOUSVALUEWEIBULLESTIMATORSDISTRIBUTION);
        m_ContinuousValueWeibullEstimatorsDistributionEClass->setEPackage(
                _this());
        getEClassifiers().push_back(
                m_ContinuousValueWeibullEstimatorsDistributionEClass);
    }
    // m_ContinuousValueWeibullEstimatorsDistribution__average has already been allocated above
    m_ContinuousValueWeibullEstimatorsDistribution__average->setFeatureID(
            ::amalthea::AmaltheaPackage::CONTINUOUSVALUEWEIBULLESTIMATORSDISTRIBUTION__AVERAGE);
    m_ContinuousValueWeibullEstimatorsDistributionEClass->getEStructuralFeatures().push_back(
            m_ContinuousValueWeibullEstimatorsDistribution__average);
    // m_ContinuousValueWeibullEstimatorsDistribution__pRemainPromille has already been allocated above
    m_ContinuousValueWeibullEstimatorsDistribution__pRemainPromille->setFeatureID(
            ::amalthea::AmaltheaPackage::CONTINUOUSVALUEWEIBULLESTIMATORSDISTRIBUTION__PREMAINPROMILLE);
    m_ContinuousValueWeibullEstimatorsDistributionEClass->getEStructuralFeatures().push_back(
            m_ContinuousValueWeibullEstimatorsDistribution__pRemainPromille);

    // ContinuousValueBetaDistribution
    {
        m_ContinuousValueBetaDistributionEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_ContinuousValueBetaDistributionEClass->setClassifierID(
                CONTINUOUSVALUEBETADISTRIBUTION);
        m_ContinuousValueBetaDistributionEClass->setEPackage(_this());
        getEClassifiers().push_back(m_ContinuousValueBetaDistributionEClass);
    }
    // m_ContinuousValueBetaDistribution__alpha has already been allocated above
    m_ContinuousValueBetaDistribution__alpha->setFeatureID(
            ::amalthea::AmaltheaPackage::CONTINUOUSVALUEBETADISTRIBUTION__ALPHA);
    m_ContinuousValueBetaDistributionEClass->getEStructuralFeatures().push_back(
            m_ContinuousValueBetaDistribution__alpha);
    // m_ContinuousValueBetaDistribution__beta has already been allocated above
    m_ContinuousValueBetaDistribution__beta->setFeatureID(
            ::amalthea::AmaltheaPackage::CONTINUOUSVALUEBETADISTRIBUTION__BETA);
    m_ContinuousValueBetaDistributionEClass->getEStructuralFeatures().push_back(
            m_ContinuousValueBetaDistribution__beta);

    // Mode
    {
        m_ModeEClass = ::ecore::Ptr < ::ecore::EClass > (new ::ecore::EClass);
        m_ModeEClass->setClassifierID(MODE);
        m_ModeEClass->setEPackage(_this());
        getEClassifiers().push_back(m_ModeEClass);
    }

    // NumericMode
    {
        m_NumericModeEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_NumericModeEClass->setClassifierID(NUMERICMODE);
        m_NumericModeEClass->setEPackage(_this());
        getEClassifiers().push_back(m_NumericModeEClass);
    }

    // EnumMode
    {
        m_EnumModeEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_EnumModeEClass->setClassifierID(ENUMMODE);
        m_EnumModeEClass->setEPackage(_this());
        getEClassifiers().push_back(m_EnumModeEClass);
    }
    // m_EnumMode__literals has already been allocated above
    m_EnumMode__literals->setFeatureID(
            ::amalthea::AmaltheaPackage::ENUMMODE__LITERALS);
    m_EnumModeEClass->getEStructuralFeatures().push_back(m_EnumMode__literals);

    // ModeLiteral
    {
        m_ModeLiteralEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_ModeLiteralEClass->setClassifierID(MODELITERAL);
        m_ModeLiteralEClass->setEPackage(_this());
        getEClassifiers().push_back(m_ModeLiteralEClass);
    }
    // m_ModeLiteral__containingMode has already been allocated above
    m_ModeLiteral__containingMode->setFeatureID(
            ::amalthea::AmaltheaPackage::MODELITERAL__CONTAININGMODE);
    m_ModeLiteralEClass->getEStructuralFeatures().push_back(
            m_ModeLiteral__containingMode);

    // ComponentsModel
    {
        m_ComponentsModelEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_ComponentsModelEClass->setClassifierID(COMPONENTSMODEL);
        m_ComponentsModelEClass->setEPackage(_this());
        getEClassifiers().push_back(m_ComponentsModelEClass);
    }
    // m_ComponentsModel__structures has already been allocated above
    m_ComponentsModel__structures->setFeatureID(
            ::amalthea::AmaltheaPackage::COMPONENTSMODEL__STRUCTURES);
    m_ComponentsModelEClass->getEStructuralFeatures().push_back(
            m_ComponentsModel__structures);
    // m_ComponentsModel__systems has already been allocated above
    m_ComponentsModel__systems->setFeatureID(
            ::amalthea::AmaltheaPackage::COMPONENTSMODEL__SYSTEMS);
    m_ComponentsModelEClass->getEStructuralFeatures().push_back(
            m_ComponentsModel__systems);

    // IComponentContainer
    {
        m_IComponentContainerEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_IComponentContainerEClass->setClassifierID(ICOMPONENTCONTAINER);
        m_IComponentContainerEClass->setEPackage(_this());
        getEClassifiers().push_back(m_IComponentContainerEClass);
    }
    // m_IComponentContainer__components has already been allocated above
    m_IComponentContainer__components->setFeatureID(
            ::amalthea::AmaltheaPackage::ICOMPONENTCONTAINER__COMPONENTS);
    m_IComponentContainerEClass->getEStructuralFeatures().push_back(
            m_IComponentContainer__components);

    // IInterfaceContainer
    {
        m_IInterfaceContainerEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_IInterfaceContainerEClass->setClassifierID(IINTERFACECONTAINER);
        m_IInterfaceContainerEClass->setEPackage(_this());
        getEClassifiers().push_back(m_IInterfaceContainerEClass);
    }
    // m_IInterfaceContainer__interfaces has already been allocated above
    m_IInterfaceContainer__interfaces->setFeatureID(
            ::amalthea::AmaltheaPackage::IINTERFACECONTAINER__INTERFACES);
    m_IInterfaceContainerEClass->getEStructuralFeatures().push_back(
            m_IInterfaceContainer__interfaces);

    // ISystem
    {
        m_ISystemEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_ISystemEClass->setClassifierID(ISYSTEM);
        m_ISystemEClass->setEPackage(_this());
        getEClassifiers().push_back(m_ISystemEClass);
    }
    // m_ISystem__componentInstances has already been allocated above
    m_ISystem__componentInstances->setFeatureID(
            ::amalthea::AmaltheaPackage::ISYSTEM__COMPONENTINSTANCES);
    m_ISystemEClass->getEStructuralFeatures().push_back(
            m_ISystem__componentInstances);
    // m_ISystem__connectors has already been allocated above
    m_ISystem__connectors->setFeatureID(
            ::amalthea::AmaltheaPackage::ISYSTEM__CONNECTORS);
    m_ISystemEClass->getEStructuralFeatures().push_back(m_ISystem__connectors);
    // m_ISystem__groundedPorts has already been allocated above
    m_ISystem__groundedPorts->setFeatureID(
            ::amalthea::AmaltheaPackage::ISYSTEM__GROUNDEDPORTS);
    m_ISystemEClass->getEStructuralFeatures().push_back(
            m_ISystem__groundedPorts);
    // m_ISystem__innerPorts has already been allocated above
    m_ISystem__innerPorts->setFeatureID(
            ::amalthea::AmaltheaPackage::ISYSTEM__INNERPORTS);
    m_ISystemEClass->getEStructuralFeatures().push_back(m_ISystem__innerPorts);

    // ComponentInterface
    {
        m_ComponentInterfaceEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_ComponentInterfaceEClass->setClassifierID(COMPONENTINTERFACE);
        m_ComponentInterfaceEClass->setEPackage(_this());
        getEClassifiers().push_back(m_ComponentInterfaceEClass);
    }
    // m_ComponentInterface__datatype has already been allocated above
    m_ComponentInterface__datatype->setFeatureID(
            ::amalthea::AmaltheaPackage::COMPONENTINTERFACE__DATATYPE);
    m_ComponentInterfaceEClass->getEStructuralFeatures().push_back(
            m_ComponentInterface__datatype);
    // m_ComponentInterface__subInterfaces has already been allocated above
    m_ComponentInterface__subInterfaces->setFeatureID(
            ::amalthea::AmaltheaPackage::COMPONENTINTERFACE__SUBINTERFACES);
    m_ComponentInterfaceEClass->getEStructuralFeatures().push_back(
            m_ComponentInterface__subInterfaces);

    // MainInterface
    {
        m_MainInterfaceEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_MainInterfaceEClass->setClassifierID(MAININTERFACE);
        m_MainInterfaceEClass->setEPackage(_this());
        getEClassifiers().push_back(m_MainInterfaceEClass);
    }
    // m_MainInterface__version has already been allocated above
    m_MainInterface__version->setFeatureID(
            ::amalthea::AmaltheaPackage::MAININTERFACE__VERSION);
    m_MainInterfaceEClass->getEStructuralFeatures().push_back(
            m_MainInterface__version);

    // SubInterface
    {
        m_SubInterfaceEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_SubInterfaceEClass->setClassifierID(SUBINTERFACE);
        m_SubInterfaceEClass->setEPackage(_this());
        getEClassifiers().push_back(m_SubInterfaceEClass);
    }
    // m_SubInterface__containingInterface has already been allocated above
    m_SubInterface__containingInterface->setFeatureID(
            ::amalthea::AmaltheaPackage::SUBINTERFACE__CONTAININGINTERFACE);
    m_SubInterfaceEClass->getEStructuralFeatures().push_back(
            m_SubInterface__containingInterface);

    // ComponentPort
    {
        m_ComponentPortEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_ComponentPortEClass->setClassifierID(COMPONENTPORT);
        m_ComponentPortEClass->setEPackage(_this());
        getEClassifiers().push_back(m_ComponentPortEClass);
    }
    // m_ComponentPort__kind has already been allocated above
    m_ComponentPort__kind->setFeatureID(
            ::amalthea::AmaltheaPackage::COMPONENTPORT__KIND);
    m_ComponentPortEClass->getEStructuralFeatures().push_back(
            m_ComponentPort__kind);
    // m_ComponentPort__containingComponent has already been allocated above
    m_ComponentPort__containingComponent->setFeatureID(
            ::amalthea::AmaltheaPackage::COMPONENTPORT__CONTAININGCOMPONENT);
    m_ComponentPortEClass->getEStructuralFeatures().push_back(
            m_ComponentPort__containingComponent);
    // m_ComponentPort__interface has already been allocated above
    m_ComponentPort__interface->setFeatureID(
            ::amalthea::AmaltheaPackage::COMPONENTPORT__INTERFACE);
    m_ComponentPortEClass->getEStructuralFeatures().push_back(
            m_ComponentPort__interface);

    // ComponentStructure
    {
        m_ComponentStructureEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_ComponentStructureEClass->setClassifierID(COMPONENTSTRUCTURE);
        m_ComponentStructureEClass->setEPackage(_this());
        getEClassifiers().push_back(m_ComponentStructureEClass);
    }
    // m_ComponentStructure__structureType has already been allocated above
    m_ComponentStructure__structureType->setFeatureID(
            ::amalthea::AmaltheaPackage::COMPONENTSTRUCTURE__STRUCTURETYPE);
    m_ComponentStructureEClass->getEStructuralFeatures().push_back(
            m_ComponentStructure__structureType);
    // m_ComponentStructure__subStructures has already been allocated above
    m_ComponentStructure__subStructures->setFeatureID(
            ::amalthea::AmaltheaPackage::COMPONENTSTRUCTURE__SUBSTRUCTURES);
    m_ComponentStructureEClass->getEStructuralFeatures().push_back(
            m_ComponentStructure__subStructures);
    // m_ComponentStructure__memberObjects has already been allocated above
    m_ComponentStructure__memberObjects->setFeatureID(
            ::amalthea::AmaltheaPackage::COMPONENTSTRUCTURE__MEMBEROBJECTS);
    m_ComponentStructureEClass->getEStructuralFeatures().push_back(
            m_ComponentStructure__memberObjects);

    // IComponentStructureMember
    {
        m_IComponentStructureMemberEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_IComponentStructureMemberEClass->setClassifierID(
                ICOMPONENTSTRUCTUREMEMBER);
        m_IComponentStructureMemberEClass->setEPackage(_this());
        getEClassifiers().push_back(m_IComponentStructureMemberEClass);
    }
    // m_IComponentStructureMember__structure has already been allocated above
    m_IComponentStructureMember__structure->setFeatureID(
            ::amalthea::AmaltheaPackage::ICOMPONENTSTRUCTUREMEMBER__STRUCTURE);
    m_IComponentStructureMemberEClass->getEStructuralFeatures().push_back(
            m_IComponentStructureMember__structure);

    // Component
    {
        m_ComponentEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_ComponentEClass->setClassifierID(COMPONENT);
        m_ComponentEClass->setEPackage(_this());
        getEClassifiers().push_back(m_ComponentEClass);
    }
    // m_Component__ports has already been allocated above
    m_Component__ports->setFeatureID(
            ::amalthea::AmaltheaPackage::COMPONENT__PORTS);
    m_ComponentEClass->getEStructuralFeatures().push_back(m_Component__ports);
    // m_Component__processes has already been allocated above
    m_Component__processes->setFeatureID(
            ::amalthea::AmaltheaPackage::COMPONENT__PROCESSES);
    m_ComponentEClass->getEStructuralFeatures().push_back(
            m_Component__processes);
    // m_Component__runnables has already been allocated above
    m_Component__runnables->setFeatureID(
            ::amalthea::AmaltheaPackage::COMPONENT__RUNNABLES);
    m_ComponentEClass->getEStructuralFeatures().push_back(
            m_Component__runnables);
    // m_Component__labels has already been allocated above
    m_Component__labels->setFeatureID(
            ::amalthea::AmaltheaPackage::COMPONENT__LABELS);
    m_ComponentEClass->getEStructuralFeatures().push_back(m_Component__labels);
    // m_Component__semaphores has already been allocated above
    m_Component__semaphores->setFeatureID(
            ::amalthea::AmaltheaPackage::COMPONENT__SEMAPHORES);
    m_ComponentEClass->getEStructuralFeatures().push_back(
            m_Component__semaphores);
    // m_Component__osEvents has already been allocated above
    m_Component__osEvents->setFeatureID(
            ::amalthea::AmaltheaPackage::COMPONENT__OSEVENTS);
    m_ComponentEClass->getEStructuralFeatures().push_back(
            m_Component__osEvents);

    // Composite
    {
        m_CompositeEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_CompositeEClass->setClassifierID(COMPOSITE);
        m_CompositeEClass->setEPackage(_this());
        getEClassifiers().push_back(m_CompositeEClass);
    }

    // System
    {
        m_SystemEClass = ::ecore::Ptr < ::ecore::EClass > (new ::ecore::EClass);
        m_SystemEClass->setClassifierID(SYSTEM);
        m_SystemEClass->setEPackage(_this());
        getEClassifiers().push_back(m_SystemEClass);
    }

    // ComponentInstance
    {
        m_ComponentInstanceEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_ComponentInstanceEClass->setClassifierID(COMPONENTINSTANCE);
        m_ComponentInstanceEClass->setEPackage(_this());
        getEClassifiers().push_back(m_ComponentInstanceEClass);
    }
    // m_ComponentInstance__containingSystem has already been allocated above
    m_ComponentInstance__containingSystem->setFeatureID(
            ::amalthea::AmaltheaPackage::COMPONENTINSTANCE__CONTAININGSYSTEM);
    m_ComponentInstanceEClass->getEStructuralFeatures().push_back(
            m_ComponentInstance__containingSystem);
    // m_ComponentInstance__type has already been allocated above
    m_ComponentInstance__type->setFeatureID(
            ::amalthea::AmaltheaPackage::COMPONENTINSTANCE__TYPE);
    m_ComponentInstanceEClass->getEStructuralFeatures().push_back(
            m_ComponentInstance__type);

    // Connector
    {
        m_ConnectorEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_ConnectorEClass->setClassifierID(CONNECTOR);
        m_ConnectorEClass->setEPackage(_this());
        getEClassifiers().push_back(m_ConnectorEClass);
    }
    // m_Connector__containingSystem has already been allocated above
    m_Connector__containingSystem->setFeatureID(
            ::amalthea::AmaltheaPackage::CONNECTOR__CONTAININGSYSTEM);
    m_ConnectorEClass->getEStructuralFeatures().push_back(
            m_Connector__containingSystem);
    // m_Connector__sourcePort has already been allocated above
    m_Connector__sourcePort->setFeatureID(
            ::amalthea::AmaltheaPackage::CONNECTOR__SOURCEPORT);
    m_ConnectorEClass->getEStructuralFeatures().push_back(
            m_Connector__sourcePort);
    // m_Connector__targetPort has already been allocated above
    m_Connector__targetPort->setFeatureID(
            ::amalthea::AmaltheaPackage::CONNECTOR__TARGETPORT);
    m_ConnectorEClass->getEStructuralFeatures().push_back(
            m_Connector__targetPort);
    // m_Connector__implementedInterfaces has already been allocated above
    m_Connector__implementedInterfaces->setFeatureID(
            ::amalthea::AmaltheaPackage::CONNECTOR__IMPLEMENTEDINTERFACES);
    m_ConnectorEClass->getEStructuralFeatures().push_back(
            m_Connector__implementedInterfaces);

    // InterfaceChannel
    {
        m_InterfaceChannelEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_InterfaceChannelEClass->setClassifierID(INTERFACECHANNEL);
        m_InterfaceChannelEClass->setEPackage(_this());
        getEClassifiers().push_back(m_InterfaceChannelEClass);
    }
    // m_InterfaceChannel__key has already been allocated above
    m_InterfaceChannel__key->setFeatureID(
            ::amalthea::AmaltheaPackage::INTERFACECHANNEL__KEY);
    m_InterfaceChannelEClass->getEStructuralFeatures().push_back(
            m_InterfaceChannel__key);
    // m_InterfaceChannel__value has already been allocated above
    m_InterfaceChannel__value->setFeatureID(
            ::amalthea::AmaltheaPackage::INTERFACECHANNEL__VALUE);
    m_InterfaceChannelEClass->getEStructuralFeatures().push_back(
            m_InterfaceChannel__value);

    // QualifiedPort
    {
        m_QualifiedPortEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_QualifiedPortEClass->setClassifierID(QUALIFIEDPORT);
        m_QualifiedPortEClass->setEPackage(_this());
        getEClassifiers().push_back(m_QualifiedPortEClass);
    }
    // m_QualifiedPort__instance has already been allocated above
    m_QualifiedPort__instance->setFeatureID(
            ::amalthea::AmaltheaPackage::QUALIFIEDPORT__INSTANCE);
    m_QualifiedPortEClass->getEStructuralFeatures().push_back(
            m_QualifiedPort__instance);
    // m_QualifiedPort__port has already been allocated above
    m_QualifiedPort__port->setFeatureID(
            ::amalthea::AmaltheaPackage::QUALIFIEDPORT__PORT);
    m_QualifiedPortEClass->getEStructuralFeatures().push_back(
            m_QualifiedPort__port);

    // ConfigModel
    {
        m_ConfigModelEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_ConfigModelEClass->setClassifierID(CONFIGMODEL);
        m_ConfigModelEClass->setEPackage(_this());
        getEClassifiers().push_back(m_ConfigModelEClass);
    }
    // m_ConfigModel__eventsToTrace has already been allocated above
    m_ConfigModel__eventsToTrace->setFeatureID(
            ::amalthea::AmaltheaPackage::CONFIGMODEL__EVENTSTOTRACE);
    m_ConfigModelEClass->getEStructuralFeatures().push_back(
            m_ConfigModel__eventsToTrace);

    // EventConfig
    {
        m_EventConfigEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_EventConfigEClass->setClassifierID(EVENTCONFIG);
        m_EventConfigEClass->setEPackage(_this());
        getEClassifiers().push_back(m_EventConfigEClass);
    }
    // m_EventConfig__event has already been allocated above
    m_EventConfig__event->setFeatureID(
            ::amalthea::AmaltheaPackage::EVENTCONFIG__EVENT);
    m_EventConfigEClass->getEStructuralFeatures().push_back(
            m_EventConfig__event);

    // ConstraintsModel
    {
        m_ConstraintsModelEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_ConstraintsModelEClass->setClassifierID(CONSTRAINTSMODEL);
        m_ConstraintsModelEClass->setEPackage(_this());
        getEClassifiers().push_back(m_ConstraintsModelEClass);
    }
    // m_ConstraintsModel__eventChains has already been allocated above
    m_ConstraintsModel__eventChains->setFeatureID(
            ::amalthea::AmaltheaPackage::CONSTRAINTSMODEL__EVENTCHAINS);
    m_ConstraintsModelEClass->getEStructuralFeatures().push_back(
            m_ConstraintsModel__eventChains);
    // m_ConstraintsModel__timingConstraints has already been allocated above
    m_ConstraintsModel__timingConstraints->setFeatureID(
            ::amalthea::AmaltheaPackage::CONSTRAINTSMODEL__TIMINGCONSTRAINTS);
    m_ConstraintsModelEClass->getEStructuralFeatures().push_back(
            m_ConstraintsModel__timingConstraints);
    // m_ConstraintsModel__affinityConstraints has already been allocated above
    m_ConstraintsModel__affinityConstraints->setFeatureID(
            ::amalthea::AmaltheaPackage::CONSTRAINTSMODEL__AFFINITYCONSTRAINTS);
    m_ConstraintsModelEClass->getEStructuralFeatures().push_back(
            m_ConstraintsModel__affinityConstraints);
    // m_ConstraintsModel__runnableSequencingConstraints has already been allocated above
    m_ConstraintsModel__runnableSequencingConstraints->setFeatureID(
            ::amalthea::AmaltheaPackage::CONSTRAINTSMODEL__RUNNABLESEQUENCINGCONSTRAINTS);
    m_ConstraintsModelEClass->getEStructuralFeatures().push_back(
            m_ConstraintsModel__runnableSequencingConstraints);
    // m_ConstraintsModel__dataAgeConstraints has already been allocated above
    m_ConstraintsModel__dataAgeConstraints->setFeatureID(
            ::amalthea::AmaltheaPackage::CONSTRAINTSMODEL__DATAAGECONSTRAINTS);
    m_ConstraintsModelEClass->getEStructuralFeatures().push_back(
            m_ConstraintsModel__dataAgeConstraints);
    // m_ConstraintsModel__requirements has already been allocated above
    m_ConstraintsModel__requirements->setFeatureID(
            ::amalthea::AmaltheaPackage::CONSTRAINTSMODEL__REQUIREMENTS);
    m_ConstraintsModelEClass->getEStructuralFeatures().push_back(
            m_ConstraintsModel__requirements);
    // m_ConstraintsModel__dataCoherencyGroups has already been allocated above
    m_ConstraintsModel__dataCoherencyGroups->setFeatureID(
            ::amalthea::AmaltheaPackage::CONSTRAINTSMODEL__DATACOHERENCYGROUPS);
    m_ConstraintsModelEClass->getEStructuralFeatures().push_back(
            m_ConstraintsModel__dataCoherencyGroups);
    // m_ConstraintsModel__dataStabilityGroups has already been allocated above
    m_ConstraintsModel__dataStabilityGroups->setFeatureID(
            ::amalthea::AmaltheaPackage::CONSTRAINTSMODEL__DATASTABILITYGROUPS);
    m_ConstraintsModelEClass->getEStructuralFeatures().push_back(
            m_ConstraintsModel__dataStabilityGroups);
    // m_ConstraintsModel__physicalSectionConstraints has already been allocated above
    m_ConstraintsModel__physicalSectionConstraints->setFeatureID(
            ::amalthea::AmaltheaPackage::CONSTRAINTSMODEL__PHYSICALSECTIONCONSTRAINTS);
    m_ConstraintsModelEClass->getEStructuralFeatures().push_back(
            m_ConstraintsModel__physicalSectionConstraints);

    // RunnableSequencingConstraint
    {
        m_RunnableSequencingConstraintEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_RunnableSequencingConstraintEClass->setClassifierID(
                RUNNABLESEQUENCINGCONSTRAINT);
        m_RunnableSequencingConstraintEClass->setEPackage(_this());
        getEClassifiers().push_back(m_RunnableSequencingConstraintEClass);
    }
    // m_RunnableSequencingConstraint__orderType has already been allocated above
    m_RunnableSequencingConstraint__orderType->setFeatureID(
            ::amalthea::AmaltheaPackage::RUNNABLESEQUENCINGCONSTRAINT__ORDERTYPE);
    m_RunnableSequencingConstraintEClass->getEStructuralFeatures().push_back(
            m_RunnableSequencingConstraint__orderType);
    // m_RunnableSequencingConstraint__runnableGroups has already been allocated above
    m_RunnableSequencingConstraint__runnableGroups->setFeatureID(
            ::amalthea::AmaltheaPackage::RUNNABLESEQUENCINGCONSTRAINT__RUNNABLEGROUPS);
    m_RunnableSequencingConstraintEClass->getEStructuralFeatures().push_back(
            m_RunnableSequencingConstraint__runnableGroups);
    // m_RunnableSequencingConstraint__processScope has already been allocated above
    m_RunnableSequencingConstraint__processScope->setFeatureID(
            ::amalthea::AmaltheaPackage::RUNNABLESEQUENCINGCONSTRAINT__PROCESSSCOPE);
    m_RunnableSequencingConstraintEClass->getEStructuralFeatures().push_back(
            m_RunnableSequencingConstraint__processScope);

    // AffinityConstraint
    {
        m_AffinityConstraintEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_AffinityConstraintEClass->setClassifierID(AFFINITYCONSTRAINT);
        m_AffinityConstraintEClass->setEPackage(_this());
        getEClassifiers().push_back(m_AffinityConstraintEClass);
    }

    // SeparationConstraint
    {
        m_SeparationConstraintEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_SeparationConstraintEClass->setClassifierID(SEPARATIONCONSTRAINT);
        m_SeparationConstraintEClass->setEPackage(_this());
        getEClassifiers().push_back(m_SeparationConstraintEClass);
    }

    // PairingConstraint
    {
        m_PairingConstraintEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_PairingConstraintEClass->setClassifierID(PAIRINGCONSTRAINT);
        m_PairingConstraintEClass->setEPackage(_this());
        getEClassifiers().push_back(m_PairingConstraintEClass);
    }

    // ProcessConstraint
    {
        m_ProcessConstraintEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_ProcessConstraintEClass->setClassifierID(PROCESSCONSTRAINT);
        m_ProcessConstraintEClass->setEPackage(_this());
        getEClassifiers().push_back(m_ProcessConstraintEClass);
    }
    // m_ProcessConstraint__target has already been allocated above
    m_ProcessConstraint__target->setFeatureID(
            ::amalthea::AmaltheaPackage::PROCESSCONSTRAINT__TARGET);
    m_ProcessConstraintEClass->getEStructuralFeatures().push_back(
            m_ProcessConstraint__target);

    // RunnableConstraint
    {
        m_RunnableConstraintEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_RunnableConstraintEClass->setClassifierID(RUNNABLECONSTRAINT);
        m_RunnableConstraintEClass->setEPackage(_this());
        getEClassifiers().push_back(m_RunnableConstraintEClass);
    }
    // m_RunnableConstraint__target has already been allocated above
    m_RunnableConstraint__target->setFeatureID(
            ::amalthea::AmaltheaPackage::RUNNABLECONSTRAINT__TARGET);
    m_RunnableConstraintEClass->getEStructuralFeatures().push_back(
            m_RunnableConstraint__target);

    // DataConstraint
    {
        m_DataConstraintEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_DataConstraintEClass->setClassifierID(DATACONSTRAINT);
        m_DataConstraintEClass->setEPackage(_this());
        getEClassifiers().push_back(m_DataConstraintEClass);
    }
    // m_DataConstraint__target has already been allocated above
    m_DataConstraint__target->setFeatureID(
            ::amalthea::AmaltheaPackage::DATACONSTRAINT__TARGET);
    m_DataConstraintEClass->getEStructuralFeatures().push_back(
            m_DataConstraint__target);

    // RunnableSeparationConstraint
    {
        m_RunnableSeparationConstraintEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_RunnableSeparationConstraintEClass->setClassifierID(
                RUNNABLESEPARATIONCONSTRAINT);
        m_RunnableSeparationConstraintEClass->setEPackage(_this());
        getEClassifiers().push_back(m_RunnableSeparationConstraintEClass);
    }
    // m_RunnableSeparationConstraint__groups has already been allocated above
    m_RunnableSeparationConstraint__groups->setFeatureID(
            ::amalthea::AmaltheaPackage::RUNNABLESEPARATIONCONSTRAINT__GROUPS);
    m_RunnableSeparationConstraintEClass->getEStructuralFeatures().push_back(
            m_RunnableSeparationConstraint__groups);

    // ProcessSeparationConstraint
    {
        m_ProcessSeparationConstraintEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_ProcessSeparationConstraintEClass->setClassifierID(
                PROCESSSEPARATIONCONSTRAINT);
        m_ProcessSeparationConstraintEClass->setEPackage(_this());
        getEClassifiers().push_back(m_ProcessSeparationConstraintEClass);
    }
    // m_ProcessSeparationConstraint__groups has already been allocated above
    m_ProcessSeparationConstraint__groups->setFeatureID(
            ::amalthea::AmaltheaPackage::PROCESSSEPARATIONCONSTRAINT__GROUPS);
    m_ProcessSeparationConstraintEClass->getEStructuralFeatures().push_back(
            m_ProcessSeparationConstraint__groups);

    // DataSeparationConstraint
    {
        m_DataSeparationConstraintEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_DataSeparationConstraintEClass->setClassifierID(
                DATASEPARATIONCONSTRAINT);
        m_DataSeparationConstraintEClass->setEPackage(_this());
        getEClassifiers().push_back(m_DataSeparationConstraintEClass);
    }
    // m_DataSeparationConstraint__groups has already been allocated above
    m_DataSeparationConstraint__groups->setFeatureID(
            ::amalthea::AmaltheaPackage::DATASEPARATIONCONSTRAINT__GROUPS);
    m_DataSeparationConstraintEClass->getEStructuralFeatures().push_back(
            m_DataSeparationConstraint__groups);

    // RunnablePairingConstraint
    {
        m_RunnablePairingConstraintEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_RunnablePairingConstraintEClass->setClassifierID(
                RUNNABLEPAIRINGCONSTRAINT);
        m_RunnablePairingConstraintEClass->setEPackage(_this());
        getEClassifiers().push_back(m_RunnablePairingConstraintEClass);
    }
    // m_RunnablePairingConstraint__group has already been allocated above
    m_RunnablePairingConstraint__group->setFeatureID(
            ::amalthea::AmaltheaPackage::RUNNABLEPAIRINGCONSTRAINT__GROUP);
    m_RunnablePairingConstraintEClass->getEStructuralFeatures().push_back(
            m_RunnablePairingConstraint__group);

    // ProcessPairingConstraint
    {
        m_ProcessPairingConstraintEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_ProcessPairingConstraintEClass->setClassifierID(
                PROCESSPAIRINGCONSTRAINT);
        m_ProcessPairingConstraintEClass->setEPackage(_this());
        getEClassifiers().push_back(m_ProcessPairingConstraintEClass);
    }
    // m_ProcessPairingConstraint__group has already been allocated above
    m_ProcessPairingConstraint__group->setFeatureID(
            ::amalthea::AmaltheaPackage::PROCESSPAIRINGCONSTRAINT__GROUP);
    m_ProcessPairingConstraintEClass->getEStructuralFeatures().push_back(
            m_ProcessPairingConstraint__group);

    // DataPairingConstraint
    {
        m_DataPairingConstraintEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_DataPairingConstraintEClass->setClassifierID(DATAPAIRINGCONSTRAINT);
        m_DataPairingConstraintEClass->setEPackage(_this());
        getEClassifiers().push_back(m_DataPairingConstraintEClass);
    }
    // m_DataPairingConstraint__group has already been allocated above
    m_DataPairingConstraint__group->setFeatureID(
            ::amalthea::AmaltheaPackage::DATAPAIRINGCONSTRAINT__GROUP);
    m_DataPairingConstraintEClass->getEStructuralFeatures().push_back(
            m_DataPairingConstraint__group);

    // RunnableConstraintTarget
    {
        m_RunnableConstraintTargetEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_RunnableConstraintTargetEClass->setClassifierID(
                RUNNABLECONSTRAINTTARGET);
        m_RunnableConstraintTargetEClass->setEPackage(_this());
        getEClassifiers().push_back(m_RunnableConstraintTargetEClass);
    }

    // ProcessConstraintTarget
    {
        m_ProcessConstraintTargetEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_ProcessConstraintTargetEClass->setClassifierID(
                PROCESSCONSTRAINTTARGET);
        m_ProcessConstraintTargetEClass->setEPackage(_this());
        getEClassifiers().push_back(m_ProcessConstraintTargetEClass);
    }

    // DataConstraintTarget
    {
        m_DataConstraintTargetEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_DataConstraintTargetEClass->setClassifierID(DATACONSTRAINTTARGET);
        m_DataConstraintTargetEClass->setEPackage(_this());
        getEClassifiers().push_back(m_DataConstraintTargetEClass);
    }

    // TargetMemory
    {
        m_TargetMemoryEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_TargetMemoryEClass->setClassifierID(TARGETMEMORY);
        m_TargetMemoryEClass->setEPackage(_this());
        getEClassifiers().push_back(m_TargetMemoryEClass);
    }
    // m_TargetMemory__memories has already been allocated above
    m_TargetMemory__memories->setFeatureID(
            ::amalthea::AmaltheaPackage::TARGETMEMORY__MEMORIES);
    m_TargetMemoryEClass->getEStructuralFeatures().push_back(
            m_TargetMemory__memories);

    // TargetCore
    {
        m_TargetCoreEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_TargetCoreEClass->setClassifierID(TARGETCORE);
        m_TargetCoreEClass->setEPackage(_this());
        getEClassifiers().push_back(m_TargetCoreEClass);
    }
    // m_TargetCore__cores has already been allocated above
    m_TargetCore__cores->setFeatureID(
            ::amalthea::AmaltheaPackage::TARGETCORE__CORES);
    m_TargetCoreEClass->getEStructuralFeatures().push_back(m_TargetCore__cores);

    // TargetScheduler
    {
        m_TargetSchedulerEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_TargetSchedulerEClass->setClassifierID(TARGETSCHEDULER);
        m_TargetSchedulerEClass->setEPackage(_this());
        getEClassifiers().push_back(m_TargetSchedulerEClass);
    }
    // m_TargetScheduler__schedulers has already been allocated above
    m_TargetScheduler__schedulers->setFeatureID(
            ::amalthea::AmaltheaPackage::TARGETSCHEDULER__SCHEDULERS);
    m_TargetSchedulerEClass->getEStructuralFeatures().push_back(
            m_TargetScheduler__schedulers);

    // LabelGroup
    {
        m_LabelGroupEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_LabelGroupEClass->setClassifierID(LABELGROUP);
        m_LabelGroupEClass->setEPackage(_this());
        getEClassifiers().push_back(m_LabelGroupEClass);
    }

    // RunnableGroup
    {
        m_RunnableGroupEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_RunnableGroupEClass->setClassifierID(RUNNABLEGROUP);
        m_RunnableGroupEClass->setEPackage(_this());
        getEClassifiers().push_back(m_RunnableGroupEClass);
    }

    // ProcessGroup
    {
        m_ProcessGroupEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_ProcessGroupEClass->setClassifierID(PROCESSGROUP);
        m_ProcessGroupEClass->setEPackage(_this());
        getEClassifiers().push_back(m_ProcessGroupEClass);
    }

    // LabelEntityGroup
    {
        m_LabelEntityGroupEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_LabelEntityGroupEClass->setClassifierID(LABELENTITYGROUP);
        m_LabelEntityGroupEClass->setEPackage(_this());
        getEClassifiers().push_back(m_LabelEntityGroupEClass);
    }
    // m_LabelEntityGroup__labels has already been allocated above
    m_LabelEntityGroup__labels->setFeatureID(
            ::amalthea::AmaltheaPackage::LABELENTITYGROUP__LABELS);
    m_LabelEntityGroupEClass->getEStructuralFeatures().push_back(
            m_LabelEntityGroup__labels);

    // RunnableEntityGroup
    {
        m_RunnableEntityGroupEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_RunnableEntityGroupEClass->setClassifierID(RUNNABLEENTITYGROUP);
        m_RunnableEntityGroupEClass->setEPackage(_this());
        getEClassifiers().push_back(m_RunnableEntityGroupEClass);
    }
    // m_RunnableEntityGroup__runnables has already been allocated above
    m_RunnableEntityGroup__runnables->setFeatureID(
            ::amalthea::AmaltheaPackage::RUNNABLEENTITYGROUP__RUNNABLES);
    m_RunnableEntityGroupEClass->getEStructuralFeatures().push_back(
            m_RunnableEntityGroup__runnables);

    // ProcessEntityGroup
    {
        m_ProcessEntityGroupEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_ProcessEntityGroupEClass->setClassifierID(PROCESSENTITYGROUP);
        m_ProcessEntityGroupEClass->setEPackage(_this());
        getEClassifiers().push_back(m_ProcessEntityGroupEClass);
    }
    // m_ProcessEntityGroup__processes has already been allocated above
    m_ProcessEntityGroup__processes->setFeatureID(
            ::amalthea::AmaltheaPackage::PROCESSENTITYGROUP__PROCESSES);
    m_ProcessEntityGroupEClass->getEStructuralFeatures().push_back(
            m_ProcessEntityGroup__processes);

    // TagGroup
    {
        m_TagGroupEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_TagGroupEClass->setClassifierID(TAGGROUP);
        m_TagGroupEClass->setEPackage(_this());
        getEClassifiers().push_back(m_TagGroupEClass);
    }
    // m_TagGroup__tag has already been allocated above
    m_TagGroup__tag->setFeatureID(::amalthea::AmaltheaPackage::TAGGROUP__TAG);
    m_TagGroupEClass->getEStructuralFeatures().push_back(m_TagGroup__tag);

    // AbstractEventChain
    {
        m_AbstractEventChainEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_AbstractEventChainEClass->setClassifierID(ABSTRACTEVENTCHAIN);
        m_AbstractEventChainEClass->setEPackage(_this());
        getEClassifiers().push_back(m_AbstractEventChainEClass);
    }
    // m_AbstractEventChain__itemType has already been allocated above
    m_AbstractEventChain__itemType->setFeatureID(
            ::amalthea::AmaltheaPackage::ABSTRACTEVENTCHAIN__ITEMTYPE);
    m_AbstractEventChainEClass->getEStructuralFeatures().push_back(
            m_AbstractEventChain__itemType);
    // m_AbstractEventChain__minItemsCompleted has already been allocated above
    m_AbstractEventChain__minItemsCompleted->setFeatureID(
            ::amalthea::AmaltheaPackage::ABSTRACTEVENTCHAIN__MINITEMSCOMPLETED);
    m_AbstractEventChainEClass->getEStructuralFeatures().push_back(
            m_AbstractEventChain__minItemsCompleted);
    // m_AbstractEventChain__stimulus has already been allocated above
    m_AbstractEventChain__stimulus->setFeatureID(
            ::amalthea::AmaltheaPackage::ABSTRACTEVENTCHAIN__STIMULUS);
    m_AbstractEventChainEClass->getEStructuralFeatures().push_back(
            m_AbstractEventChain__stimulus);
    // m_AbstractEventChain__response has already been allocated above
    m_AbstractEventChain__response->setFeatureID(
            ::amalthea::AmaltheaPackage::ABSTRACTEVENTCHAIN__RESPONSE);
    m_AbstractEventChainEClass->getEStructuralFeatures().push_back(
            m_AbstractEventChain__response);
    // m_AbstractEventChain__items has already been allocated above
    m_AbstractEventChain__items->setFeatureID(
            ::amalthea::AmaltheaPackage::ABSTRACTEVENTCHAIN__ITEMS);
    m_AbstractEventChainEClass->getEStructuralFeatures().push_back(
            m_AbstractEventChain__items);

    // EventChain
    {
        m_EventChainEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_EventChainEClass->setClassifierID(EVENTCHAIN);
        m_EventChainEClass->setEPackage(_this());
        getEClassifiers().push_back(m_EventChainEClass);
    }

    // SubEventChain
    {
        m_SubEventChainEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_SubEventChainEClass->setClassifierID(SUBEVENTCHAIN);
        m_SubEventChainEClass->setEPackage(_this());
        getEClassifiers().push_back(m_SubEventChainEClass);
    }

    // EventChainItem
    {
        m_EventChainItemEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_EventChainItemEClass->setClassifierID(EVENTCHAINITEM);
        m_EventChainItemEClass->setEPackage(_this());
        getEClassifiers().push_back(m_EventChainItemEClass);
    }

    // EventChainReference
    {
        m_EventChainReferenceEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_EventChainReferenceEClass->setClassifierID(EVENTCHAINREFERENCE);
        m_EventChainReferenceEClass->setEPackage(_this());
        getEClassifiers().push_back(m_EventChainReferenceEClass);
    }
    // m_EventChainReference__eventChain has already been allocated above
    m_EventChainReference__eventChain->setFeatureID(
            ::amalthea::AmaltheaPackage::EVENTCHAINREFERENCE__EVENTCHAIN);
    m_EventChainReferenceEClass->getEStructuralFeatures().push_back(
            m_EventChainReference__eventChain);

    // EventChainContainer
    {
        m_EventChainContainerEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_EventChainContainerEClass->setClassifierID(EVENTCHAINCONTAINER);
        m_EventChainContainerEClass->setEPackage(_this());
        getEClassifiers().push_back(m_EventChainContainerEClass);
    }
    // m_EventChainContainer__eventChain has already been allocated above
    m_EventChainContainer__eventChain->setFeatureID(
            ::amalthea::AmaltheaPackage::EVENTCHAINCONTAINER__EVENTCHAIN);
    m_EventChainContainerEClass->getEStructuralFeatures().push_back(
            m_EventChainContainer__eventChain);

    // TimingConstraint
    {
        m_TimingConstraintEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_TimingConstraintEClass->setClassifierID(TIMINGCONSTRAINT);
        m_TimingConstraintEClass->setEPackage(_this());
        getEClassifiers().push_back(m_TimingConstraintEClass);
    }

    // PhysicalSectionConstraint
    {
        m_PhysicalSectionConstraintEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_PhysicalSectionConstraintEClass->setClassifierID(
                PHYSICALSECTIONCONSTRAINT);
        m_PhysicalSectionConstraintEClass->setEPackage(_this());
        getEClassifiers().push_back(m_PhysicalSectionConstraintEClass);
    }
    // m_PhysicalSectionConstraint__section has already been allocated above
    m_PhysicalSectionConstraint__section->setFeatureID(
            ::amalthea::AmaltheaPackage::PHYSICALSECTIONCONSTRAINT__SECTION);
    m_PhysicalSectionConstraintEClass->getEStructuralFeatures().push_back(
            m_PhysicalSectionConstraint__section);
    // m_PhysicalSectionConstraint__memories has already been allocated above
    m_PhysicalSectionConstraint__memories->setFeatureID(
            ::amalthea::AmaltheaPackage::PHYSICALSECTIONCONSTRAINT__MEMORIES);
    m_PhysicalSectionConstraintEClass->getEStructuralFeatures().push_back(
            m_PhysicalSectionConstraint__memories);

    // SynchronizationConstraint
    {
        m_SynchronizationConstraintEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_SynchronizationConstraintEClass->setClassifierID(
                SYNCHRONIZATIONCONSTRAINT);
        m_SynchronizationConstraintEClass->setEPackage(_this());
        getEClassifiers().push_back(m_SynchronizationConstraintEClass);
    }
    // m_SynchronizationConstraint__multipleOccurrencesAllowed has already been allocated above
    m_SynchronizationConstraint__multipleOccurrencesAllowed->setFeatureID(
            ::amalthea::AmaltheaPackage::SYNCHRONIZATIONCONSTRAINT__MULTIPLEOCCURRENCESALLOWED);
    m_SynchronizationConstraintEClass->getEStructuralFeatures().push_back(
            m_SynchronizationConstraint__multipleOccurrencesAllowed);
    // m_SynchronizationConstraint__tolerance has already been allocated above
    m_SynchronizationConstraint__tolerance->setFeatureID(
            ::amalthea::AmaltheaPackage::SYNCHRONIZATIONCONSTRAINT__TOLERANCE);
    m_SynchronizationConstraintEClass->getEStructuralFeatures().push_back(
            m_SynchronizationConstraint__tolerance);

    // EventSynchronizationConstraint
    {
        m_EventSynchronizationConstraintEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_EventSynchronizationConstraintEClass->setClassifierID(
                EVENTSYNCHRONIZATIONCONSTRAINT);
        m_EventSynchronizationConstraintEClass->setEPackage(_this());
        getEClassifiers().push_back(m_EventSynchronizationConstraintEClass);
    }
    // m_EventSynchronizationConstraint__events has already been allocated above
    m_EventSynchronizationConstraint__events->setFeatureID(
            ::amalthea::AmaltheaPackage::EVENTSYNCHRONIZATIONCONSTRAINT__EVENTS);
    m_EventSynchronizationConstraintEClass->getEStructuralFeatures().push_back(
            m_EventSynchronizationConstraint__events);

    // EventChainSynchronizationConstraint
    {
        m_EventChainSynchronizationConstraintEClass = ::ecore::Ptr
                < ::ecore::EClass > (new ::ecore::EClass);
        m_EventChainSynchronizationConstraintEClass->setClassifierID(
                EVENTCHAINSYNCHRONIZATIONCONSTRAINT);
        m_EventChainSynchronizationConstraintEClass->setEPackage(_this());
        getEClassifiers().push_back(
                m_EventChainSynchronizationConstraintEClass);
    }
    // m_EventChainSynchronizationConstraint__type has already been allocated above
    m_EventChainSynchronizationConstraint__type->setFeatureID(
            ::amalthea::AmaltheaPackage::EVENTCHAINSYNCHRONIZATIONCONSTRAINT__TYPE);
    m_EventChainSynchronizationConstraintEClass->getEStructuralFeatures().push_back(
            m_EventChainSynchronizationConstraint__type);
    // m_EventChainSynchronizationConstraint__scope has already been allocated above
    m_EventChainSynchronizationConstraint__scope->setFeatureID(
            ::amalthea::AmaltheaPackage::EVENTCHAINSYNCHRONIZATIONCONSTRAINT__SCOPE);
    m_EventChainSynchronizationConstraintEClass->getEStructuralFeatures().push_back(
            m_EventChainSynchronizationConstraint__scope);

    // DelayConstraint
    {
        m_DelayConstraintEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_DelayConstraintEClass->setClassifierID(DELAYCONSTRAINT);
        m_DelayConstraintEClass->setEPackage(_this());
        getEClassifiers().push_back(m_DelayConstraintEClass);
    }
    // m_DelayConstraint__mappingType has already been allocated above
    m_DelayConstraint__mappingType->setFeatureID(
            ::amalthea::AmaltheaPackage::DELAYCONSTRAINT__MAPPINGTYPE);
    m_DelayConstraintEClass->getEStructuralFeatures().push_back(
            m_DelayConstraint__mappingType);
    // m_DelayConstraint__source has already been allocated above
    m_DelayConstraint__source->setFeatureID(
            ::amalthea::AmaltheaPackage::DELAYCONSTRAINT__SOURCE);
    m_DelayConstraintEClass->getEStructuralFeatures().push_back(
            m_DelayConstraint__source);
    // m_DelayConstraint__target has already been allocated above
    m_DelayConstraint__target->setFeatureID(
            ::amalthea::AmaltheaPackage::DELAYCONSTRAINT__TARGET);
    m_DelayConstraintEClass->getEStructuralFeatures().push_back(
            m_DelayConstraint__target);
    // m_DelayConstraint__upper has already been allocated above
    m_DelayConstraint__upper->setFeatureID(
            ::amalthea::AmaltheaPackage::DELAYCONSTRAINT__UPPER);
    m_DelayConstraintEClass->getEStructuralFeatures().push_back(
            m_DelayConstraint__upper);
    // m_DelayConstraint__lower has already been allocated above
    m_DelayConstraint__lower->setFeatureID(
            ::amalthea::AmaltheaPackage::DELAYCONSTRAINT__LOWER);
    m_DelayConstraintEClass->getEStructuralFeatures().push_back(
            m_DelayConstraint__lower);

    // EventChainLatencyConstraint
    {
        m_EventChainLatencyConstraintEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_EventChainLatencyConstraintEClass->setClassifierID(
                EVENTCHAINLATENCYCONSTRAINT);
        m_EventChainLatencyConstraintEClass->setEPackage(_this());
        getEClassifiers().push_back(m_EventChainLatencyConstraintEClass);
    }
    // m_EventChainLatencyConstraint__type has already been allocated above
    m_EventChainLatencyConstraint__type->setFeatureID(
            ::amalthea::AmaltheaPackage::EVENTCHAINLATENCYCONSTRAINT__TYPE);
    m_EventChainLatencyConstraintEClass->getEStructuralFeatures().push_back(
            m_EventChainLatencyConstraint__type);
    // m_EventChainLatencyConstraint__scope has already been allocated above
    m_EventChainLatencyConstraint__scope->setFeatureID(
            ::amalthea::AmaltheaPackage::EVENTCHAINLATENCYCONSTRAINT__SCOPE);
    m_EventChainLatencyConstraintEClass->getEStructuralFeatures().push_back(
            m_EventChainLatencyConstraint__scope);
    // m_EventChainLatencyConstraint__minimum has already been allocated above
    m_EventChainLatencyConstraint__minimum->setFeatureID(
            ::amalthea::AmaltheaPackage::EVENTCHAINLATENCYCONSTRAINT__MINIMUM);
    m_EventChainLatencyConstraintEClass->getEStructuralFeatures().push_back(
            m_EventChainLatencyConstraint__minimum);
    // m_EventChainLatencyConstraint__maximum has already been allocated above
    m_EventChainLatencyConstraint__maximum->setFeatureID(
            ::amalthea::AmaltheaPackage::EVENTCHAINLATENCYCONSTRAINT__MAXIMUM);
    m_EventChainLatencyConstraintEClass->getEStructuralFeatures().push_back(
            m_EventChainLatencyConstraint__maximum);

    // RepetitionConstraint
    {
        m_RepetitionConstraintEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_RepetitionConstraintEClass->setClassifierID(REPETITIONCONSTRAINT);
        m_RepetitionConstraintEClass->setEPackage(_this());
        getEClassifiers().push_back(m_RepetitionConstraintEClass);
    }
    // m_RepetitionConstraint__span has already been allocated above
    m_RepetitionConstraint__span->setFeatureID(
            ::amalthea::AmaltheaPackage::REPETITIONCONSTRAINT__SPAN);
    m_RepetitionConstraintEClass->getEStructuralFeatures().push_back(
            m_RepetitionConstraint__span);
    // m_RepetitionConstraint__event has already been allocated above
    m_RepetitionConstraint__event->setFeatureID(
            ::amalthea::AmaltheaPackage::REPETITIONCONSTRAINT__EVENT);
    m_RepetitionConstraintEClass->getEStructuralFeatures().push_back(
            m_RepetitionConstraint__event);
    // m_RepetitionConstraint__lower has already been allocated above
    m_RepetitionConstraint__lower->setFeatureID(
            ::amalthea::AmaltheaPackage::REPETITIONCONSTRAINT__LOWER);
    m_RepetitionConstraintEClass->getEStructuralFeatures().push_back(
            m_RepetitionConstraint__lower);
    // m_RepetitionConstraint__upper has already been allocated above
    m_RepetitionConstraint__upper->setFeatureID(
            ::amalthea::AmaltheaPackage::REPETITIONCONSTRAINT__UPPER);
    m_RepetitionConstraintEClass->getEStructuralFeatures().push_back(
            m_RepetitionConstraint__upper);
    // m_RepetitionConstraint__jitter has already been allocated above
    m_RepetitionConstraint__jitter->setFeatureID(
            ::amalthea::AmaltheaPackage::REPETITIONCONSTRAINT__JITTER);
    m_RepetitionConstraintEClass->getEStructuralFeatures().push_back(
            m_RepetitionConstraint__jitter);
    // m_RepetitionConstraint__period has already been allocated above
    m_RepetitionConstraint__period->setFeatureID(
            ::amalthea::AmaltheaPackage::REPETITIONCONSTRAINT__PERIOD);
    m_RepetitionConstraintEClass->getEStructuralFeatures().push_back(
            m_RepetitionConstraint__period);

    // DataAgeConstraint
    {
        m_DataAgeConstraintEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_DataAgeConstraintEClass->setClassifierID(DATAAGECONSTRAINT);
        m_DataAgeConstraintEClass->setEPackage(_this());
        getEClassifiers().push_back(m_DataAgeConstraintEClass);
    }
    // m_DataAgeConstraint__runnable has already been allocated above
    m_DataAgeConstraint__runnable->setFeatureID(
            ::amalthea::AmaltheaPackage::DATAAGECONSTRAINT__RUNNABLE);
    m_DataAgeConstraintEClass->getEStructuralFeatures().push_back(
            m_DataAgeConstraint__runnable);
    // m_DataAgeConstraint__label has already been allocated above
    m_DataAgeConstraint__label->setFeatureID(
            ::amalthea::AmaltheaPackage::DATAAGECONSTRAINT__LABEL);
    m_DataAgeConstraintEClass->getEStructuralFeatures().push_back(
            m_DataAgeConstraint__label);
    // m_DataAgeConstraint__dataAge has already been allocated above
    m_DataAgeConstraint__dataAge->setFeatureID(
            ::amalthea::AmaltheaPackage::DATAAGECONSTRAINT__DATAAGE);
    m_DataAgeConstraintEClass->getEStructuralFeatures().push_back(
            m_DataAgeConstraint__dataAge);

    // DataAge
    {
        m_DataAgeEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_DataAgeEClass->setClassifierID(DATAAGE);
        m_DataAgeEClass->setEPackage(_this());
        getEClassifiers().push_back(m_DataAgeEClass);
    }

    // DataAgeCycle
    {
        m_DataAgeCycleEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_DataAgeCycleEClass->setClassifierID(DATAAGECYCLE);
        m_DataAgeCycleEClass->setEPackage(_this());
        getEClassifiers().push_back(m_DataAgeCycleEClass);
    }
    // m_DataAgeCycle__minimumCycle has already been allocated above
    m_DataAgeCycle__minimumCycle->setFeatureID(
            ::amalthea::AmaltheaPackage::DATAAGECYCLE__MINIMUMCYCLE);
    m_DataAgeCycleEClass->getEStructuralFeatures().push_back(
            m_DataAgeCycle__minimumCycle);
    // m_DataAgeCycle__maximumCycle has already been allocated above
    m_DataAgeCycle__maximumCycle->setFeatureID(
            ::amalthea::AmaltheaPackage::DATAAGECYCLE__MAXIMUMCYCLE);
    m_DataAgeCycleEClass->getEStructuralFeatures().push_back(
            m_DataAgeCycle__maximumCycle);

    // DataAgeTime
    {
        m_DataAgeTimeEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_DataAgeTimeEClass->setClassifierID(DATAAGETIME);
        m_DataAgeTimeEClass->setEPackage(_this());
        getEClassifiers().push_back(m_DataAgeTimeEClass);
    }
    // m_DataAgeTime__minimumTime has already been allocated above
    m_DataAgeTime__minimumTime->setFeatureID(
            ::amalthea::AmaltheaPackage::DATAAGETIME__MINIMUMTIME);
    m_DataAgeTimeEClass->getEStructuralFeatures().push_back(
            m_DataAgeTime__minimumTime);
    // m_DataAgeTime__maximumTime has already been allocated above
    m_DataAgeTime__maximumTime->setFeatureID(
            ::amalthea::AmaltheaPackage::DATAAGETIME__MAXIMUMTIME);
    m_DataAgeTimeEClass->getEStructuralFeatures().push_back(
            m_DataAgeTime__maximumTime);

    // Requirement
    {
        m_RequirementEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_RequirementEClass->setClassifierID(REQUIREMENT);
        m_RequirementEClass->setEPackage(_this());
        getEClassifiers().push_back(m_RequirementEClass);
    }
    // m_Requirement__severity has already been allocated above
    m_Requirement__severity->setFeatureID(
            ::amalthea::AmaltheaPackage::REQUIREMENT__SEVERITY);
    m_RequirementEClass->getEStructuralFeatures().push_back(
            m_Requirement__severity);
    // m_Requirement__limit has already been allocated above
    m_Requirement__limit->setFeatureID(
            ::amalthea::AmaltheaPackage::REQUIREMENT__LIMIT);
    m_RequirementEClass->getEStructuralFeatures().push_back(
            m_Requirement__limit);

    // ProcessRequirement
    {
        m_ProcessRequirementEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_ProcessRequirementEClass->setClassifierID(PROCESSREQUIREMENT);
        m_ProcessRequirementEClass->setEPackage(_this());
        getEClassifiers().push_back(m_ProcessRequirementEClass);
    }
    // m_ProcessRequirement__process has already been allocated above
    m_ProcessRequirement__process->setFeatureID(
            ::amalthea::AmaltheaPackage::PROCESSREQUIREMENT__PROCESS);
    m_ProcessRequirementEClass->getEStructuralFeatures().push_back(
            m_ProcessRequirement__process);

    // RunnableRequirement
    {
        m_RunnableRequirementEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_RunnableRequirementEClass->setClassifierID(RUNNABLEREQUIREMENT);
        m_RunnableRequirementEClass->setEPackage(_this());
        getEClassifiers().push_back(m_RunnableRequirementEClass);
    }
    // m_RunnableRequirement__runnable has already been allocated above
    m_RunnableRequirement__runnable->setFeatureID(
            ::amalthea::AmaltheaPackage::RUNNABLEREQUIREMENT__RUNNABLE);
    m_RunnableRequirementEClass->getEStructuralFeatures().push_back(
            m_RunnableRequirement__runnable);

    // ArchitectureRequirement
    {
        m_ArchitectureRequirementEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_ArchitectureRequirementEClass->setClassifierID(
                ARCHITECTUREREQUIREMENT);
        m_ArchitectureRequirementEClass->setEPackage(_this());
        getEClassifiers().push_back(m_ArchitectureRequirementEClass);
    }
    // m_ArchitectureRequirement__component has already been allocated above
    m_ArchitectureRequirement__component->setFeatureID(
            ::amalthea::AmaltheaPackage::ARCHITECTUREREQUIREMENT__COMPONENT);
    m_ArchitectureRequirementEClass->getEStructuralFeatures().push_back(
            m_ArchitectureRequirement__component);

    // ProcessChainRequirement
    {
        m_ProcessChainRequirementEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_ProcessChainRequirementEClass->setClassifierID(
                PROCESSCHAINREQUIREMENT);
        m_ProcessChainRequirementEClass->setEPackage(_this());
        getEClassifiers().push_back(m_ProcessChainRequirementEClass);
    }
    // m_ProcessChainRequirement__processChain has already been allocated above
    m_ProcessChainRequirement__processChain->setFeatureID(
            ::amalthea::AmaltheaPackage::PROCESSCHAINREQUIREMENT__PROCESSCHAIN);
    m_ProcessChainRequirementEClass->getEStructuralFeatures().push_back(
            m_ProcessChainRequirement__processChain);

    // RequirementLimit
    {
        m_RequirementLimitEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_RequirementLimitEClass->setClassifierID(REQUIREMENTLIMIT);
        m_RequirementLimitEClass->setEPackage(_this());
        getEClassifiers().push_back(m_RequirementLimitEClass);
    }
    // m_RequirementLimit__limitType has already been allocated above
    m_RequirementLimit__limitType->setFeatureID(
            ::amalthea::AmaltheaPackage::REQUIREMENTLIMIT__LIMITTYPE);
    m_RequirementLimitEClass->getEStructuralFeatures().push_back(
            m_RequirementLimit__limitType);

    // CPUPercentageRequirementLimit
    {
        m_CPUPercentageRequirementLimitEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_CPUPercentageRequirementLimitEClass->setClassifierID(
                CPUPERCENTAGEREQUIREMENTLIMIT);
        m_CPUPercentageRequirementLimitEClass->setEPackage(_this());
        getEClassifiers().push_back(m_CPUPercentageRequirementLimitEClass);
    }
    // m_CPUPercentageRequirementLimit__metric has already been allocated above
    m_CPUPercentageRequirementLimit__metric->setFeatureID(
            ::amalthea::AmaltheaPackage::CPUPERCENTAGEREQUIREMENTLIMIT__METRIC);
    m_CPUPercentageRequirementLimitEClass->getEStructuralFeatures().push_back(
            m_CPUPercentageRequirementLimit__metric);
    // m_CPUPercentageRequirementLimit__limitValue has already been allocated above
    m_CPUPercentageRequirementLimit__limitValue->setFeatureID(
            ::amalthea::AmaltheaPackage::CPUPERCENTAGEREQUIREMENTLIMIT__LIMITVALUE);
    m_CPUPercentageRequirementLimitEClass->getEStructuralFeatures().push_back(
            m_CPUPercentageRequirementLimit__limitValue);
    // m_CPUPercentageRequirementLimit__hardwareContext has already been allocated above
    m_CPUPercentageRequirementLimit__hardwareContext->setFeatureID(
            ::amalthea::AmaltheaPackage::CPUPERCENTAGEREQUIREMENTLIMIT__HARDWARECONTEXT);
    m_CPUPercentageRequirementLimitEClass->getEStructuralFeatures().push_back(
            m_CPUPercentageRequirementLimit__hardwareContext);

    // FrequencyRequirementLimit
    {
        m_FrequencyRequirementLimitEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_FrequencyRequirementLimitEClass->setClassifierID(
                FREQUENCYREQUIREMENTLIMIT);
        m_FrequencyRequirementLimitEClass->setEPackage(_this());
        getEClassifiers().push_back(m_FrequencyRequirementLimitEClass);
    }
    // m_FrequencyRequirementLimit__metric has already been allocated above
    m_FrequencyRequirementLimit__metric->setFeatureID(
            ::amalthea::AmaltheaPackage::FREQUENCYREQUIREMENTLIMIT__METRIC);
    m_FrequencyRequirementLimitEClass->getEStructuralFeatures().push_back(
            m_FrequencyRequirementLimit__metric);
    // m_FrequencyRequirementLimit__limitValue has already been allocated above
    m_FrequencyRequirementLimit__limitValue->setFeatureID(
            ::amalthea::AmaltheaPackage::FREQUENCYREQUIREMENTLIMIT__LIMITVALUE);
    m_FrequencyRequirementLimitEClass->getEStructuralFeatures().push_back(
            m_FrequencyRequirementLimit__limitValue);

    // PercentageRequirementLimit
    {
        m_PercentageRequirementLimitEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_PercentageRequirementLimitEClass->setClassifierID(
                PERCENTAGEREQUIREMENTLIMIT);
        m_PercentageRequirementLimitEClass->setEPackage(_this());
        getEClassifiers().push_back(m_PercentageRequirementLimitEClass);
    }
    // m_PercentageRequirementLimit__metric has already been allocated above
    m_PercentageRequirementLimit__metric->setFeatureID(
            ::amalthea::AmaltheaPackage::PERCENTAGEREQUIREMENTLIMIT__METRIC);
    m_PercentageRequirementLimitEClass->getEStructuralFeatures().push_back(
            m_PercentageRequirementLimit__metric);
    // m_PercentageRequirementLimit__limitValue has already been allocated above
    m_PercentageRequirementLimit__limitValue->setFeatureID(
            ::amalthea::AmaltheaPackage::PERCENTAGEREQUIREMENTLIMIT__LIMITVALUE);
    m_PercentageRequirementLimitEClass->getEStructuralFeatures().push_back(
            m_PercentageRequirementLimit__limitValue);

    // CountRequirementLimit
    {
        m_CountRequirementLimitEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_CountRequirementLimitEClass->setClassifierID(COUNTREQUIREMENTLIMIT);
        m_CountRequirementLimitEClass->setEPackage(_this());
        getEClassifiers().push_back(m_CountRequirementLimitEClass);
    }
    // m_CountRequirementLimit__metric has already been allocated above
    m_CountRequirementLimit__metric->setFeatureID(
            ::amalthea::AmaltheaPackage::COUNTREQUIREMENTLIMIT__METRIC);
    m_CountRequirementLimitEClass->getEStructuralFeatures().push_back(
            m_CountRequirementLimit__metric);
    // m_CountRequirementLimit__limitValue has already been allocated above
    m_CountRequirementLimit__limitValue->setFeatureID(
            ::amalthea::AmaltheaPackage::COUNTREQUIREMENTLIMIT__LIMITVALUE);
    m_CountRequirementLimitEClass->getEStructuralFeatures().push_back(
            m_CountRequirementLimit__limitValue);

    // TimeRequirementLimit
    {
        m_TimeRequirementLimitEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_TimeRequirementLimitEClass->setClassifierID(TIMEREQUIREMENTLIMIT);
        m_TimeRequirementLimitEClass->setEPackage(_this());
        getEClassifiers().push_back(m_TimeRequirementLimitEClass);
    }
    // m_TimeRequirementLimit__metric has already been allocated above
    m_TimeRequirementLimit__metric->setFeatureID(
            ::amalthea::AmaltheaPackage::TIMEREQUIREMENTLIMIT__METRIC);
    m_TimeRequirementLimitEClass->getEStructuralFeatures().push_back(
            m_TimeRequirementLimit__metric);
    // m_TimeRequirementLimit__limitValue has already been allocated above
    m_TimeRequirementLimit__limitValue->setFeatureID(
            ::amalthea::AmaltheaPackage::TIMEREQUIREMENTLIMIT__LIMITVALUE);
    m_TimeRequirementLimitEClass->getEStructuralFeatures().push_back(
            m_TimeRequirementLimit__limitValue);

    // DataCoherencyGroup
    {
        m_DataCoherencyGroupEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_DataCoherencyGroupEClass->setClassifierID(DATACOHERENCYGROUP);
        m_DataCoherencyGroupEClass->setEPackage(_this());
        getEClassifiers().push_back(m_DataCoherencyGroupEClass);
    }
    // m_DataCoherencyGroup__direction has already been allocated above
    m_DataCoherencyGroup__direction->setFeatureID(
            ::amalthea::AmaltheaPackage::DATACOHERENCYGROUP__DIRECTION);
    m_DataCoherencyGroupEClass->getEStructuralFeatures().push_back(
            m_DataCoherencyGroup__direction);
    // m_DataCoherencyGroup__labels has already been allocated above
    m_DataCoherencyGroup__labels->setFeatureID(
            ::amalthea::AmaltheaPackage::DATACOHERENCYGROUP__LABELS);
    m_DataCoherencyGroupEClass->getEStructuralFeatures().push_back(
            m_DataCoherencyGroup__labels);
    // m_DataCoherencyGroup__scope has already been allocated above
    m_DataCoherencyGroup__scope->setFeatureID(
            ::amalthea::AmaltheaPackage::DATACOHERENCYGROUP__SCOPE);
    m_DataCoherencyGroupEClass->getEStructuralFeatures().push_back(
            m_DataCoherencyGroup__scope);

    // DataStabilityGroup
    {
        m_DataStabilityGroupEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_DataStabilityGroupEClass->setClassifierID(DATASTABILITYGROUP);
        m_DataStabilityGroupEClass->setEPackage(_this());
        getEClassifiers().push_back(m_DataStabilityGroupEClass);
    }
    // m_DataStabilityGroup__labels has already been allocated above
    m_DataStabilityGroup__labels->setFeatureID(
            ::amalthea::AmaltheaPackage::DATASTABILITYGROUP__LABELS);
    m_DataStabilityGroupEClass->getEStructuralFeatures().push_back(
            m_DataStabilityGroup__labels);
    // m_DataStabilityGroup__scope has already been allocated above
    m_DataStabilityGroup__scope->setFeatureID(
            ::amalthea::AmaltheaPackage::DATASTABILITYGROUP__SCOPE);
    m_DataStabilityGroupEClass->getEStructuralFeatures().push_back(
            m_DataStabilityGroup__scope);

    // DataGroupScope
    {
        m_DataGroupScopeEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_DataGroupScopeEClass->setClassifierID(DATAGROUPSCOPE);
        m_DataGroupScopeEClass->setEPackage(_this());
        getEClassifiers().push_back(m_DataGroupScopeEClass);
    }

    // ProcessScope
    {
        m_ProcessScopeEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_ProcessScopeEClass->setClassifierID(PROCESSSCOPE);
        m_ProcessScopeEClass->setEPackage(_this());
        getEClassifiers().push_back(m_ProcessScopeEClass);
    }
    // m_ProcessScope__process has already been allocated above
    m_ProcessScope__process->setFeatureID(
            ::amalthea::AmaltheaPackage::PROCESSSCOPE__PROCESS);
    m_ProcessScopeEClass->getEStructuralFeatures().push_back(
            m_ProcessScope__process);

    // RunnableScope
    {
        m_RunnableScopeEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_RunnableScopeEClass->setClassifierID(RUNNABLESCOPE);
        m_RunnableScopeEClass->setEPackage(_this());
        getEClassifiers().push_back(m_RunnableScopeEClass);
    }
    // m_RunnableScope__runnable has already been allocated above
    m_RunnableScope__runnable->setFeatureID(
            ::amalthea::AmaltheaPackage::RUNNABLESCOPE__RUNNABLE);
    m_RunnableScopeEClass->getEStructuralFeatures().push_back(
            m_RunnableScope__runnable);

    // ComponentScope
    {
        m_ComponentScopeEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_ComponentScopeEClass->setClassifierID(COMPONENTSCOPE);
        m_ComponentScopeEClass->setEPackage(_this());
        getEClassifiers().push_back(m_ComponentScopeEClass);
    }
    // m_ComponentScope__component has already been allocated above
    m_ComponentScope__component->setFeatureID(
            ::amalthea::AmaltheaPackage::COMPONENTSCOPE__COMPONENT);
    m_ComponentScopeEClass->getEStructuralFeatures().push_back(
            m_ComponentScope__component);

    // EventModel
    {
        m_EventModelEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_EventModelEClass->setClassifierID(EVENTMODEL);
        m_EventModelEClass->setEPackage(_this());
        getEClassifiers().push_back(m_EventModelEClass);
    }
    // m_EventModel__events has already been allocated above
    m_EventModel__events->setFeatureID(
            ::amalthea::AmaltheaPackage::EVENTMODEL__EVENTS);
    m_EventModelEClass->getEStructuralFeatures().push_back(
            m_EventModel__events);

    // Event
    {
        m_EventEClass = ::ecore::Ptr < ::ecore::EClass > (new ::ecore::EClass);
        m_EventEClass->setClassifierID(EVENT);
        m_EventEClass->setEPackage(_this());
        getEClassifiers().push_back(m_EventEClass);
    }

    // EventSet
    {
        m_EventSetEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_EventSetEClass->setClassifierID(EVENTSET);
        m_EventSetEClass->setEPackage(_this());
        getEClassifiers().push_back(m_EventSetEClass);
    }
    // m_EventSet__events has already been allocated above
    m_EventSet__events->setFeatureID(
            ::amalthea::AmaltheaPackage::EVENTSET__EVENTS);
    m_EventSetEClass->getEStructuralFeatures().push_back(m_EventSet__events);

    // EntityEvent
    {
        m_EntityEventEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_EntityEventEClass->setClassifierID(ENTITYEVENT);
        m_EntityEventEClass->setEPackage(_this());
        getEClassifiers().push_back(m_EntityEventEClass);
    }

    // TriggerEvent
    {
        m_TriggerEventEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_TriggerEventEClass->setClassifierID(TRIGGEREVENT);
        m_TriggerEventEClass->setEPackage(_this());
        getEClassifiers().push_back(m_TriggerEventEClass);
    }

    // CustomEvent
    {
        m_CustomEventEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_CustomEventEClass->setClassifierID(CUSTOMEVENT);
        m_CustomEventEClass->setEPackage(_this());
        getEClassifiers().push_back(m_CustomEventEClass);
    }
    // m_CustomEvent__eventType has already been allocated above
    m_CustomEvent__eventType->setFeatureID(
            ::amalthea::AmaltheaPackage::CUSTOMEVENT__EVENTTYPE);
    m_CustomEventEClass->getEStructuralFeatures().push_back(
            m_CustomEvent__eventType);
    // m_CustomEvent__explicitTriggers has already been allocated above
    m_CustomEvent__explicitTriggers->setFeatureID(
            ::amalthea::AmaltheaPackage::CUSTOMEVENT__EXPLICITTRIGGERS);
    m_CustomEventEClass->getEStructuralFeatures().push_back(
            m_CustomEvent__explicitTriggers);

    // StimulusEvent
    {
        m_StimulusEventEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_StimulusEventEClass->setClassifierID(STIMULUSEVENT);
        m_StimulusEventEClass->setEPackage(_this());
        getEClassifiers().push_back(m_StimulusEventEClass);
    }
    // m_StimulusEvent__entity has already been allocated above
    m_StimulusEvent__entity->setFeatureID(
            ::amalthea::AmaltheaPackage::STIMULUSEVENT__ENTITY);
    m_StimulusEventEClass->getEStructuralFeatures().push_back(
            m_StimulusEvent__entity);

    // ProcessEvent
    {
        m_ProcessEventEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_ProcessEventEClass->setClassifierID(PROCESSEVENT);
        m_ProcessEventEClass->setEPackage(_this());
        getEClassifiers().push_back(m_ProcessEventEClass);
    }
    // m_ProcessEvent__eventType has already been allocated above
    m_ProcessEvent__eventType->setFeatureID(
            ::amalthea::AmaltheaPackage::PROCESSEVENT__EVENTTYPE);
    m_ProcessEventEClass->getEStructuralFeatures().push_back(
            m_ProcessEvent__eventType);
    // m_ProcessEvent__entity has already been allocated above
    m_ProcessEvent__entity->setFeatureID(
            ::amalthea::AmaltheaPackage::PROCESSEVENT__ENTITY);
    m_ProcessEventEClass->getEStructuralFeatures().push_back(
            m_ProcessEvent__entity);
    // m_ProcessEvent__processingUnit has already been allocated above
    m_ProcessEvent__processingUnit->setFeatureID(
            ::amalthea::AmaltheaPackage::PROCESSEVENT__PROCESSINGUNIT);
    m_ProcessEventEClass->getEStructuralFeatures().push_back(
            m_ProcessEvent__processingUnit);

    // ProcessChainEvent
    {
        m_ProcessChainEventEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_ProcessChainEventEClass->setClassifierID(PROCESSCHAINEVENT);
        m_ProcessChainEventEClass->setEPackage(_this());
        getEClassifiers().push_back(m_ProcessChainEventEClass);
    }
    // m_ProcessChainEvent__eventType has already been allocated above
    m_ProcessChainEvent__eventType->setFeatureID(
            ::amalthea::AmaltheaPackage::PROCESSCHAINEVENT__EVENTTYPE);
    m_ProcessChainEventEClass->getEStructuralFeatures().push_back(
            m_ProcessChainEvent__eventType);
    // m_ProcessChainEvent__entity has already been allocated above
    m_ProcessChainEvent__entity->setFeatureID(
            ::amalthea::AmaltheaPackage::PROCESSCHAINEVENT__ENTITY);
    m_ProcessChainEventEClass->getEStructuralFeatures().push_back(
            m_ProcessChainEvent__entity);
    // m_ProcessChainEvent__processingUnit has already been allocated above
    m_ProcessChainEvent__processingUnit->setFeatureID(
            ::amalthea::AmaltheaPackage::PROCESSCHAINEVENT__PROCESSINGUNIT);
    m_ProcessChainEventEClass->getEStructuralFeatures().push_back(
            m_ProcessChainEvent__processingUnit);

    // RunnableEvent
    {
        m_RunnableEventEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_RunnableEventEClass->setClassifierID(RUNNABLEEVENT);
        m_RunnableEventEClass->setEPackage(_this());
        getEClassifiers().push_back(m_RunnableEventEClass);
    }
    // m_RunnableEvent__eventType has already been allocated above
    m_RunnableEvent__eventType->setFeatureID(
            ::amalthea::AmaltheaPackage::RUNNABLEEVENT__EVENTTYPE);
    m_RunnableEventEClass->getEStructuralFeatures().push_back(
            m_RunnableEvent__eventType);
    // m_RunnableEvent__entity has already been allocated above
    m_RunnableEvent__entity->setFeatureID(
            ::amalthea::AmaltheaPackage::RUNNABLEEVENT__ENTITY);
    m_RunnableEventEClass->getEStructuralFeatures().push_back(
            m_RunnableEvent__entity);
    // m_RunnableEvent__process has already been allocated above
    m_RunnableEvent__process->setFeatureID(
            ::amalthea::AmaltheaPackage::RUNNABLEEVENT__PROCESS);
    m_RunnableEventEClass->getEStructuralFeatures().push_back(
            m_RunnableEvent__process);
    // m_RunnableEvent__processingUnit has already been allocated above
    m_RunnableEvent__processingUnit->setFeatureID(
            ::amalthea::AmaltheaPackage::RUNNABLEEVENT__PROCESSINGUNIT);
    m_RunnableEventEClass->getEStructuralFeatures().push_back(
            m_RunnableEvent__processingUnit);

    // LabelEvent
    {
        m_LabelEventEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_LabelEventEClass->setClassifierID(LABELEVENT);
        m_LabelEventEClass->setEPackage(_this());
        getEClassifiers().push_back(m_LabelEventEClass);
    }
    // m_LabelEvent__eventType has already been allocated above
    m_LabelEvent__eventType->setFeatureID(
            ::amalthea::AmaltheaPackage::LABELEVENT__EVENTTYPE);
    m_LabelEventEClass->getEStructuralFeatures().push_back(
            m_LabelEvent__eventType);
    // m_LabelEvent__entity has already been allocated above
    m_LabelEvent__entity->setFeatureID(
            ::amalthea::AmaltheaPackage::LABELEVENT__ENTITY);
    m_LabelEventEClass->getEStructuralFeatures().push_back(
            m_LabelEvent__entity);
    // m_LabelEvent__runnable has already been allocated above
    m_LabelEvent__runnable->setFeatureID(
            ::amalthea::AmaltheaPackage::LABELEVENT__RUNNABLE);
    m_LabelEventEClass->getEStructuralFeatures().push_back(
            m_LabelEvent__runnable);
    // m_LabelEvent__process has already been allocated above
    m_LabelEvent__process->setFeatureID(
            ::amalthea::AmaltheaPackage::LABELEVENT__PROCESS);
    m_LabelEventEClass->getEStructuralFeatures().push_back(
            m_LabelEvent__process);

    // ChannelEvent
    {
        m_ChannelEventEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_ChannelEventEClass->setClassifierID(CHANNELEVENT);
        m_ChannelEventEClass->setEPackage(_this());
        getEClassifiers().push_back(m_ChannelEventEClass);
    }
    // m_ChannelEvent__eventType has already been allocated above
    m_ChannelEvent__eventType->setFeatureID(
            ::amalthea::AmaltheaPackage::CHANNELEVENT__EVENTTYPE);
    m_ChannelEventEClass->getEStructuralFeatures().push_back(
            m_ChannelEvent__eventType);
    // m_ChannelEvent__entity has already been allocated above
    m_ChannelEvent__entity->setFeatureID(
            ::amalthea::AmaltheaPackage::CHANNELEVENT__ENTITY);
    m_ChannelEventEClass->getEStructuralFeatures().push_back(
            m_ChannelEvent__entity);
    // m_ChannelEvent__runnable has already been allocated above
    m_ChannelEvent__runnable->setFeatureID(
            ::amalthea::AmaltheaPackage::CHANNELEVENT__RUNNABLE);
    m_ChannelEventEClass->getEStructuralFeatures().push_back(
            m_ChannelEvent__runnable);
    // m_ChannelEvent__process has already been allocated above
    m_ChannelEvent__process->setFeatureID(
            ::amalthea::AmaltheaPackage::CHANNELEVENT__PROCESS);
    m_ChannelEventEClass->getEStructuralFeatures().push_back(
            m_ChannelEvent__process);

    // SemaphoreEvent
    {
        m_SemaphoreEventEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_SemaphoreEventEClass->setClassifierID(SEMAPHOREEVENT);
        m_SemaphoreEventEClass->setEPackage(_this());
        getEClassifiers().push_back(m_SemaphoreEventEClass);
    }
    // m_SemaphoreEvent__eventType has already been allocated above
    m_SemaphoreEvent__eventType->setFeatureID(
            ::amalthea::AmaltheaPackage::SEMAPHOREEVENT__EVENTTYPE);
    m_SemaphoreEventEClass->getEStructuralFeatures().push_back(
            m_SemaphoreEvent__eventType);
    // m_SemaphoreEvent__entity has already been allocated above
    m_SemaphoreEvent__entity->setFeatureID(
            ::amalthea::AmaltheaPackage::SEMAPHOREEVENT__ENTITY);
    m_SemaphoreEventEClass->getEStructuralFeatures().push_back(
            m_SemaphoreEvent__entity);
    // m_SemaphoreEvent__runnable has already been allocated above
    m_SemaphoreEvent__runnable->setFeatureID(
            ::amalthea::AmaltheaPackage::SEMAPHOREEVENT__RUNNABLE);
    m_SemaphoreEventEClass->getEStructuralFeatures().push_back(
            m_SemaphoreEvent__runnable);
    // m_SemaphoreEvent__process has already been allocated above
    m_SemaphoreEvent__process->setFeatureID(
            ::amalthea::AmaltheaPackage::SEMAPHOREEVENT__PROCESS);
    m_SemaphoreEventEClass->getEStructuralFeatures().push_back(
            m_SemaphoreEvent__process);
    // m_SemaphoreEvent__processingUnit has already been allocated above
    m_SemaphoreEvent__processingUnit->setFeatureID(
            ::amalthea::AmaltheaPackage::SEMAPHOREEVENT__PROCESSINGUNIT);
    m_SemaphoreEventEClass->getEStructuralFeatures().push_back(
            m_SemaphoreEvent__processingUnit);

    // ComponentEvent
    {
        m_ComponentEventEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_ComponentEventEClass->setClassifierID(COMPONENTEVENT);
        m_ComponentEventEClass->setEPackage(_this());
        getEClassifiers().push_back(m_ComponentEventEClass);
    }
    // m_ComponentEvent__eventType has already been allocated above
    m_ComponentEvent__eventType->setFeatureID(
            ::amalthea::AmaltheaPackage::COMPONENTEVENT__EVENTTYPE);
    m_ComponentEventEClass->getEStructuralFeatures().push_back(
            m_ComponentEvent__eventType);
    // m_ComponentEvent__entity has already been allocated above
    m_ComponentEvent__entity->setFeatureID(
            ::amalthea::AmaltheaPackage::COMPONENTEVENT__ENTITY);
    m_ComponentEventEClass->getEStructuralFeatures().push_back(
            m_ComponentEvent__entity);

    // HWModel
    {
        m_HWModelEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_HWModelEClass->setClassifierID(HWMODEL);
        m_HWModelEClass->setEPackage(_this());
        getEClassifiers().push_back(m_HWModelEClass);
    }
    // m_HWModel__definitions has already been allocated above
    m_HWModel__definitions->setFeatureID(
            ::amalthea::AmaltheaPackage::HWMODEL__DEFINITIONS);
    m_HWModelEClass->getEStructuralFeatures().push_back(m_HWModel__definitions);
    // m_HWModel__featureCategories has already been allocated above
    m_HWModel__featureCategories->setFeatureID(
            ::amalthea::AmaltheaPackage::HWMODEL__FEATURECATEGORIES);
    m_HWModelEClass->getEStructuralFeatures().push_back(
            m_HWModel__featureCategories);
    // m_HWModel__structures has already been allocated above
    m_HWModel__structures->setFeatureID(
            ::amalthea::AmaltheaPackage::HWMODEL__STRUCTURES);
    m_HWModelEClass->getEStructuralFeatures().push_back(m_HWModel__structures);
    // m_HWModel__domains has already been allocated above
    m_HWModel__domains->setFeatureID(
            ::amalthea::AmaltheaPackage::HWMODEL__DOMAINS);
    m_HWModelEClass->getEStructuralFeatures().push_back(m_HWModel__domains);

    // HwStructure
    {
        m_HwStructureEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_HwStructureEClass->setClassifierID(HWSTRUCTURE);
        m_HwStructureEClass->setEPackage(_this());
        getEClassifiers().push_back(m_HwStructureEClass);
    }
    // m_HwStructure__structureType has already been allocated above
    m_HwStructure__structureType->setFeatureID(
            ::amalthea::AmaltheaPackage::HWSTRUCTURE__STRUCTURETYPE);
    m_HwStructureEClass->getEStructuralFeatures().push_back(
            m_HwStructure__structureType);
    // m_HwStructure__ports has already been allocated above
    m_HwStructure__ports->setFeatureID(
            ::amalthea::AmaltheaPackage::HWSTRUCTURE__PORTS);
    m_HwStructureEClass->getEStructuralFeatures().push_back(
            m_HwStructure__ports);
    // m_HwStructure__structures has already been allocated above
    m_HwStructure__structures->setFeatureID(
            ::amalthea::AmaltheaPackage::HWSTRUCTURE__STRUCTURES);
    m_HwStructureEClass->getEStructuralFeatures().push_back(
            m_HwStructure__structures);
    // m_HwStructure__modules has already been allocated above
    m_HwStructure__modules->setFeatureID(
            ::amalthea::AmaltheaPackage::HWSTRUCTURE__MODULES);
    m_HwStructureEClass->getEStructuralFeatures().push_back(
            m_HwStructure__modules);
    // m_HwStructure__connections has already been allocated above
    m_HwStructure__connections->setFeatureID(
            ::amalthea::AmaltheaPackage::HWSTRUCTURE__CONNECTIONS);
    m_HwStructureEClass->getEStructuralFeatures().push_back(
            m_HwStructure__connections);
    // m_HwStructure__innerPorts has already been allocated above
    m_HwStructure__innerPorts->setFeatureID(
            ::amalthea::AmaltheaPackage::HWSTRUCTURE__INNERPORTS);
    m_HwStructureEClass->getEStructuralFeatures().push_back(
            m_HwStructure__innerPorts);

    // HwModule
    {
        m_HwModuleEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_HwModuleEClass->setClassifierID(HWMODULE);
        m_HwModuleEClass->setEPackage(_this());
        getEClassifiers().push_back(m_HwModuleEClass);
    }
    // m_HwModule__ports has already been allocated above
    m_HwModule__ports->setFeatureID(
            ::amalthea::AmaltheaPackage::HWMODULE__PORTS);
    m_HwModuleEClass->getEStructuralFeatures().push_back(m_HwModule__ports);
    // m_HwModule__powerDomain has already been allocated above
    m_HwModule__powerDomain->setFeatureID(
            ::amalthea::AmaltheaPackage::HWMODULE__POWERDOMAIN);
    m_HwModuleEClass->getEStructuralFeatures().push_back(
            m_HwModule__powerDomain);
    // m_HwModule__frequencyDomain has already been allocated above
    m_HwModule__frequencyDomain->setFeatureID(
            ::amalthea::AmaltheaPackage::HWMODULE__FREQUENCYDOMAIN);
    m_HwModuleEClass->getEStructuralFeatures().push_back(
            m_HwModule__frequencyDomain);

    // HwDomain
    {
        m_HwDomainEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_HwDomainEClass->setClassifierID(HWDOMAIN);
        m_HwDomainEClass->setEPackage(_this());
        getEClassifiers().push_back(m_HwDomainEClass);
    }

    // FrequencyDomain
    {
        m_FrequencyDomainEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_FrequencyDomainEClass->setClassifierID(FREQUENCYDOMAIN);
        m_FrequencyDomainEClass->setEPackage(_this());
        getEClassifiers().push_back(m_FrequencyDomainEClass);
    }
    // m_FrequencyDomain__clockGating has already been allocated above
    m_FrequencyDomain__clockGating->setFeatureID(
            ::amalthea::AmaltheaPackage::FREQUENCYDOMAIN__CLOCKGATING);
    m_FrequencyDomainEClass->getEStructuralFeatures().push_back(
            m_FrequencyDomain__clockGating);
    // m_FrequencyDomain__defaultValue has already been allocated above
    m_FrequencyDomain__defaultValue->setFeatureID(
            ::amalthea::AmaltheaPackage::FREQUENCYDOMAIN__DEFAULTVALUE);
    m_FrequencyDomainEClass->getEStructuralFeatures().push_back(
            m_FrequencyDomain__defaultValue);

    // PowerDomain
    {
        m_PowerDomainEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_PowerDomainEClass->setClassifierID(POWERDOMAIN);
        m_PowerDomainEClass->setEPackage(_this());
        getEClassifiers().push_back(m_PowerDomainEClass);
    }
    // m_PowerDomain__powerGating has already been allocated above
    m_PowerDomain__powerGating->setFeatureID(
            ::amalthea::AmaltheaPackage::POWERDOMAIN__POWERGATING);
    m_PowerDomainEClass->getEStructuralFeatures().push_back(
            m_PowerDomain__powerGating);
    // m_PowerDomain__defaultValue has already been allocated above
    m_PowerDomain__defaultValue->setFeatureID(
            ::amalthea::AmaltheaPackage::POWERDOMAIN__DEFAULTVALUE);
    m_PowerDomainEClass->getEStructuralFeatures().push_back(
            m_PowerDomain__defaultValue);

    // ProcessingUnit
    {
        m_ProcessingUnitEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_ProcessingUnitEClass->setClassifierID(PROCESSINGUNIT);
        m_ProcessingUnitEClass->setEPackage(_this());
        getEClassifiers().push_back(m_ProcessingUnitEClass);
    }
    // m_ProcessingUnit__definition has already been allocated above
    m_ProcessingUnit__definition->setFeatureID(
            ::amalthea::AmaltheaPackage::PROCESSINGUNIT__DEFINITION);
    m_ProcessingUnitEClass->getEStructuralFeatures().push_back(
            m_ProcessingUnit__definition);
    // m_ProcessingUnit__accessElements has already been allocated above
    m_ProcessingUnit__accessElements->setFeatureID(
            ::amalthea::AmaltheaPackage::PROCESSINGUNIT__ACCESSELEMENTS);
    m_ProcessingUnitEClass->getEStructuralFeatures().push_back(
            m_ProcessingUnit__accessElements);
    // m_ProcessingUnit__caches has already been allocated above
    m_ProcessingUnit__caches->setFeatureID(
            ::amalthea::AmaltheaPackage::PROCESSINGUNIT__CACHES);
    m_ProcessingUnitEClass->getEStructuralFeatures().push_back(
            m_ProcessingUnit__caches);

    // Memory
    {
        m_MemoryEClass = ::ecore::Ptr < ::ecore::EClass > (new ::ecore::EClass);
        m_MemoryEClass->setClassifierID(MEMORY);
        m_MemoryEClass->setEPackage(_this());
        getEClassifiers().push_back(m_MemoryEClass);
    }
    // m_Memory__definition has already been allocated above
    m_Memory__definition->setFeatureID(
            ::amalthea::AmaltheaPackage::MEMORY__DEFINITION);
    m_MemoryEClass->getEStructuralFeatures().push_back(m_Memory__definition);
    // m_Memory__mappings has already been allocated above
    m_Memory__mappings->setFeatureID(
            ::amalthea::AmaltheaPackage::MEMORY__MAPPINGS);
    m_MemoryEClass->getEStructuralFeatures().push_back(m_Memory__mappings);

    // Cache
    {
        m_CacheEClass = ::ecore::Ptr < ::ecore::EClass > (new ::ecore::EClass);
        m_CacheEClass->setClassifierID(CACHE);
        m_CacheEClass->setEPackage(_this());
        getEClassifiers().push_back(m_CacheEClass);
    }
    // m_Cache__definition has already been allocated above
    m_Cache__definition->setFeatureID(
            ::amalthea::AmaltheaPackage::CACHE__DEFINITION);
    m_CacheEClass->getEStructuralFeatures().push_back(m_Cache__definition);

    // HwFeatureCategory
    {
        m_HwFeatureCategoryEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_HwFeatureCategoryEClass->setClassifierID(HWFEATURECATEGORY);
        m_HwFeatureCategoryEClass->setEPackage(_this());
        getEClassifiers().push_back(m_HwFeatureCategoryEClass);
    }
    // m_HwFeatureCategory__featureType has already been allocated above
    m_HwFeatureCategory__featureType->setFeatureID(
            ::amalthea::AmaltheaPackage::HWFEATURECATEGORY__FEATURETYPE);
    m_HwFeatureCategoryEClass->getEStructuralFeatures().push_back(
            m_HwFeatureCategory__featureType);
    // m_HwFeatureCategory__features has already been allocated above
    m_HwFeatureCategory__features->setFeatureID(
            ::amalthea::AmaltheaPackage::HWFEATURECATEGORY__FEATURES);
    m_HwFeatureCategoryEClass->getEStructuralFeatures().push_back(
            m_HwFeatureCategory__features);

    // HwFeature
    {
        m_HwFeatureEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_HwFeatureEClass->setClassifierID(HWFEATURE);
        m_HwFeatureEClass->setEPackage(_this());
        getEClassifiers().push_back(m_HwFeatureEClass);
    }
    // m_HwFeature__value has already been allocated above
    m_HwFeature__value->setFeatureID(
            ::amalthea::AmaltheaPackage::HWFEATURE__VALUE);
    m_HwFeatureEClass->getEStructuralFeatures().push_back(m_HwFeature__value);
    // m_HwFeature__containingCategory has already been allocated above
    m_HwFeature__containingCategory->setFeatureID(
            ::amalthea::AmaltheaPackage::HWFEATURE__CONTAININGCATEGORY);
    m_HwFeatureEClass->getEStructuralFeatures().push_back(
            m_HwFeature__containingCategory);

    // HwPort
    {
        m_HwPortEClass = ::ecore::Ptr < ::ecore::EClass > (new ::ecore::EClass);
        m_HwPortEClass->setClassifierID(HWPORT);
        m_HwPortEClass->setEPackage(_this());
        getEClassifiers().push_back(m_HwPortEClass);
    }
    // m_HwPort__bitWidth has already been allocated above
    m_HwPort__bitWidth->setFeatureID(
            ::amalthea::AmaltheaPackage::HWPORT__BITWIDTH);
    m_HwPortEClass->getEStructuralFeatures().push_back(m_HwPort__bitWidth);
    // m_HwPort__priority has already been allocated above
    m_HwPort__priority->setFeatureID(
            ::amalthea::AmaltheaPackage::HWPORT__PRIORITY);
    m_HwPortEClass->getEStructuralFeatures().push_back(m_HwPort__priority);
    // m_HwPort__portType has already been allocated above
    m_HwPort__portType->setFeatureID(
            ::amalthea::AmaltheaPackage::HWPORT__PORTTYPE);
    m_HwPortEClass->getEStructuralFeatures().push_back(m_HwPort__portType);
    // m_HwPort__portInterface has already been allocated above
    m_HwPort__portInterface->setFeatureID(
            ::amalthea::AmaltheaPackage::HWPORT__PORTINTERFACE);
    m_HwPortEClass->getEStructuralFeatures().push_back(m_HwPort__portInterface);
    // m_HwPort__delegated has already been allocated above
    m_HwPort__delegated->setFeatureID(
            ::amalthea::AmaltheaPackage::HWPORT__DELEGATED);
    m_HwPortEClass->getEStructuralFeatures().push_back(m_HwPort__delegated);
    // m_HwPort__connections has already been allocated above
    m_HwPort__connections->setFeatureID(
            ::amalthea::AmaltheaPackage::HWPORT__CONNECTIONS);
    m_HwPortEClass->getEStructuralFeatures().push_back(m_HwPort__connections);

    // ConnectionHandler
    {
        m_ConnectionHandlerEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_ConnectionHandlerEClass->setClassifierID(CONNECTIONHANDLER);
        m_ConnectionHandlerEClass->setEPackage(_this());
        getEClassifiers().push_back(m_ConnectionHandlerEClass);
    }
    // m_ConnectionHandler__definition has already been allocated above
    m_ConnectionHandler__definition->setFeatureID(
            ::amalthea::AmaltheaPackage::CONNECTIONHANDLER__DEFINITION);
    m_ConnectionHandlerEClass->getEStructuralFeatures().push_back(
            m_ConnectionHandler__definition);
    // m_ConnectionHandler__internalConnections has already been allocated above
    m_ConnectionHandler__internalConnections->setFeatureID(
            ::amalthea::AmaltheaPackage::CONNECTIONHANDLER__INTERNALCONNECTIONS);
    m_ConnectionHandlerEClass->getEStructuralFeatures().push_back(
            m_ConnectionHandler__internalConnections);

    // HwConnection
    {
        m_HwConnectionEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_HwConnectionEClass->setClassifierID(HWCONNECTION);
        m_HwConnectionEClass->setEPackage(_this());
        getEClassifiers().push_back(m_HwConnectionEClass);
    }
    // m_HwConnection__internal has already been allocated above
    m_HwConnection__internal->setFeatureID(
            ::amalthea::AmaltheaPackage::HWCONNECTION__INTERNAL);
    m_HwConnectionEClass->getEStructuralFeatures().push_back(
            m_HwConnection__internal);
    // m_HwConnection__readLatency has already been allocated above
    m_HwConnection__readLatency->setFeatureID(
            ::amalthea::AmaltheaPackage::HWCONNECTION__READLATENCY);
    m_HwConnectionEClass->getEStructuralFeatures().push_back(
            m_HwConnection__readLatency);
    // m_HwConnection__writeLatency has already been allocated above
    m_HwConnection__writeLatency->setFeatureID(
            ::amalthea::AmaltheaPackage::HWCONNECTION__WRITELATENCY);
    m_HwConnectionEClass->getEStructuralFeatures().push_back(
            m_HwConnection__writeLatency);
    // m_HwConnection__dataRate has already been allocated above
    m_HwConnection__dataRate->setFeatureID(
            ::amalthea::AmaltheaPackage::HWCONNECTION__DATARATE);
    m_HwConnectionEClass->getEStructuralFeatures().push_back(
            m_HwConnection__dataRate);
    // m_HwConnection__port1 has already been allocated above
    m_HwConnection__port1->setFeatureID(
            ::amalthea::AmaltheaPackage::HWCONNECTION__PORT1);
    m_HwConnectionEClass->getEStructuralFeatures().push_back(
            m_HwConnection__port1);
    // m_HwConnection__port2 has already been allocated above
    m_HwConnection__port2->setFeatureID(
            ::amalthea::AmaltheaPackage::HWCONNECTION__PORT2);
    m_HwConnectionEClass->getEStructuralFeatures().push_back(
            m_HwConnection__port2);

    // HwAccessElement
    {
        m_HwAccessElementEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_HwAccessElementEClass->setClassifierID(HWACCESSELEMENT);
        m_HwAccessElementEClass->setEPackage(_this());
        getEClassifiers().push_back(m_HwAccessElementEClass);
    }
    // m_HwAccessElement__source has already been allocated above
    m_HwAccessElement__source->setFeatureID(
            ::amalthea::AmaltheaPackage::HWACCESSELEMENT__SOURCE);
    m_HwAccessElementEClass->getEStructuralFeatures().push_back(
            m_HwAccessElement__source);
    // m_HwAccessElement__destination has already been allocated above
    m_HwAccessElement__destination->setFeatureID(
            ::amalthea::AmaltheaPackage::HWACCESSELEMENT__DESTINATION);
    m_HwAccessElementEClass->getEStructuralFeatures().push_back(
            m_HwAccessElement__destination);
    // m_HwAccessElement__accessPath has already been allocated above
    m_HwAccessElement__accessPath->setFeatureID(
            ::amalthea::AmaltheaPackage::HWACCESSELEMENT__ACCESSPATH);
    m_HwAccessElementEClass->getEStructuralFeatures().push_back(
            m_HwAccessElement__accessPath);
    // m_HwAccessElement__readLatency has already been allocated above
    m_HwAccessElement__readLatency->setFeatureID(
            ::amalthea::AmaltheaPackage::HWACCESSELEMENT__READLATENCY);
    m_HwAccessElementEClass->getEStructuralFeatures().push_back(
            m_HwAccessElement__readLatency);
    // m_HwAccessElement__writeLatency has already been allocated above
    m_HwAccessElement__writeLatency->setFeatureID(
            ::amalthea::AmaltheaPackage::HWACCESSELEMENT__WRITELATENCY);
    m_HwAccessElementEClass->getEStructuralFeatures().push_back(
            m_HwAccessElement__writeLatency);
    // m_HwAccessElement__dataRate has already been allocated above
    m_HwAccessElement__dataRate->setFeatureID(
            ::amalthea::AmaltheaPackage::HWACCESSELEMENT__DATARATE);
    m_HwAccessElementEClass->getEStructuralFeatures().push_back(
            m_HwAccessElement__dataRate);

    // HwDefinition
    {
        m_HwDefinitionEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_HwDefinitionEClass->setClassifierID(HWDEFINITION);
        m_HwDefinitionEClass->setEPackage(_this());
        getEClassifiers().push_back(m_HwDefinitionEClass);
    }

    // ProcessingUnitDefinition
    {
        m_ProcessingUnitDefinitionEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_ProcessingUnitDefinitionEClass->setClassifierID(
                PROCESSINGUNITDEFINITION);
        m_ProcessingUnitDefinitionEClass->setEPackage(_this());
        getEClassifiers().push_back(m_ProcessingUnitDefinitionEClass);
    }
    // m_ProcessingUnitDefinition__puType has already been allocated above
    m_ProcessingUnitDefinition__puType->setFeatureID(
            ::amalthea::AmaltheaPackage::PROCESSINGUNITDEFINITION__PUTYPE);
    m_ProcessingUnitDefinitionEClass->getEStructuralFeatures().push_back(
            m_ProcessingUnitDefinition__puType);
    // m_ProcessingUnitDefinition__features has already been allocated above
    m_ProcessingUnitDefinition__features->setFeatureID(
            ::amalthea::AmaltheaPackage::PROCESSINGUNITDEFINITION__FEATURES);
    m_ProcessingUnitDefinitionEClass->getEStructuralFeatures().push_back(
            m_ProcessingUnitDefinition__features);
    // m_ProcessingUnitDefinition__classifiers has already been allocated above
    m_ProcessingUnitDefinition__classifiers->setFeatureID(
            ::amalthea::AmaltheaPackage::PROCESSINGUNITDEFINITION__CLASSIFIERS);
    m_ProcessingUnitDefinitionEClass->getEStructuralFeatures().push_back(
            m_ProcessingUnitDefinition__classifiers);

    // ConnectionHandlerDefinition
    {
        m_ConnectionHandlerDefinitionEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_ConnectionHandlerDefinitionEClass->setClassifierID(
                CONNECTIONHANDLERDEFINITION);
        m_ConnectionHandlerDefinitionEClass->setEPackage(_this());
        getEClassifiers().push_back(m_ConnectionHandlerDefinitionEClass);
    }
    // m_ConnectionHandlerDefinition__policy has already been allocated above
    m_ConnectionHandlerDefinition__policy->setFeatureID(
            ::amalthea::AmaltheaPackage::CONNECTIONHANDLERDEFINITION__POLICY);
    m_ConnectionHandlerDefinitionEClass->getEStructuralFeatures().push_back(
            m_ConnectionHandlerDefinition__policy);
    // m_ConnectionHandlerDefinition__maxBurstSize has already been allocated above
    m_ConnectionHandlerDefinition__maxBurstSize->setFeatureID(
            ::amalthea::AmaltheaPackage::CONNECTIONHANDLERDEFINITION__MAXBURSTSIZE);
    m_ConnectionHandlerDefinitionEClass->getEStructuralFeatures().push_back(
            m_ConnectionHandlerDefinition__maxBurstSize);
    // m_ConnectionHandlerDefinition__maxConcurrentTransfers has already been allocated above
    m_ConnectionHandlerDefinition__maxConcurrentTransfers->setFeatureID(
            ::amalthea::AmaltheaPackage::CONNECTIONHANDLERDEFINITION__MAXCONCURRENTTRANSFERS);
    m_ConnectionHandlerDefinitionEClass->getEStructuralFeatures().push_back(
            m_ConnectionHandlerDefinition__maxConcurrentTransfers);
    // m_ConnectionHandlerDefinition__readLatency has already been allocated above
    m_ConnectionHandlerDefinition__readLatency->setFeatureID(
            ::amalthea::AmaltheaPackage::CONNECTIONHANDLERDEFINITION__READLATENCY);
    m_ConnectionHandlerDefinitionEClass->getEStructuralFeatures().push_back(
            m_ConnectionHandlerDefinition__readLatency);
    // m_ConnectionHandlerDefinition__writeLatency has already been allocated above
    m_ConnectionHandlerDefinition__writeLatency->setFeatureID(
            ::amalthea::AmaltheaPackage::CONNECTIONHANDLERDEFINITION__WRITELATENCY);
    m_ConnectionHandlerDefinitionEClass->getEStructuralFeatures().push_back(
            m_ConnectionHandlerDefinition__writeLatency);
    // m_ConnectionHandlerDefinition__dataRate has already been allocated above
    m_ConnectionHandlerDefinition__dataRate->setFeatureID(
            ::amalthea::AmaltheaPackage::CONNECTIONHANDLERDEFINITION__DATARATE);
    m_ConnectionHandlerDefinitionEClass->getEStructuralFeatures().push_back(
            m_ConnectionHandlerDefinition__dataRate);

    // MemoryDefinition
    {
        m_MemoryDefinitionEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_MemoryDefinitionEClass->setClassifierID(MEMORYDEFINITION);
        m_MemoryDefinitionEClass->setEPackage(_this());
        getEClassifiers().push_back(m_MemoryDefinitionEClass);
    }
    // m_MemoryDefinition__memoryType has already been allocated above
    m_MemoryDefinition__memoryType->setFeatureID(
            ::amalthea::AmaltheaPackage::MEMORYDEFINITION__MEMORYTYPE);
    m_MemoryDefinitionEClass->getEStructuralFeatures().push_back(
            m_MemoryDefinition__memoryType);
    // m_MemoryDefinition__size has already been allocated above
    m_MemoryDefinition__size->setFeatureID(
            ::amalthea::AmaltheaPackage::MEMORYDEFINITION__SIZE);
    m_MemoryDefinitionEClass->getEStructuralFeatures().push_back(
            m_MemoryDefinition__size);
    // m_MemoryDefinition__accessLatency has already been allocated above
    m_MemoryDefinition__accessLatency->setFeatureID(
            ::amalthea::AmaltheaPackage::MEMORYDEFINITION__ACCESSLATENCY);
    m_MemoryDefinitionEClass->getEStructuralFeatures().push_back(
            m_MemoryDefinition__accessLatency);
    // m_MemoryDefinition__dataRate has already been allocated above
    m_MemoryDefinition__dataRate->setFeatureID(
            ::amalthea::AmaltheaPackage::MEMORYDEFINITION__DATARATE);
    m_MemoryDefinitionEClass->getEStructuralFeatures().push_back(
            m_MemoryDefinition__dataRate);
    // m_MemoryDefinition__classifiers has already been allocated above
    m_MemoryDefinition__classifiers->setFeatureID(
            ::amalthea::AmaltheaPackage::MEMORYDEFINITION__CLASSIFIERS);
    m_MemoryDefinitionEClass->getEStructuralFeatures().push_back(
            m_MemoryDefinition__classifiers);

    // CacheDefinition
    {
        m_CacheDefinitionEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_CacheDefinitionEClass->setClassifierID(CACHEDEFINITION);
        m_CacheDefinitionEClass->setEPackage(_this());
        getEClassifiers().push_back(m_CacheDefinitionEClass);
    }
    // m_CacheDefinition__cacheType has already been allocated above
    m_CacheDefinition__cacheType->setFeatureID(
            ::amalthea::AmaltheaPackage::CACHEDEFINITION__CACHETYPE);
    m_CacheDefinitionEClass->getEStructuralFeatures().push_back(
            m_CacheDefinition__cacheType);
    // m_CacheDefinition__writeStrategy has already been allocated above
    m_CacheDefinition__writeStrategy->setFeatureID(
            ::amalthea::AmaltheaPackage::CACHEDEFINITION__WRITESTRATEGY);
    m_CacheDefinitionEClass->getEStructuralFeatures().push_back(
            m_CacheDefinition__writeStrategy);
    // m_CacheDefinition__nWays has already been allocated above
    m_CacheDefinition__nWays->setFeatureID(
            ::amalthea::AmaltheaPackage::CACHEDEFINITION__NWAYS);
    m_CacheDefinitionEClass->getEStructuralFeatures().push_back(
            m_CacheDefinition__nWays);
    // m_CacheDefinition__coherency has already been allocated above
    m_CacheDefinition__coherency->setFeatureID(
            ::amalthea::AmaltheaPackage::CACHEDEFINITION__COHERENCY);
    m_CacheDefinitionEClass->getEStructuralFeatures().push_back(
            m_CacheDefinition__coherency);
    // m_CacheDefinition__exclusive has already been allocated above
    m_CacheDefinition__exclusive->setFeatureID(
            ::amalthea::AmaltheaPackage::CACHEDEFINITION__EXCLUSIVE);
    m_CacheDefinitionEClass->getEStructuralFeatures().push_back(
            m_CacheDefinition__exclusive);
    // m_CacheDefinition__hitRate has already been allocated above
    m_CacheDefinition__hitRate->setFeatureID(
            ::amalthea::AmaltheaPackage::CACHEDEFINITION__HITRATE);
    m_CacheDefinitionEClass->getEStructuralFeatures().push_back(
            m_CacheDefinition__hitRate);
    // m_CacheDefinition__size has already been allocated above
    m_CacheDefinition__size->setFeatureID(
            ::amalthea::AmaltheaPackage::CACHEDEFINITION__SIZE);
    m_CacheDefinitionEClass->getEStructuralFeatures().push_back(
            m_CacheDefinition__size);
    // m_CacheDefinition__lineSize has already been allocated above
    m_CacheDefinition__lineSize->setFeatureID(
            ::amalthea::AmaltheaPackage::CACHEDEFINITION__LINESIZE);
    m_CacheDefinitionEClass->getEStructuralFeatures().push_back(
            m_CacheDefinition__lineSize);
    // m_CacheDefinition__accessLatency has already been allocated above
    m_CacheDefinition__accessLatency->setFeatureID(
            ::amalthea::AmaltheaPackage::CACHEDEFINITION__ACCESSLATENCY);
    m_CacheDefinitionEClass->getEStructuralFeatures().push_back(
            m_CacheDefinition__accessLatency);

    // HwPath
    {
        m_HwPathEClass = ::ecore::Ptr < ::ecore::EClass > (new ::ecore::EClass);
        m_HwPathEClass->setClassifierID(HWPATH);
        m_HwPathEClass->setEPackage(_this());
        getEClassifiers().push_back(m_HwPathEClass);
    }
    // m_HwPath__source has already been allocated above
    m_HwPath__source->setFeatureID(::amalthea::AmaltheaPackage::HWPATH__SOURCE);
    m_HwPathEClass->getEStructuralFeatures().push_back(m_HwPath__source);
    // m_HwPath__destination has already been allocated above
    m_HwPath__destination->setFeatureID(
            ::amalthea::AmaltheaPackage::HWPATH__DESTINATION);
    m_HwPathEClass->getEStructuralFeatures().push_back(m_HwPath__destination);

    // HwAccessPath
    {
        m_HwAccessPathEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_HwAccessPathEClass->setClassifierID(HWACCESSPATH);
        m_HwAccessPathEClass->setEPackage(_this());
        getEClassifiers().push_back(m_HwAccessPathEClass);
    }
    // m_HwAccessPath__startAddress has already been allocated above
    m_HwAccessPath__startAddress->setFeatureID(
            ::amalthea::AmaltheaPackage::HWACCESSPATH__STARTADDRESS);
    m_HwAccessPathEClass->getEStructuralFeatures().push_back(
            m_HwAccessPath__startAddress);
    // m_HwAccessPath__endAddress has already been allocated above
    m_HwAccessPath__endAddress->setFeatureID(
            ::amalthea::AmaltheaPackage::HWACCESSPATH__ENDADDRESS);
    m_HwAccessPathEClass->getEStructuralFeatures().push_back(
            m_HwAccessPath__endAddress);
    // m_HwAccessPath__memOffset has already been allocated above
    m_HwAccessPath__memOffset->setFeatureID(
            ::amalthea::AmaltheaPackage::HWACCESSPATH__MEMOFFSET);
    m_HwAccessPathEClass->getEStructuralFeatures().push_back(
            m_HwAccessPath__memOffset);
    // m_HwAccessPath__containingAccessElement has already been allocated above
    m_HwAccessPath__containingAccessElement->setFeatureID(
            ::amalthea::AmaltheaPackage::HWACCESSPATH__CONTAININGACCESSELEMENT);
    m_HwAccessPathEClass->getEStructuralFeatures().push_back(
            m_HwAccessPath__containingAccessElement);
    // m_HwAccessPath__pathElements has already been allocated above
    m_HwAccessPath__pathElements->setFeatureID(
            ::amalthea::AmaltheaPackage::HWACCESSPATH__PATHELEMENTS);
    m_HwAccessPathEClass->getEStructuralFeatures().push_back(
            m_HwAccessPath__pathElements);

    // HwPathElement
    {
        m_HwPathElementEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_HwPathElementEClass->setClassifierID(HWPATHELEMENT);
        m_HwPathElementEClass->setEPackage(_this());
        getEClassifiers().push_back(m_HwPathElementEClass);
    }

    // HwDestination
    {
        m_HwDestinationEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_HwDestinationEClass->setClassifierID(HWDESTINATION);
        m_HwDestinationEClass->setEPackage(_this());
        getEClassifiers().push_back(m_HwDestinationEClass);
    }

    // MappingModel
    {
        m_MappingModelEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_MappingModelEClass->setClassifierID(MAPPINGMODEL);
        m_MappingModelEClass->setEPackage(_this());
        getEClassifiers().push_back(m_MappingModelEClass);
    }
    // m_MappingModel__addressMappingType has already been allocated above
    m_MappingModel__addressMappingType->setFeatureID(
            ::amalthea::AmaltheaPackage::MAPPINGMODEL__ADDRESSMAPPINGTYPE);
    m_MappingModelEClass->getEStructuralFeatures().push_back(
            m_MappingModel__addressMappingType);
    // m_MappingModel__schedulerAllocation has already been allocated above
    m_MappingModel__schedulerAllocation->setFeatureID(
            ::amalthea::AmaltheaPackage::MAPPINGMODEL__SCHEDULERALLOCATION);
    m_MappingModelEClass->getEStructuralFeatures().push_back(
            m_MappingModel__schedulerAllocation);
    // m_MappingModel__runnableAllocation has already been allocated above
    m_MappingModel__runnableAllocation->setFeatureID(
            ::amalthea::AmaltheaPackage::MAPPINGMODEL__RUNNABLEALLOCATION);
    m_MappingModelEClass->getEStructuralFeatures().push_back(
            m_MappingModel__runnableAllocation);
    // m_MappingModel__taskAllocation has already been allocated above
    m_MappingModel__taskAllocation->setFeatureID(
            ::amalthea::AmaltheaPackage::MAPPINGMODEL__TASKALLOCATION);
    m_MappingModelEClass->getEStructuralFeatures().push_back(
            m_MappingModel__taskAllocation);
    // m_MappingModel__isrAllocation has already been allocated above
    m_MappingModel__isrAllocation->setFeatureID(
            ::amalthea::AmaltheaPackage::MAPPINGMODEL__ISRALLOCATION);
    m_MappingModelEClass->getEStructuralFeatures().push_back(
            m_MappingModel__isrAllocation);
    // m_MappingModel__memoryMapping has already been allocated above
    m_MappingModel__memoryMapping->setFeatureID(
            ::amalthea::AmaltheaPackage::MAPPINGMODEL__MEMORYMAPPING);
    m_MappingModelEClass->getEStructuralFeatures().push_back(
            m_MappingModel__memoryMapping);
    // m_MappingModel__physicalSectionMapping has already been allocated above
    m_MappingModel__physicalSectionMapping->setFeatureID(
            ::amalthea::AmaltheaPackage::MAPPINGMODEL__PHYSICALSECTIONMAPPING);
    m_MappingModelEClass->getEStructuralFeatures().push_back(
            m_MappingModel__physicalSectionMapping);

    // SchedulerAllocation
    {
        m_SchedulerAllocationEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_SchedulerAllocationEClass->setClassifierID(SCHEDULERALLOCATION);
        m_SchedulerAllocationEClass->setEPackage(_this());
        getEClassifiers().push_back(m_SchedulerAllocationEClass);
    }
    // m_SchedulerAllocation__scheduler has already been allocated above
    m_SchedulerAllocation__scheduler->setFeatureID(
            ::amalthea::AmaltheaPackage::SCHEDULERALLOCATION__SCHEDULER);
    m_SchedulerAllocationEClass->getEStructuralFeatures().push_back(
            m_SchedulerAllocation__scheduler);
    // m_SchedulerAllocation__responsibility has already been allocated above
    m_SchedulerAllocation__responsibility->setFeatureID(
            ::amalthea::AmaltheaPackage::SCHEDULERALLOCATION__RESPONSIBILITY);
    m_SchedulerAllocationEClass->getEStructuralFeatures().push_back(
            m_SchedulerAllocation__responsibility);
    // m_SchedulerAllocation__executingPU has already been allocated above
    m_SchedulerAllocation__executingPU->setFeatureID(
            ::amalthea::AmaltheaPackage::SCHEDULERALLOCATION__EXECUTINGPU);
    m_SchedulerAllocationEClass->getEStructuralFeatures().push_back(
            m_SchedulerAllocation__executingPU);

    // TaskAllocation
    {
        m_TaskAllocationEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_TaskAllocationEClass->setClassifierID(TASKALLOCATION);
        m_TaskAllocationEClass->setEPackage(_this());
        getEClassifiers().push_back(m_TaskAllocationEClass);
    }
    // m_TaskAllocation__task has already been allocated above
    m_TaskAllocation__task->setFeatureID(
            ::amalthea::AmaltheaPackage::TASKALLOCATION__TASK);
    m_TaskAllocationEClass->getEStructuralFeatures().push_back(
            m_TaskAllocation__task);
    // m_TaskAllocation__scheduler has already been allocated above
    m_TaskAllocation__scheduler->setFeatureID(
            ::amalthea::AmaltheaPackage::TASKALLOCATION__SCHEDULER);
    m_TaskAllocationEClass->getEStructuralFeatures().push_back(
            m_TaskAllocation__scheduler);
    // m_TaskAllocation__affinity has already been allocated above
    m_TaskAllocation__affinity->setFeatureID(
            ::amalthea::AmaltheaPackage::TASKALLOCATION__AFFINITY);
    m_TaskAllocationEClass->getEStructuralFeatures().push_back(
            m_TaskAllocation__affinity);
    // m_TaskAllocation__schedulingParameters has already been allocated above
    m_TaskAllocation__schedulingParameters->setFeatureID(
            ::amalthea::AmaltheaPackage::TASKALLOCATION__SCHEDULINGPARAMETERS);
    m_TaskAllocationEClass->getEStructuralFeatures().push_back(
            m_TaskAllocation__schedulingParameters);
    // m_TaskAllocation__parameterExtensions has already been allocated above
    m_TaskAllocation__parameterExtensions->setFeatureID(
            ::amalthea::AmaltheaPackage::TASKALLOCATION__PARAMETEREXTENSIONS);
    m_TaskAllocationEClass->getEStructuralFeatures().push_back(
            m_TaskAllocation__parameterExtensions);

    // ISRAllocation
    {
        m_ISRAllocationEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_ISRAllocationEClass->setClassifierID(ISRALLOCATION);
        m_ISRAllocationEClass->setEPackage(_this());
        getEClassifiers().push_back(m_ISRAllocationEClass);
    }
    // m_ISRAllocation__priority has already been allocated above
    m_ISRAllocation__priority->setFeatureID(
            ::amalthea::AmaltheaPackage::ISRALLOCATION__PRIORITY);
    m_ISRAllocationEClass->getEStructuralFeatures().push_back(
            m_ISRAllocation__priority);
    // m_ISRAllocation__isr has already been allocated above
    m_ISRAllocation__isr->setFeatureID(
            ::amalthea::AmaltheaPackage::ISRALLOCATION__ISR);
    m_ISRAllocationEClass->getEStructuralFeatures().push_back(
            m_ISRAllocation__isr);
    // m_ISRAllocation__controller has already been allocated above
    m_ISRAllocation__controller->setFeatureID(
            ::amalthea::AmaltheaPackage::ISRALLOCATION__CONTROLLER);
    m_ISRAllocationEClass->getEStructuralFeatures().push_back(
            m_ISRAllocation__controller);

    // RunnableAllocation
    {
        m_RunnableAllocationEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_RunnableAllocationEClass->setClassifierID(RUNNABLEALLOCATION);
        m_RunnableAllocationEClass->setEPackage(_this());
        getEClassifiers().push_back(m_RunnableAllocationEClass);
    }
    // m_RunnableAllocation__scheduler has already been allocated above
    m_RunnableAllocation__scheduler->setFeatureID(
            ::amalthea::AmaltheaPackage::RUNNABLEALLOCATION__SCHEDULER);
    m_RunnableAllocationEClass->getEStructuralFeatures().push_back(
            m_RunnableAllocation__scheduler);
    // m_RunnableAllocation__entity has already been allocated above
    m_RunnableAllocation__entity->setFeatureID(
            ::amalthea::AmaltheaPackage::RUNNABLEALLOCATION__ENTITY);
    m_RunnableAllocationEClass->getEStructuralFeatures().push_back(
            m_RunnableAllocation__entity);

    // MemoryMapping
    {
        m_MemoryMappingEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_MemoryMappingEClass->setClassifierID(MEMORYMAPPING);
        m_MemoryMappingEClass->setEPackage(_this());
        getEClassifiers().push_back(m_MemoryMappingEClass);
    }
    // m_MemoryMapping__memoryPositionAddress has already been allocated above
    m_MemoryMapping__memoryPositionAddress->setFeatureID(
            ::amalthea::AmaltheaPackage::MEMORYMAPPING__MEMORYPOSITIONADDRESS);
    m_MemoryMappingEClass->getEStructuralFeatures().push_back(
            m_MemoryMapping__memoryPositionAddress);
    // m_MemoryMapping__abstractElement has already been allocated above
    m_MemoryMapping__abstractElement->setFeatureID(
            ::amalthea::AmaltheaPackage::MEMORYMAPPING__ABSTRACTELEMENT);
    m_MemoryMappingEClass->getEStructuralFeatures().push_back(
            m_MemoryMapping__abstractElement);
    // m_MemoryMapping__memory has already been allocated above
    m_MemoryMapping__memory->setFeatureID(
            ::amalthea::AmaltheaPackage::MEMORYMAPPING__MEMORY);
    m_MemoryMappingEClass->getEStructuralFeatures().push_back(
            m_MemoryMapping__memory);

    // PhysicalSectionMapping
    {
        m_PhysicalSectionMappingEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_PhysicalSectionMappingEClass->setClassifierID(PHYSICALSECTIONMAPPING);
        m_PhysicalSectionMappingEClass->setEPackage(_this());
        getEClassifiers().push_back(m_PhysicalSectionMappingEClass);
    }
    // m_PhysicalSectionMapping__startAddress has already been allocated above
    m_PhysicalSectionMapping__startAddress->setFeatureID(
            ::amalthea::AmaltheaPackage::PHYSICALSECTIONMAPPING__STARTADDRESS);
    m_PhysicalSectionMappingEClass->getEStructuralFeatures().push_back(
            m_PhysicalSectionMapping__startAddress);
    // m_PhysicalSectionMapping__endAddress has already been allocated above
    m_PhysicalSectionMapping__endAddress->setFeatureID(
            ::amalthea::AmaltheaPackage::PHYSICALSECTIONMAPPING__ENDADDRESS);
    m_PhysicalSectionMappingEClass->getEStructuralFeatures().push_back(
            m_PhysicalSectionMapping__endAddress);
    // m_PhysicalSectionMapping__origin has already been allocated above
    m_PhysicalSectionMapping__origin->setFeatureID(
            ::amalthea::AmaltheaPackage::PHYSICALSECTIONMAPPING__ORIGIN);
    m_PhysicalSectionMappingEClass->getEStructuralFeatures().push_back(
            m_PhysicalSectionMapping__origin);
    // m_PhysicalSectionMapping__memory has already been allocated above
    m_PhysicalSectionMapping__memory->setFeatureID(
            ::amalthea::AmaltheaPackage::PHYSICALSECTIONMAPPING__MEMORY);
    m_PhysicalSectionMappingEClass->getEStructuralFeatures().push_back(
            m_PhysicalSectionMapping__memory);
    // m_PhysicalSectionMapping__labels has already been allocated above
    m_PhysicalSectionMapping__labels->setFeatureID(
            ::amalthea::AmaltheaPackage::PHYSICALSECTIONMAPPING__LABELS);
    m_PhysicalSectionMappingEClass->getEStructuralFeatures().push_back(
            m_PhysicalSectionMapping__labels);
    // m_PhysicalSectionMapping__runEntities has already been allocated above
    m_PhysicalSectionMapping__runEntities->setFeatureID(
            ::amalthea::AmaltheaPackage::PHYSICALSECTIONMAPPING__RUNENTITIES);
    m_PhysicalSectionMappingEClass->getEStructuralFeatures().push_back(
            m_PhysicalSectionMapping__runEntities);

    // OSModel
    {
        m_OSModelEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_OSModelEClass->setClassifierID(OSMODEL);
        m_OSModelEClass->setEPackage(_this());
        getEClassifiers().push_back(m_OSModelEClass);
    }
    // m_OSModel__semaphores has already been allocated above
    m_OSModel__semaphores->setFeatureID(
            ::amalthea::AmaltheaPackage::OSMODEL__SEMAPHORES);
    m_OSModelEClass->getEStructuralFeatures().push_back(m_OSModel__semaphores);
    // m_OSModel__operatingSystems has already been allocated above
    m_OSModel__operatingSystems->setFeatureID(
            ::amalthea::AmaltheaPackage::OSMODEL__OPERATINGSYSTEMS);
    m_OSModelEClass->getEStructuralFeatures().push_back(
            m_OSModel__operatingSystems);
    // m_OSModel__osOverheads has already been allocated above
    m_OSModel__osOverheads->setFeatureID(
            ::amalthea::AmaltheaPackage::OSMODEL__OSOVERHEADS);
    m_OSModelEClass->getEStructuralFeatures().push_back(m_OSModel__osOverheads);

    // OsDataConsistency
    {
        m_OsDataConsistencyEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_OsDataConsistencyEClass->setClassifierID(OSDATACONSISTENCY);
        m_OsDataConsistencyEClass->setEPackage(_this());
        getEClassifiers().push_back(m_OsDataConsistencyEClass);
    }
    // m_OsDataConsistency__mode has already been allocated above
    m_OsDataConsistency__mode->setFeatureID(
            ::amalthea::AmaltheaPackage::OSDATACONSISTENCY__MODE);
    m_OsDataConsistencyEClass->getEStructuralFeatures().push_back(
            m_OsDataConsistency__mode);
    // m_OsDataConsistency__dataStability has already been allocated above
    m_OsDataConsistency__dataStability->setFeatureID(
            ::amalthea::AmaltheaPackage::OSDATACONSISTENCY__DATASTABILITY);
    m_OsDataConsistencyEClass->getEStructuralFeatures().push_back(
            m_OsDataConsistency__dataStability);
    // m_OsDataConsistency__nonAtomicDataCoherency has already been allocated above
    m_OsDataConsistency__nonAtomicDataCoherency->setFeatureID(
            ::amalthea::AmaltheaPackage::OSDATACONSISTENCY__NONATOMICDATACOHERENCY);
    m_OsDataConsistencyEClass->getEStructuralFeatures().push_back(
            m_OsDataConsistency__nonAtomicDataCoherency);

    // DataStability
    {
        m_DataStabilityEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_DataStabilityEClass->setClassifierID(DATASTABILITY);
        m_DataStabilityEClass->setEPackage(_this());
        getEClassifiers().push_back(m_DataStabilityEClass);
    }
    // m_DataStability__enabled has already been allocated above
    m_DataStability__enabled->setFeatureID(
            ::amalthea::AmaltheaPackage::DATASTABILITY__ENABLED);
    m_DataStabilityEClass->getEStructuralFeatures().push_back(
            m_DataStability__enabled);
    // m_DataStability__algorithm has already been allocated above
    m_DataStability__algorithm->setFeatureID(
            ::amalthea::AmaltheaPackage::DATASTABILITY__ALGORITHM);
    m_DataStabilityEClass->getEStructuralFeatures().push_back(
            m_DataStability__algorithm);
    // m_DataStability__accessMultiplicity has already been allocated above
    m_DataStability__accessMultiplicity->setFeatureID(
            ::amalthea::AmaltheaPackage::DATASTABILITY__ACCESSMULTIPLICITY);
    m_DataStabilityEClass->getEStructuralFeatures().push_back(
            m_DataStability__accessMultiplicity);
    // m_DataStability__level has already been allocated above
    m_DataStability__level->setFeatureID(
            ::amalthea::AmaltheaPackage::DATASTABILITY__LEVEL);
    m_DataStabilityEClass->getEStructuralFeatures().push_back(
            m_DataStability__level);

    // NonAtomicDataCoherency
    {
        m_NonAtomicDataCoherencyEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_NonAtomicDataCoherencyEClass->setClassifierID(NONATOMICDATACOHERENCY);
        m_NonAtomicDataCoherencyEClass->setEPackage(_this());
        getEClassifiers().push_back(m_NonAtomicDataCoherencyEClass);
    }
    // m_NonAtomicDataCoherency__enabled has already been allocated above
    m_NonAtomicDataCoherency__enabled->setFeatureID(
            ::amalthea::AmaltheaPackage::NONATOMICDATACOHERENCY__ENABLED);
    m_NonAtomicDataCoherencyEClass->getEStructuralFeatures().push_back(
            m_NonAtomicDataCoherency__enabled);
    // m_NonAtomicDataCoherency__algorithm has already been allocated above
    m_NonAtomicDataCoherency__algorithm->setFeatureID(
            ::amalthea::AmaltheaPackage::NONATOMICDATACOHERENCY__ALGORITHM);
    m_NonAtomicDataCoherencyEClass->getEStructuralFeatures().push_back(
            m_NonAtomicDataCoherency__algorithm);
    // m_NonAtomicDataCoherency__accessMultiplicity has already been allocated above
    m_NonAtomicDataCoherency__accessMultiplicity->setFeatureID(
            ::amalthea::AmaltheaPackage::NONATOMICDATACOHERENCY__ACCESSMULTIPLICITY);
    m_NonAtomicDataCoherencyEClass->getEStructuralFeatures().push_back(
            m_NonAtomicDataCoherency__accessMultiplicity);

    // Semaphore
    {
        m_SemaphoreEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_SemaphoreEClass->setClassifierID(SEMAPHORE);
        m_SemaphoreEClass->setEPackage(_this());
        getEClassifiers().push_back(m_SemaphoreEClass);
    }
    // m_Semaphore__semaphoreType has already been allocated above
    m_Semaphore__semaphoreType->setFeatureID(
            ::amalthea::AmaltheaPackage::SEMAPHORE__SEMAPHORETYPE);
    m_SemaphoreEClass->getEStructuralFeatures().push_back(
            m_Semaphore__semaphoreType);
    // m_Semaphore__initialValue has already been allocated above
    m_Semaphore__initialValue->setFeatureID(
            ::amalthea::AmaltheaPackage::SEMAPHORE__INITIALVALUE);
    m_SemaphoreEClass->getEStructuralFeatures().push_back(
            m_Semaphore__initialValue);
    // m_Semaphore__maxValue has already been allocated above
    m_Semaphore__maxValue->setFeatureID(
            ::amalthea::AmaltheaPackage::SEMAPHORE__MAXVALUE);
    m_SemaphoreEClass->getEStructuralFeatures().push_back(
            m_Semaphore__maxValue);
    // m_Semaphore__priorityCeilingProtocol has already been allocated above
    m_Semaphore__priorityCeilingProtocol->setFeatureID(
            ::amalthea::AmaltheaPackage::SEMAPHORE__PRIORITYCEILINGPROTOCOL);
    m_SemaphoreEClass->getEStructuralFeatures().push_back(
            m_Semaphore__priorityCeilingProtocol);
    // m_Semaphore__semaphoreAccesses has already been allocated above
    m_Semaphore__semaphoreAccesses->setFeatureID(
            ::amalthea::AmaltheaPackage::SEMAPHORE__SEMAPHOREACCESSES);
    m_SemaphoreEClass->getEStructuralFeatures().push_back(
            m_Semaphore__semaphoreAccesses);
    // m_Semaphore__referringComponents has already been allocated above
    m_Semaphore__referringComponents->setFeatureID(
            ::amalthea::AmaltheaPackage::SEMAPHORE__REFERRINGCOMPONENTS);
    m_SemaphoreEClass->getEStructuralFeatures().push_back(
            m_Semaphore__referringComponents);

    // Scheduler
    {
        m_SchedulerEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_SchedulerEClass->setClassifierID(SCHEDULER);
        m_SchedulerEClass->setEPackage(_this());
        getEClassifiers().push_back(m_SchedulerEClass);
    }
    // m_Scheduler__computationItems has already been allocated above
    m_Scheduler__computationItems->setFeatureID(
            ::amalthea::AmaltheaPackage::SCHEDULER__COMPUTATIONITEMS);
    m_SchedulerEClass->getEStructuralFeatures().push_back(
            m_Scheduler__computationItems);
    // m_Scheduler__schedulerAllocations has already been allocated above
    m_Scheduler__schedulerAllocations->setFeatureID(
            ::amalthea::AmaltheaPackage::SCHEDULER__SCHEDULERALLOCATIONS);
    m_SchedulerEClass->getEStructuralFeatures().push_back(
            m_Scheduler__schedulerAllocations);
    // m_Scheduler__runnableAllocations has already been allocated above
    m_Scheduler__runnableAllocations->setFeatureID(
            ::amalthea::AmaltheaPackage::SCHEDULER__RUNNABLEALLOCATIONS);
    m_SchedulerEClass->getEStructuralFeatures().push_back(
            m_Scheduler__runnableAllocations);

    // TaskScheduler
    {
        m_TaskSchedulerEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_TaskSchedulerEClass->setClassifierID(TASKSCHEDULER);
        m_TaskSchedulerEClass->setEPackage(_this());
        getEClassifiers().push_back(m_TaskSchedulerEClass);
    }
    // m_TaskScheduler__schedulingAlgorithm has already been allocated above
    m_TaskScheduler__schedulingAlgorithm->setFeatureID(
            ::amalthea::AmaltheaPackage::TASKSCHEDULER__SCHEDULINGALGORITHM);
    m_TaskSchedulerEClass->getEStructuralFeatures().push_back(
            m_TaskScheduler__schedulingAlgorithm);
    // m_TaskScheduler__parentAssociation has already been allocated above
    m_TaskScheduler__parentAssociation->setFeatureID(
            ::amalthea::AmaltheaPackage::TASKSCHEDULER__PARENTASSOCIATION);
    m_TaskSchedulerEClass->getEStructuralFeatures().push_back(
            m_TaskScheduler__parentAssociation);
    // m_TaskScheduler__childAssociations has already been allocated above
    m_TaskScheduler__childAssociations->setFeatureID(
            ::amalthea::AmaltheaPackage::TASKSCHEDULER__CHILDASSOCIATIONS);
    m_TaskSchedulerEClass->getEStructuralFeatures().push_back(
            m_TaskScheduler__childAssociations);
    // m_TaskScheduler__taskAllocations has already been allocated above
    m_TaskScheduler__taskAllocations->setFeatureID(
            ::amalthea::AmaltheaPackage::TASKSCHEDULER__TASKALLOCATIONS);
    m_TaskSchedulerEClass->getEStructuralFeatures().push_back(
            m_TaskScheduler__taskAllocations);
    // m_TaskScheduler__parentScheduler has already been allocated above
    m_TaskScheduler__parentScheduler->setFeatureID(
            ::amalthea::AmaltheaPackage::TASKSCHEDULER__PARENTSCHEDULER);
    m_TaskSchedulerEClass->getEStructuralFeatures().push_back(
            m_TaskScheduler__parentScheduler);
    // m_TaskScheduler__childSchedulers has already been allocated above
    m_TaskScheduler__childSchedulers->setFeatureID(
            ::amalthea::AmaltheaPackage::TASKSCHEDULER__CHILDSCHEDULERS);
    m_TaskSchedulerEClass->getEStructuralFeatures().push_back(
            m_TaskScheduler__childSchedulers);

    // SchedulerAssociation
    {
        m_SchedulerAssociationEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_SchedulerAssociationEClass->setClassifierID(SCHEDULERASSOCIATION);
        m_SchedulerAssociationEClass->setEPackage(_this());
        getEClassifiers().push_back(m_SchedulerAssociationEClass);
    }
    // m_SchedulerAssociation__child has already been allocated above
    m_SchedulerAssociation__child->setFeatureID(
            ::amalthea::AmaltheaPackage::SCHEDULERASSOCIATION__CHILD);
    m_SchedulerAssociationEClass->getEStructuralFeatures().push_back(
            m_SchedulerAssociation__child);
    // m_SchedulerAssociation__parent has already been allocated above
    m_SchedulerAssociation__parent->setFeatureID(
            ::amalthea::AmaltheaPackage::SCHEDULERASSOCIATION__PARENT);
    m_SchedulerAssociationEClass->getEStructuralFeatures().push_back(
            m_SchedulerAssociation__parent);
    // m_SchedulerAssociation__schedulingParameters has already been allocated above
    m_SchedulerAssociation__schedulingParameters->setFeatureID(
            ::amalthea::AmaltheaPackage::SCHEDULERASSOCIATION__SCHEDULINGPARAMETERS);
    m_SchedulerAssociationEClass->getEStructuralFeatures().push_back(
            m_SchedulerAssociation__schedulingParameters);
    // m_SchedulerAssociation__parameterExtensions has already been allocated above
    m_SchedulerAssociation__parameterExtensions->setFeatureID(
            ::amalthea::AmaltheaPackage::SCHEDULERASSOCIATION__PARAMETEREXTENSIONS);
    m_SchedulerAssociationEClass->getEStructuralFeatures().push_back(
            m_SchedulerAssociation__parameterExtensions);

    // InterruptController
    {
        m_InterruptControllerEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_InterruptControllerEClass->setClassifierID(INTERRUPTCONTROLLER);
        m_InterruptControllerEClass->setEPackage(_this());
        getEClassifiers().push_back(m_InterruptControllerEClass);
    }
    // m_InterruptController__schedulingAlgorithm has already been allocated above
    m_InterruptController__schedulingAlgorithm->setFeatureID(
            ::amalthea::AmaltheaPackage::INTERRUPTCONTROLLER__SCHEDULINGALGORITHM);
    m_InterruptControllerEClass->getEStructuralFeatures().push_back(
            m_InterruptController__schedulingAlgorithm);
    // m_InterruptController__isrAllocations has already been allocated above
    m_InterruptController__isrAllocations->setFeatureID(
            ::amalthea::AmaltheaPackage::INTERRUPTCONTROLLER__ISRALLOCATIONS);
    m_InterruptControllerEClass->getEStructuralFeatures().push_back(
            m_InterruptController__isrAllocations);

    // SchedulingParameters
    {
        m_SchedulingParametersEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_SchedulingParametersEClass->setClassifierID(SCHEDULINGPARAMETERS);
        m_SchedulingParametersEClass->setEPackage(_this());
        getEClassifiers().push_back(m_SchedulingParametersEClass);
    }
    // m_SchedulingParameters__priority has already been allocated above
    m_SchedulingParameters__priority->setFeatureID(
            ::amalthea::AmaltheaPackage::SCHEDULINGPARAMETERS__PRIORITY);
    m_SchedulingParametersEClass->getEStructuralFeatures().push_back(
            m_SchedulingParameters__priority);
    // m_SchedulingParameters__minBudget has already been allocated above
    m_SchedulingParameters__minBudget->setFeatureID(
            ::amalthea::AmaltheaPackage::SCHEDULINGPARAMETERS__MINBUDGET);
    m_SchedulingParametersEClass->getEStructuralFeatures().push_back(
            m_SchedulingParameters__minBudget);
    // m_SchedulingParameters__maxBudget has already been allocated above
    m_SchedulingParameters__maxBudget->setFeatureID(
            ::amalthea::AmaltheaPackage::SCHEDULINGPARAMETERS__MAXBUDGET);
    m_SchedulingParametersEClass->getEStructuralFeatures().push_back(
            m_SchedulingParameters__maxBudget);
    // m_SchedulingParameters__replenishment has already been allocated above
    m_SchedulingParameters__replenishment->setFeatureID(
            ::amalthea::AmaltheaPackage::SCHEDULINGPARAMETERS__REPLENISHMENT);
    m_SchedulingParametersEClass->getEStructuralFeatures().push_back(
            m_SchedulingParameters__replenishment);

    // ParameterExtension
    {
        m_ParameterExtensionEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_ParameterExtensionEClass->setClassifierID(PARAMETEREXTENSION);
        m_ParameterExtensionEClass->setEPackage(_this());
        getEClassifiers().push_back(m_ParameterExtensionEClass);
    }
    // m_ParameterExtension__key has already been allocated above
    m_ParameterExtension__key->setFeatureID(
            ::amalthea::AmaltheaPackage::PARAMETEREXTENSION__KEY);
    m_ParameterExtensionEClass->getEStructuralFeatures().push_back(
            m_ParameterExtension__key);
    // m_ParameterExtension__value has already been allocated above
    m_ParameterExtension__value->setFeatureID(
            ::amalthea::AmaltheaPackage::PARAMETEREXTENSION__VALUE);
    m_ParameterExtensionEClass->getEStructuralFeatures().push_back(
            m_ParameterExtension__value);

    // Algorithm
    {
        m_AlgorithmEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_AlgorithmEClass->setClassifierID(ALGORITHM);
        m_AlgorithmEClass->setEPackage(_this());
        getEClassifiers().push_back(m_AlgorithmEClass);
    }

    // InterruptSchedulingAlgorithm
    {
        m_InterruptSchedulingAlgorithmEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_InterruptSchedulingAlgorithmEClass->setClassifierID(
                INTERRUPTSCHEDULINGALGORITHM);
        m_InterruptSchedulingAlgorithmEClass->setEPackage(_this());
        getEClassifiers().push_back(m_InterruptSchedulingAlgorithmEClass);
    }

    // TaskSchedulingAlgorithm
    {
        m_TaskSchedulingAlgorithmEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_TaskSchedulingAlgorithmEClass->setClassifierID(
                TASKSCHEDULINGALGORITHM);
        m_TaskSchedulingAlgorithmEClass->setEPackage(_this());
        getEClassifiers().push_back(m_TaskSchedulingAlgorithmEClass);
    }

    // FixedPriority
    {
        m_FixedPriorityEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_FixedPriorityEClass->setClassifierID(FIXEDPRIORITY);
        m_FixedPriorityEClass->setEPackage(_this());
        getEClassifiers().push_back(m_FixedPriorityEClass);
    }

    // FixedPriorityPreemptive
    {
        m_FixedPriorityPreemptiveEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_FixedPriorityPreemptiveEClass->setClassifierID(
                FIXEDPRIORITYPREEMPTIVE);
        m_FixedPriorityPreemptiveEClass->setEPackage(_this());
        getEClassifiers().push_back(m_FixedPriorityPreemptiveEClass);
    }

    // FixedPriorityPreemptiveWithBudgetEnforcement
    {
        m_FixedPriorityPreemptiveWithBudgetEnforcementEClass = ::ecore::Ptr
                < ::ecore::EClass > (new ::ecore::EClass);
        m_FixedPriorityPreemptiveWithBudgetEnforcementEClass->setClassifierID(
                FIXEDPRIORITYPREEMPTIVEWITHBUDGETENFORCEMENT);
        m_FixedPriorityPreemptiveWithBudgetEnforcementEClass->setEPackage(
                _this());
        getEClassifiers().push_back(
                m_FixedPriorityPreemptiveWithBudgetEnforcementEClass);
    }

    // OSEK
    {
        m_OSEKEClass = ::ecore::Ptr < ::ecore::EClass > (new ::ecore::EClass);
        m_OSEKEClass->setClassifierID(OSEK);
        m_OSEKEClass->setEPackage(_this());
        getEClassifiers().push_back(m_OSEKEClass);
    }

    // DeadlineMonotonic
    {
        m_DeadlineMonotonicEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_DeadlineMonotonicEClass->setClassifierID(DEADLINEMONOTONIC);
        m_DeadlineMonotonicEClass->setEPackage(_this());
        getEClassifiers().push_back(m_DeadlineMonotonicEClass);
    }

    // RateMonotonic
    {
        m_RateMonotonicEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_RateMonotonicEClass->setClassifierID(RATEMONOTONIC);
        m_RateMonotonicEClass->setEPackage(_this());
        getEClassifiers().push_back(m_RateMonotonicEClass);
    }

    // Pfair
    {
        m_PfairEClass = ::ecore::Ptr < ::ecore::EClass > (new ::ecore::EClass);
        m_PfairEClass->setClassifierID(PFAIR);
        m_PfairEClass->setEPackage(_this());
        getEClassifiers().push_back(m_PfairEClass);
    }
    // m_Pfair__quantSizeNs has already been allocated above
    m_Pfair__quantSizeNs->setFeatureID(
            ::amalthea::AmaltheaPackage::PFAIR__QUANTSIZENS);
    m_PfairEClass->getEStructuralFeatures().push_back(m_Pfair__quantSizeNs);

    // PfairPD2
    {
        m_PfairPD2EClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_PfairPD2EClass->setClassifierID(PFAIRPD2);
        m_PfairPD2EClass->setEPackage(_this());
        getEClassifiers().push_back(m_PfairPD2EClass);
    }

    // PartlyPFairPD2
    {
        m_PartlyPFairPD2EClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_PartlyPFairPD2EClass->setClassifierID(PARTLYPFAIRPD2);
        m_PartlyPFairPD2EClass->setEPackage(_this());
        getEClassifiers().push_back(m_PartlyPFairPD2EClass);
    }

    // EarlyReleaseFairPD2
    {
        m_EarlyReleaseFairPD2EClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_EarlyReleaseFairPD2EClass->setClassifierID(EARLYRELEASEFAIRPD2);
        m_EarlyReleaseFairPD2EClass->setEPackage(_this());
        getEClassifiers().push_back(m_EarlyReleaseFairPD2EClass);
    }

    // PartlyEarlyReleaseFairPD2
    {
        m_PartlyEarlyReleaseFairPD2EClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_PartlyEarlyReleaseFairPD2EClass->setClassifierID(
                PARTLYEARLYRELEASEFAIRPD2);
        m_PartlyEarlyReleaseFairPD2EClass->setEPackage(_this());
        getEClassifiers().push_back(m_PartlyEarlyReleaseFairPD2EClass);
    }

    // DynamicPriority
    {
        m_DynamicPriorityEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_DynamicPriorityEClass->setClassifierID(DYNAMICPRIORITY);
        m_DynamicPriorityEClass->setEPackage(_this());
        getEClassifiers().push_back(m_DynamicPriorityEClass);
    }

    // LeastLocalRemainingExecutionTimeFirst
    {
        m_LeastLocalRemainingExecutionTimeFirstEClass = ::ecore::Ptr
                < ::ecore::EClass > (new ::ecore::EClass);
        m_LeastLocalRemainingExecutionTimeFirstEClass->setClassifierID(
                LEASTLOCALREMAININGEXECUTIONTIMEFIRST);
        m_LeastLocalRemainingExecutionTimeFirstEClass->setEPackage(_this());
        getEClassifiers().push_back(
                m_LeastLocalRemainingExecutionTimeFirstEClass);
    }

    // EarliestDeadlineFirst
    {
        m_EarliestDeadlineFirstEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_EarliestDeadlineFirstEClass->setClassifierID(EARLIESTDEADLINEFIRST);
        m_EarliestDeadlineFirstEClass->setEPackage(_this());
        getEClassifiers().push_back(m_EarliestDeadlineFirstEClass);
    }

    // PriorityBasedRoundRobin
    {
        m_PriorityBasedRoundRobinEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_PriorityBasedRoundRobinEClass->setClassifierID(
                PRIORITYBASEDROUNDROBIN);
        m_PriorityBasedRoundRobinEClass->setEPackage(_this());
        getEClassifiers().push_back(m_PriorityBasedRoundRobinEClass);
    }

    // ReservationBasedServer
    {
        m_ReservationBasedServerEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_ReservationBasedServerEClass->setClassifierID(RESERVATIONBASEDSERVER);
        m_ReservationBasedServerEClass->setEPackage(_this());
        getEClassifiers().push_back(m_ReservationBasedServerEClass);
    }

    // DeferrableServer
    {
        m_DeferrableServerEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_DeferrableServerEClass->setClassifierID(DEFERRABLESERVER);
        m_DeferrableServerEClass->setEPackage(_this());
        getEClassifiers().push_back(m_DeferrableServerEClass);
    }

    // PollingPeriodicServer
    {
        m_PollingPeriodicServerEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_PollingPeriodicServerEClass->setClassifierID(POLLINGPERIODICSERVER);
        m_PollingPeriodicServerEClass->setEPackage(_this());
        getEClassifiers().push_back(m_PollingPeriodicServerEClass);
    }

    // SporadicServer
    {
        m_SporadicServerEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_SporadicServerEClass->setClassifierID(SPORADICSERVER);
        m_SporadicServerEClass->setEPackage(_this());
        getEClassifiers().push_back(m_SporadicServerEClass);
    }

    // ConstantBandwidthServer
    {
        m_ConstantBandwidthServerEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_ConstantBandwidthServerEClass->setClassifierID(
                CONSTANTBANDWIDTHSERVER);
        m_ConstantBandwidthServerEClass->setEPackage(_this());
        getEClassifiers().push_back(m_ConstantBandwidthServerEClass);
    }

    // ConstantBandwidthServerWithCASH
    {
        m_ConstantBandwidthServerWithCASHEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_ConstantBandwidthServerWithCASHEClass->setClassifierID(
                CONSTANTBANDWIDTHSERVERWITHCASH);
        m_ConstantBandwidthServerWithCASHEClass->setEPackage(_this());
        getEClassifiers().push_back(m_ConstantBandwidthServerWithCASHEClass);
    }

    // Grouping
    {
        m_GroupingEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_GroupingEClass->setClassifierID(GROUPING);
        m_GroupingEClass->setEPackage(_this());
        getEClassifiers().push_back(m_GroupingEClass);
    }

    // UserSpecificSchedulingAlgorithm
    {
        m_UserSpecificSchedulingAlgorithmEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_UserSpecificSchedulingAlgorithmEClass->setClassifierID(
                USERSPECIFICSCHEDULINGALGORITHM);
        m_UserSpecificSchedulingAlgorithmEClass->setEPackage(_this());
        getEClassifiers().push_back(m_UserSpecificSchedulingAlgorithmEClass);
    }
    // m_UserSpecificSchedulingAlgorithm__parameterExtensions has already been allocated above
    m_UserSpecificSchedulingAlgorithm__parameterExtensions->setFeatureID(
            ::amalthea::AmaltheaPackage::USERSPECIFICSCHEDULINGALGORITHM__PARAMETEREXTENSIONS);
    m_UserSpecificSchedulingAlgorithmEClass->getEStructuralFeatures().push_back(
            m_UserSpecificSchedulingAlgorithm__parameterExtensions);

    // PriorityBased
    {
        m_PriorityBasedEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_PriorityBasedEClass->setClassifierID(PRIORITYBASED);
        m_PriorityBasedEClass->setEPackage(_this());
        getEClassifiers().push_back(m_PriorityBasedEClass);
    }

    // OperatingSystem
    {
        m_OperatingSystemEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_OperatingSystemEClass->setClassifierID(OPERATINGSYSTEM);
        m_OperatingSystemEClass->setEPackage(_this());
        getEClassifiers().push_back(m_OperatingSystemEClass);
    }
    // m_OperatingSystem__overhead has already been allocated above
    m_OperatingSystem__overhead->setFeatureID(
            ::amalthea::AmaltheaPackage::OPERATINGSYSTEM__OVERHEAD);
    m_OperatingSystemEClass->getEStructuralFeatures().push_back(
            m_OperatingSystem__overhead);
    // m_OperatingSystem__taskSchedulers has already been allocated above
    m_OperatingSystem__taskSchedulers->setFeatureID(
            ::amalthea::AmaltheaPackage::OPERATINGSYSTEM__TASKSCHEDULERS);
    m_OperatingSystemEClass->getEStructuralFeatures().push_back(
            m_OperatingSystem__taskSchedulers);
    // m_OperatingSystem__interruptControllers has already been allocated above
    m_OperatingSystem__interruptControllers->setFeatureID(
            ::amalthea::AmaltheaPackage::OPERATINGSYSTEM__INTERRUPTCONTROLLERS);
    m_OperatingSystemEClass->getEStructuralFeatures().push_back(
            m_OperatingSystem__interruptControllers);
    // m_OperatingSystem__osDataConsistency has already been allocated above
    m_OperatingSystem__osDataConsistency->setFeatureID(
            ::amalthea::AmaltheaPackage::OPERATINGSYSTEM__OSDATACONSISTENCY);
    m_OperatingSystemEClass->getEStructuralFeatures().push_back(
            m_OperatingSystem__osDataConsistency);

    // VendorOperatingSystem
    {
        m_VendorOperatingSystemEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_VendorOperatingSystemEClass->setClassifierID(VENDOROPERATINGSYSTEM);
        m_VendorOperatingSystemEClass->setEPackage(_this());
        getEClassifiers().push_back(m_VendorOperatingSystemEClass);
    }
    // m_VendorOperatingSystem__osName has already been allocated above
    m_VendorOperatingSystem__osName->setFeatureID(
            ::amalthea::AmaltheaPackage::VENDOROPERATINGSYSTEM__OSNAME);
    m_VendorOperatingSystemEClass->getEStructuralFeatures().push_back(
            m_VendorOperatingSystem__osName);
    // m_VendorOperatingSystem__vendor has already been allocated above
    m_VendorOperatingSystem__vendor->setFeatureID(
            ::amalthea::AmaltheaPackage::VENDOROPERATINGSYSTEM__VENDOR);
    m_VendorOperatingSystemEClass->getEStructuralFeatures().push_back(
            m_VendorOperatingSystem__vendor);
    // m_VendorOperatingSystem__version has already been allocated above
    m_VendorOperatingSystem__version->setFeatureID(
            ::amalthea::AmaltheaPackage::VENDOROPERATINGSYSTEM__VERSION);
    m_VendorOperatingSystemEClass->getEStructuralFeatures().push_back(
            m_VendorOperatingSystem__version);

    // OsOverhead
    {
        m_OsOverheadEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_OsOverheadEClass->setClassifierID(OSOVERHEAD);
        m_OsOverheadEClass->setEPackage(_this());
        getEClassifiers().push_back(m_OsOverheadEClass);
    }
    // m_OsOverhead__apiOverhead has already been allocated above
    m_OsOverhead__apiOverhead->setFeatureID(
            ::amalthea::AmaltheaPackage::OSOVERHEAD__APIOVERHEAD);
    m_OsOverheadEClass->getEStructuralFeatures().push_back(
            m_OsOverhead__apiOverhead);
    // m_OsOverhead__isrCategory1Overhead has already been allocated above
    m_OsOverhead__isrCategory1Overhead->setFeatureID(
            ::amalthea::AmaltheaPackage::OSOVERHEAD__ISRCATEGORY1OVERHEAD);
    m_OsOverheadEClass->getEStructuralFeatures().push_back(
            m_OsOverhead__isrCategory1Overhead);
    // m_OsOverhead__isrCategory2Overhead has already been allocated above
    m_OsOverhead__isrCategory2Overhead->setFeatureID(
            ::amalthea::AmaltheaPackage::OSOVERHEAD__ISRCATEGORY2OVERHEAD);
    m_OsOverheadEClass->getEStructuralFeatures().push_back(
            m_OsOverhead__isrCategory2Overhead);

    // OsAPIOverhead
    {
        m_OsAPIOverheadEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_OsAPIOverheadEClass->setClassifierID(OSAPIOVERHEAD);
        m_OsAPIOverheadEClass->setEPackage(_this());
        getEClassifiers().push_back(m_OsAPIOverheadEClass);
    }
    // m_OsAPIOverhead__apiSendMessage has already been allocated above
    m_OsAPIOverhead__apiSendMessage->setFeatureID(
            ::amalthea::AmaltheaPackage::OSAPIOVERHEAD__APISENDMESSAGE);
    m_OsAPIOverheadEClass->getEStructuralFeatures().push_back(
            m_OsAPIOverhead__apiSendMessage);
    // m_OsAPIOverhead__apiTerminateTask has already been allocated above
    m_OsAPIOverhead__apiTerminateTask->setFeatureID(
            ::amalthea::AmaltheaPackage::OSAPIOVERHEAD__APITERMINATETASK);
    m_OsAPIOverheadEClass->getEStructuralFeatures().push_back(
            m_OsAPIOverhead__apiTerminateTask);
    // m_OsAPIOverhead__apiSchedule has already been allocated above
    m_OsAPIOverhead__apiSchedule->setFeatureID(
            ::amalthea::AmaltheaPackage::OSAPIOVERHEAD__APISCHEDULE);
    m_OsAPIOverheadEClass->getEStructuralFeatures().push_back(
            m_OsAPIOverhead__apiSchedule);
    // m_OsAPIOverhead__apiRequestResource has already been allocated above
    m_OsAPIOverhead__apiRequestResource->setFeatureID(
            ::amalthea::AmaltheaPackage::OSAPIOVERHEAD__APIREQUESTRESOURCE);
    m_OsAPIOverheadEClass->getEStructuralFeatures().push_back(
            m_OsAPIOverhead__apiRequestResource);
    // m_OsAPIOverhead__apiReleaseResource has already been allocated above
    m_OsAPIOverhead__apiReleaseResource->setFeatureID(
            ::amalthea::AmaltheaPackage::OSAPIOVERHEAD__APIRELEASERESOURCE);
    m_OsAPIOverheadEClass->getEStructuralFeatures().push_back(
            m_OsAPIOverhead__apiReleaseResource);
    // m_OsAPIOverhead__apiSetEvent has already been allocated above
    m_OsAPIOverhead__apiSetEvent->setFeatureID(
            ::amalthea::AmaltheaPackage::OSAPIOVERHEAD__APISETEVENT);
    m_OsAPIOverheadEClass->getEStructuralFeatures().push_back(
            m_OsAPIOverhead__apiSetEvent);
    // m_OsAPIOverhead__apiWaitEvent has already been allocated above
    m_OsAPIOverhead__apiWaitEvent->setFeatureID(
            ::amalthea::AmaltheaPackage::OSAPIOVERHEAD__APIWAITEVENT);
    m_OsAPIOverheadEClass->getEStructuralFeatures().push_back(
            m_OsAPIOverhead__apiWaitEvent);
    // m_OsAPIOverhead__apiClearEvent has already been allocated above
    m_OsAPIOverhead__apiClearEvent->setFeatureID(
            ::amalthea::AmaltheaPackage::OSAPIOVERHEAD__APICLEAREVENT);
    m_OsAPIOverheadEClass->getEStructuralFeatures().push_back(
            m_OsAPIOverhead__apiClearEvent);
    // m_OsAPIOverhead__apiActivateTask has already been allocated above
    m_OsAPIOverhead__apiActivateTask->setFeatureID(
            ::amalthea::AmaltheaPackage::OSAPIOVERHEAD__APIACTIVATETASK);
    m_OsAPIOverheadEClass->getEStructuralFeatures().push_back(
            m_OsAPIOverhead__apiActivateTask);
    // m_OsAPIOverhead__apiEnforcedMigration has already been allocated above
    m_OsAPIOverhead__apiEnforcedMigration->setFeatureID(
            ::amalthea::AmaltheaPackage::OSAPIOVERHEAD__APIENFORCEDMIGRATION);
    m_OsAPIOverheadEClass->getEStructuralFeatures().push_back(
            m_OsAPIOverhead__apiEnforcedMigration);
    // m_OsAPIOverhead__apiSuspendOsInterrupts has already been allocated above
    m_OsAPIOverhead__apiSuspendOsInterrupts->setFeatureID(
            ::amalthea::AmaltheaPackage::OSAPIOVERHEAD__APISUSPENDOSINTERRUPTS);
    m_OsAPIOverheadEClass->getEStructuralFeatures().push_back(
            m_OsAPIOverhead__apiSuspendOsInterrupts);
    // m_OsAPIOverhead__apiResumeOsInterrupts has already been allocated above
    m_OsAPIOverhead__apiResumeOsInterrupts->setFeatureID(
            ::amalthea::AmaltheaPackage::OSAPIOVERHEAD__APIRESUMEOSINTERRUPTS);
    m_OsAPIOverheadEClass->getEStructuralFeatures().push_back(
            m_OsAPIOverhead__apiResumeOsInterrupts);
    // m_OsAPIOverhead__apiRequestSpinlock has already been allocated above
    m_OsAPIOverhead__apiRequestSpinlock->setFeatureID(
            ::amalthea::AmaltheaPackage::OSAPIOVERHEAD__APIREQUESTSPINLOCK);
    m_OsAPIOverheadEClass->getEStructuralFeatures().push_back(
            m_OsAPIOverhead__apiRequestSpinlock);
    // m_OsAPIOverhead__apiReleaseSpinlock has already been allocated above
    m_OsAPIOverhead__apiReleaseSpinlock->setFeatureID(
            ::amalthea::AmaltheaPackage::OSAPIOVERHEAD__APIRELEASESPINLOCK);
    m_OsAPIOverheadEClass->getEStructuralFeatures().push_back(
            m_OsAPIOverhead__apiReleaseSpinlock);
    // m_OsAPIOverhead__apiSenderReceiverRead has already been allocated above
    m_OsAPIOverhead__apiSenderReceiverRead->setFeatureID(
            ::amalthea::AmaltheaPackage::OSAPIOVERHEAD__APISENDERRECEIVERREAD);
    m_OsAPIOverheadEClass->getEStructuralFeatures().push_back(
            m_OsAPIOverhead__apiSenderReceiverRead);
    // m_OsAPIOverhead__apiSenderReceiverWrite has already been allocated above
    m_OsAPIOverhead__apiSenderReceiverWrite->setFeatureID(
            ::amalthea::AmaltheaPackage::OSAPIOVERHEAD__APISENDERRECEIVERWRITE);
    m_OsAPIOverheadEClass->getEStructuralFeatures().push_back(
            m_OsAPIOverhead__apiSenderReceiverWrite);
    // m_OsAPIOverhead__apiSynchronousServerCallPoint has already been allocated above
    m_OsAPIOverhead__apiSynchronousServerCallPoint->setFeatureID(
            ::amalthea::AmaltheaPackage::OSAPIOVERHEAD__APISYNCHRONOUSSERVERCALLPOINT);
    m_OsAPIOverheadEClass->getEStructuralFeatures().push_back(
            m_OsAPIOverhead__apiSynchronousServerCallPoint);
    // m_OsAPIOverhead__apiIocRead has already been allocated above
    m_OsAPIOverhead__apiIocRead->setFeatureID(
            ::amalthea::AmaltheaPackage::OSAPIOVERHEAD__APIIOCREAD);
    m_OsAPIOverheadEClass->getEStructuralFeatures().push_back(
            m_OsAPIOverhead__apiIocRead);
    // m_OsAPIOverhead__apiIocWrite has already been allocated above
    m_OsAPIOverhead__apiIocWrite->setFeatureID(
            ::amalthea::AmaltheaPackage::OSAPIOVERHEAD__APIIOCWRITE);
    m_OsAPIOverheadEClass->getEStructuralFeatures().push_back(
            m_OsAPIOverhead__apiIocWrite);

    // OsISROverhead
    {
        m_OsISROverheadEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_OsISROverheadEClass->setClassifierID(OSISROVERHEAD);
        m_OsISROverheadEClass->setEPackage(_this());
        getEClassifiers().push_back(m_OsISROverheadEClass);
    }
    // m_OsISROverhead__preExecutionOverhead has already been allocated above
    m_OsISROverhead__preExecutionOverhead->setFeatureID(
            ::amalthea::AmaltheaPackage::OSISROVERHEAD__PREEXECUTIONOVERHEAD);
    m_OsISROverheadEClass->getEStructuralFeatures().push_back(
            m_OsISROverhead__preExecutionOverhead);
    // m_OsISROverhead__postExecutionOverhead has already been allocated above
    m_OsISROverhead__postExecutionOverhead->setFeatureID(
            ::amalthea::AmaltheaPackage::OSISROVERHEAD__POSTEXECUTIONOVERHEAD);
    m_OsISROverheadEClass->getEStructuralFeatures().push_back(
            m_OsISROverhead__postExecutionOverhead);

    // PropertyConstraintsModel
    {
        m_PropertyConstraintsModelEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_PropertyConstraintsModelEClass->setClassifierID(
                PROPERTYCONSTRAINTSMODEL);
        m_PropertyConstraintsModelEClass->setEPackage(_this());
        getEClassifiers().push_back(m_PropertyConstraintsModelEClass);
    }
    // m_PropertyConstraintsModel__allocationConstraints has already been allocated above
    m_PropertyConstraintsModel__allocationConstraints->setFeatureID(
            ::amalthea::AmaltheaPackage::PROPERTYCONSTRAINTSMODEL__ALLOCATIONCONSTRAINTS);
    m_PropertyConstraintsModelEClass->getEStructuralFeatures().push_back(
            m_PropertyConstraintsModel__allocationConstraints);
    // m_PropertyConstraintsModel__mappingConstraints has already been allocated above
    m_PropertyConstraintsModel__mappingConstraints->setFeatureID(
            ::amalthea::AmaltheaPackage::PROPERTYCONSTRAINTSMODEL__MAPPINGCONSTRAINTS);
    m_PropertyConstraintsModelEClass->getEStructuralFeatures().push_back(
            m_PropertyConstraintsModel__mappingConstraints);

    // CoreAllocationConstraint
    {
        m_CoreAllocationConstraintEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_CoreAllocationConstraintEClass->setClassifierID(
                COREALLOCATIONCONSTRAINT);
        m_CoreAllocationConstraintEClass->setEPackage(_this());
        getEClassifiers().push_back(m_CoreAllocationConstraintEClass);
    }
    // m_CoreAllocationConstraint__coreClassification has already been allocated above
    m_CoreAllocationConstraint__coreClassification->setFeatureID(
            ::amalthea::AmaltheaPackage::COREALLOCATIONCONSTRAINT__CORECLASSIFICATION);
    m_CoreAllocationConstraintEClass->getEStructuralFeatures().push_back(
            m_CoreAllocationConstraint__coreClassification);

    // MemoryMappingConstraint
    {
        m_MemoryMappingConstraintEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_MemoryMappingConstraintEClass->setClassifierID(
                MEMORYMAPPINGCONSTRAINT);
        m_MemoryMappingConstraintEClass->setEPackage(_this());
        getEClassifiers().push_back(m_MemoryMappingConstraintEClass);
    }
    // m_MemoryMappingConstraint__memoryClassification has already been allocated above
    m_MemoryMappingConstraint__memoryClassification->setFeatureID(
            ::amalthea::AmaltheaPackage::MEMORYMAPPINGCONSTRAINT__MEMORYCLASSIFICATION);
    m_MemoryMappingConstraintEClass->getEStructuralFeatures().push_back(
            m_MemoryMappingConstraint__memoryClassification);

    // ProcessAllocationConstraint
    {
        m_ProcessAllocationConstraintEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_ProcessAllocationConstraintEClass->setClassifierID(
                PROCESSALLOCATIONCONSTRAINT);
        m_ProcessAllocationConstraintEClass->setEPackage(_this());
        getEClassifiers().push_back(m_ProcessAllocationConstraintEClass);
    }
    // m_ProcessAllocationConstraint__process has already been allocated above
    m_ProcessAllocationConstraint__process->setFeatureID(
            ::amalthea::AmaltheaPackage::PROCESSALLOCATIONCONSTRAINT__PROCESS);
    m_ProcessAllocationConstraintEClass->getEStructuralFeatures().push_back(
            m_ProcessAllocationConstraint__process);

    // ProcessPrototypeAllocationConstraint
    {
        m_ProcessPrototypeAllocationConstraintEClass = ::ecore::Ptr
                < ::ecore::EClass > (new ::ecore::EClass);
        m_ProcessPrototypeAllocationConstraintEClass->setClassifierID(
                PROCESSPROTOTYPEALLOCATIONCONSTRAINT);
        m_ProcessPrototypeAllocationConstraintEClass->setEPackage(_this());
        getEClassifiers().push_back(
                m_ProcessPrototypeAllocationConstraintEClass);
    }
    // m_ProcessPrototypeAllocationConstraint__processPrototype has already been allocated above
    m_ProcessPrototypeAllocationConstraint__processPrototype->setFeatureID(
            ::amalthea::AmaltheaPackage::PROCESSPROTOTYPEALLOCATIONCONSTRAINT__PROCESSPROTOTYPE);
    m_ProcessPrototypeAllocationConstraintEClass->getEStructuralFeatures().push_back(
            m_ProcessPrototypeAllocationConstraint__processPrototype);

    // RunnableAllocationConstraint
    {
        m_RunnableAllocationConstraintEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_RunnableAllocationConstraintEClass->setClassifierID(
                RUNNABLEALLOCATIONCONSTRAINT);
        m_RunnableAllocationConstraintEClass->setEPackage(_this());
        getEClassifiers().push_back(m_RunnableAllocationConstraintEClass);
    }
    // m_RunnableAllocationConstraint__runnable has already been allocated above
    m_RunnableAllocationConstraint__runnable->setFeatureID(
            ::amalthea::AmaltheaPackage::RUNNABLEALLOCATIONCONSTRAINT__RUNNABLE);
    m_RunnableAllocationConstraintEClass->getEStructuralFeatures().push_back(
            m_RunnableAllocationConstraint__runnable);

    // AbstractElementMappingConstraint
    {
        m_AbstractElementMappingConstraintEClass = ::ecore::Ptr
                < ::ecore::EClass > (new ::ecore::EClass);
        m_AbstractElementMappingConstraintEClass->setClassifierID(
                ABSTRACTELEMENTMAPPINGCONSTRAINT);
        m_AbstractElementMappingConstraintEClass->setEPackage(_this());
        getEClassifiers().push_back(m_AbstractElementMappingConstraintEClass);
    }
    // m_AbstractElementMappingConstraint__abstractElement has already been allocated above
    m_AbstractElementMappingConstraint__abstractElement->setFeatureID(
            ::amalthea::AmaltheaPackage::ABSTRACTELEMENTMAPPINGCONSTRAINT__ABSTRACTELEMENT);
    m_AbstractElementMappingConstraintEClass->getEStructuralFeatures().push_back(
            m_AbstractElementMappingConstraint__abstractElement);

    // Classification
    {
        m_ClassificationEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_ClassificationEClass->setClassifierID(CLASSIFICATION);
        m_ClassificationEClass->setEPackage(_this());
        getEClassifiers().push_back(m_ClassificationEClass);
    }
    // m_Classification__condition has already been allocated above
    m_Classification__condition->setFeatureID(
            ::amalthea::AmaltheaPackage::CLASSIFICATION__CONDITION);
    m_ClassificationEClass->getEStructuralFeatures().push_back(
            m_Classification__condition);
    // m_Classification__grouping has already been allocated above
    m_Classification__grouping->setFeatureID(
            ::amalthea::AmaltheaPackage::CLASSIFICATION__GROUPING);
    m_ClassificationEClass->getEStructuralFeatures().push_back(
            m_Classification__grouping);

    // CoreClassification
    {
        m_CoreClassificationEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_CoreClassificationEClass->setClassifierID(CORECLASSIFICATION);
        m_CoreClassificationEClass->setEPackage(_this());
        getEClassifiers().push_back(m_CoreClassificationEClass);
    }
    // m_CoreClassification__classifiers has already been allocated above
    m_CoreClassification__classifiers->setFeatureID(
            ::amalthea::AmaltheaPackage::CORECLASSIFICATION__CLASSIFIERS);
    m_CoreClassificationEClass->getEStructuralFeatures().push_back(
            m_CoreClassification__classifiers);

    // MemoryClassification
    {
        m_MemoryClassificationEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_MemoryClassificationEClass->setClassifierID(MEMORYCLASSIFICATION);
        m_MemoryClassificationEClass->setEPackage(_this());
        getEClassifiers().push_back(m_MemoryClassificationEClass);
    }
    // m_MemoryClassification__classifiers has already been allocated above
    m_MemoryClassification__classifiers->setFeatureID(
            ::amalthea::AmaltheaPackage::MEMORYCLASSIFICATION__CLASSIFIERS);
    m_MemoryClassificationEClass->getEStructuralFeatures().push_back(
            m_MemoryClassification__classifiers);

    // StimuliModel
    {
        m_StimuliModelEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_StimuliModelEClass->setClassifierID(STIMULIMODEL);
        m_StimuliModelEClass->setEPackage(_this());
        getEClassifiers().push_back(m_StimuliModelEClass);
    }
    // m_StimuliModel__stimuli has already been allocated above
    m_StimuliModel__stimuli->setFeatureID(
            ::amalthea::AmaltheaPackage::STIMULIMODEL__STIMULI);
    m_StimuliModelEClass->getEStructuralFeatures().push_back(
            m_StimuliModel__stimuli);
    // m_StimuliModel__clocks has already been allocated above
    m_StimuliModel__clocks->setFeatureID(
            ::amalthea::AmaltheaPackage::STIMULIMODEL__CLOCKS);
    m_StimuliModelEClass->getEStructuralFeatures().push_back(
            m_StimuliModel__clocks);

    // Stimulus
    {
        m_StimulusEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_StimulusEClass->setClassifierID(STIMULUS);
        m_StimulusEClass->setEPackage(_this());
        getEClassifiers().push_back(m_StimulusEClass);
    }
    // m_Stimulus__setModeValueList has already been allocated above
    m_Stimulus__setModeValueList->setFeatureID(
            ::amalthea::AmaltheaPackage::STIMULUS__SETMODEVALUELIST);
    m_StimulusEClass->getEStructuralFeatures().push_back(
            m_Stimulus__setModeValueList);
    // m_Stimulus__executionCondition has already been allocated above
    m_Stimulus__executionCondition->setFeatureID(
            ::amalthea::AmaltheaPackage::STIMULUS__EXECUTIONCONDITION);
    m_StimulusEClass->getEStructuralFeatures().push_back(
            m_Stimulus__executionCondition);
    // m_Stimulus__affectedProcesses has already been allocated above
    m_Stimulus__affectedProcesses->setFeatureID(
            ::amalthea::AmaltheaPackage::STIMULUS__AFFECTEDPROCESSES);
    m_StimulusEClass->getEStructuralFeatures().push_back(
            m_Stimulus__affectedProcesses);

    // ModeValueList
    {
        m_ModeValueListEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_ModeValueListEClass->setClassifierID(MODEVALUELIST);
        m_ModeValueListEClass->setEPackage(_this());
        getEClassifiers().push_back(m_ModeValueListEClass);
    }
    // m_ModeValueList__entries has already been allocated above
    m_ModeValueList__entries->setFeatureID(
            ::amalthea::AmaltheaPackage::MODEVALUELIST__ENTRIES);
    m_ModeValueListEClass->getEStructuralFeatures().push_back(
            m_ModeValueList__entries);

    // ModeValueMapEntry
    {
        m_ModeValueMapEntryEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_ModeValueMapEntryEClass->setClassifierID(MODEVALUEMAPENTRY);
        m_ModeValueMapEntryEClass->setEPackage(_this());
        getEClassifiers().push_back(m_ModeValueMapEntryEClass);
    }
    // m_ModeValueMapEntry__value has already been allocated above
    m_ModeValueMapEntry__value->setFeatureID(
            ::amalthea::AmaltheaPackage::MODEVALUEMAPENTRY__VALUE);
    m_ModeValueMapEntryEClass->getEStructuralFeatures().push_back(
            m_ModeValueMapEntry__value);
    // m_ModeValueMapEntry__key has already been allocated above
    m_ModeValueMapEntry__key->setFeatureID(
            ::amalthea::AmaltheaPackage::MODEVALUEMAPENTRY__KEY);
    m_ModeValueMapEntryEClass->getEStructuralFeatures().push_back(
            m_ModeValueMapEntry__key);

    // ModeValue
    {
        m_ModeValueEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_ModeValueEClass->setClassifierID(MODEVALUE);
        m_ModeValueEClass->setEPackage(_this());
        getEClassifiers().push_back(m_ModeValueEClass);
    }
    // m_ModeValue__value has already been allocated above
    m_ModeValue__value->setFeatureID(
            ::amalthea::AmaltheaPackage::MODEVALUE__VALUE);
    m_ModeValueEClass->getEStructuralFeatures().push_back(m_ModeValue__value);
    // m_ModeValue__label has already been allocated above
    m_ModeValue__label->setFeatureID(
            ::amalthea::AmaltheaPackage::MODEVALUE__LABEL);
    m_ModeValueEClass->getEStructuralFeatures().push_back(m_ModeValue__label);

    // ModeAssignment
    {
        m_ModeAssignmentEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_ModeAssignmentEClass->setClassifierID(MODEASSIGNMENT);
        m_ModeAssignmentEClass->setEPackage(_this());
        getEClassifiers().push_back(m_ModeAssignmentEClass);
    }

    // ModeConditionDisjunction
    {
        m_ModeConditionDisjunctionEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_ModeConditionDisjunctionEClass->setClassifierID(
                MODECONDITIONDISJUNCTION);
        m_ModeConditionDisjunctionEClass->setEPackage(_this());
        getEClassifiers().push_back(m_ModeConditionDisjunctionEClass);
    }
    // m_ModeConditionDisjunction__entries has already been allocated above
    m_ModeConditionDisjunction__entries->setFeatureID(
            ::amalthea::AmaltheaPackage::MODECONDITIONDISJUNCTION__ENTRIES);
    m_ModeConditionDisjunctionEClass->getEStructuralFeatures().push_back(
            m_ModeConditionDisjunction__entries);

    // ModeConditionDisjunctionEntry
    {
        m_ModeConditionDisjunctionEntryEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_ModeConditionDisjunctionEntryEClass->setClassifierID(
                MODECONDITIONDISJUNCTIONENTRY);
        m_ModeConditionDisjunctionEntryEClass->setEPackage(_this());
        getEClassifiers().push_back(m_ModeConditionDisjunctionEntryEClass);
    }

    // ModeCondition
    {
        m_ModeConditionEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_ModeConditionEClass->setClassifierID(MODECONDITION);
        m_ModeConditionEClass->setEPackage(_this());
        getEClassifiers().push_back(m_ModeConditionEClass);
    }
    // m_ModeCondition__relation has already been allocated above
    m_ModeCondition__relation->setFeatureID(
            ::amalthea::AmaltheaPackage::MODECONDITION__RELATION);
    m_ModeConditionEClass->getEStructuralFeatures().push_back(
            m_ModeCondition__relation);

    // ModeValueCondition
    {
        m_ModeValueConditionEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_ModeValueConditionEClass->setClassifierID(MODEVALUECONDITION);
        m_ModeValueConditionEClass->setEPackage(_this());
        getEClassifiers().push_back(m_ModeValueConditionEClass);
    }

    // ModeLabelCondition
    {
        m_ModeLabelConditionEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_ModeLabelConditionEClass->setClassifierID(MODELABELCONDITION);
        m_ModeLabelConditionEClass->setEPackage(_this());
        getEClassifiers().push_back(m_ModeLabelConditionEClass);
    }
    // m_ModeLabelCondition__label1 has already been allocated above
    m_ModeLabelCondition__label1->setFeatureID(
            ::amalthea::AmaltheaPackage::MODELABELCONDITION__LABEL1);
    m_ModeLabelConditionEClass->getEStructuralFeatures().push_back(
            m_ModeLabelCondition__label1);
    // m_ModeLabelCondition__label2 has already been allocated above
    m_ModeLabelCondition__label2->setFeatureID(
            ::amalthea::AmaltheaPackage::MODELABELCONDITION__LABEL2);
    m_ModeLabelConditionEClass->getEStructuralFeatures().push_back(
            m_ModeLabelCondition__label2);

    // ModeConditionConjunction
    {
        m_ModeConditionConjunctionEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_ModeConditionConjunctionEClass->setClassifierID(
                MODECONDITIONCONJUNCTION);
        m_ModeConditionConjunctionEClass->setEPackage(_this());
        getEClassifiers().push_back(m_ModeConditionConjunctionEClass);
    }
    // m_ModeConditionConjunction__entries has already been allocated above
    m_ModeConditionConjunction__entries->setFeatureID(
            ::amalthea::AmaltheaPackage::MODECONDITIONCONJUNCTION__ENTRIES);
    m_ModeConditionConjunctionEClass->getEStructuralFeatures().push_back(
            m_ModeConditionConjunction__entries);

    // FixedPeriodic
    {
        m_FixedPeriodicEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_FixedPeriodicEClass->setClassifierID(FIXEDPERIODIC);
        m_FixedPeriodicEClass->setEPackage(_this());
        getEClassifiers().push_back(m_FixedPeriodicEClass);
    }
    // m_FixedPeriodic__recurrence has already been allocated above
    m_FixedPeriodic__recurrence->setFeatureID(
            ::amalthea::AmaltheaPackage::FIXEDPERIODIC__RECURRENCE);
    m_FixedPeriodicEClass->getEStructuralFeatures().push_back(
            m_FixedPeriodic__recurrence);
    // m_FixedPeriodic__offset has already been allocated above
    m_FixedPeriodic__offset->setFeatureID(
            ::amalthea::AmaltheaPackage::FIXEDPERIODIC__OFFSET);
    m_FixedPeriodicEClass->getEStructuralFeatures().push_back(
            m_FixedPeriodic__offset);

    // PeriodicStimulus
    {
        m_PeriodicStimulusEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_PeriodicStimulusEClass->setClassifierID(PERIODICSTIMULUS);
        m_PeriodicStimulusEClass->setEPackage(_this());
        getEClassifiers().push_back(m_PeriodicStimulusEClass);
    }
    // m_PeriodicStimulus__jitter has already been allocated above
    m_PeriodicStimulus__jitter->setFeatureID(
            ::amalthea::AmaltheaPackage::PERIODICSTIMULUS__JITTER);
    m_PeriodicStimulusEClass->getEStructuralFeatures().push_back(
            m_PeriodicStimulus__jitter);
    // m_PeriodicStimulus__minDistance has already been allocated above
    m_PeriodicStimulus__minDistance->setFeatureID(
            ::amalthea::AmaltheaPackage::PERIODICSTIMULUS__MINDISTANCE);
    m_PeriodicStimulusEClass->getEStructuralFeatures().push_back(
            m_PeriodicStimulus__minDistance);

    // RelativePeriodicStimulus
    {
        m_RelativePeriodicStimulusEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_RelativePeriodicStimulusEClass->setClassifierID(
                RELATIVEPERIODICSTIMULUS);
        m_RelativePeriodicStimulusEClass->setEPackage(_this());
        getEClassifiers().push_back(m_RelativePeriodicStimulusEClass);
    }
    // m_RelativePeriodicStimulus__offset has already been allocated above
    m_RelativePeriodicStimulus__offset->setFeatureID(
            ::amalthea::AmaltheaPackage::RELATIVEPERIODICSTIMULUS__OFFSET);
    m_RelativePeriodicStimulusEClass->getEStructuralFeatures().push_back(
            m_RelativePeriodicStimulus__offset);
    // m_RelativePeriodicStimulus__nextOccurrence has already been allocated above
    m_RelativePeriodicStimulus__nextOccurrence->setFeatureID(
            ::amalthea::AmaltheaPackage::RELATIVEPERIODICSTIMULUS__NEXTOCCURRENCE);
    m_RelativePeriodicStimulusEClass->getEStructuralFeatures().push_back(
            m_RelativePeriodicStimulus__nextOccurrence);

    // VariableRateStimulus
    {
        m_VariableRateStimulusEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_VariableRateStimulusEClass->setClassifierID(VARIABLERATESTIMULUS);
        m_VariableRateStimulusEClass->setEPackage(_this());
        getEClassifiers().push_back(m_VariableRateStimulusEClass);
    }
    // m_VariableRateStimulus__maxIncreasePerStep has already been allocated above
    m_VariableRateStimulus__maxIncreasePerStep->setFeatureID(
            ::amalthea::AmaltheaPackage::VARIABLERATESTIMULUS__MAXINCREASEPERSTEP);
    m_VariableRateStimulusEClass->getEStructuralFeatures().push_back(
            m_VariableRateStimulus__maxIncreasePerStep);
    // m_VariableRateStimulus__maxDecreasePerStep has already been allocated above
    m_VariableRateStimulus__maxDecreasePerStep->setFeatureID(
            ::amalthea::AmaltheaPackage::VARIABLERATESTIMULUS__MAXDECREASEPERSTEP);
    m_VariableRateStimulusEClass->getEStructuralFeatures().push_back(
            m_VariableRateStimulus__maxDecreasePerStep);
    // m_VariableRateStimulus__step has already been allocated above
    m_VariableRateStimulus__step->setFeatureID(
            ::amalthea::AmaltheaPackage::VARIABLERATESTIMULUS__STEP);
    m_VariableRateStimulusEClass->getEStructuralFeatures().push_back(
            m_VariableRateStimulus__step);
    // m_VariableRateStimulus__occurrencesPerStep has already been allocated above
    m_VariableRateStimulus__occurrencesPerStep->setFeatureID(
            ::amalthea::AmaltheaPackage::VARIABLERATESTIMULUS__OCCURRENCESPERSTEP);
    m_VariableRateStimulusEClass->getEStructuralFeatures().push_back(
            m_VariableRateStimulus__occurrencesPerStep);
    // m_VariableRateStimulus__scenario has already been allocated above
    m_VariableRateStimulus__scenario->setFeatureID(
            ::amalthea::AmaltheaPackage::VARIABLERATESTIMULUS__SCENARIO);
    m_VariableRateStimulusEClass->getEStructuralFeatures().push_back(
            m_VariableRateStimulus__scenario);

    // Scenario
    {
        m_ScenarioEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_ScenarioEClass->setClassifierID(SCENARIO);
        m_ScenarioEClass->setEPackage(_this());
        getEClassifiers().push_back(m_ScenarioEClass);
    }
    // m_Scenario__samplingOffset has already been allocated above
    m_Scenario__samplingOffset->setFeatureID(
            ::amalthea::AmaltheaPackage::SCENARIO__SAMPLINGOFFSET);
    m_ScenarioEClass->getEStructuralFeatures().push_back(
            m_Scenario__samplingOffset);
    // m_Scenario__samplingRecurrence has already been allocated above
    m_Scenario__samplingRecurrence->setFeatureID(
            ::amalthea::AmaltheaPackage::SCENARIO__SAMPLINGRECURRENCE);
    m_ScenarioEClass->getEStructuralFeatures().push_back(
            m_Scenario__samplingRecurrence);
    // m_Scenario__clock has already been allocated above
    m_Scenario__clock->setFeatureID(
            ::amalthea::AmaltheaPackage::SCENARIO__CLOCK);
    m_ScenarioEClass->getEStructuralFeatures().push_back(m_Scenario__clock);

    // PeriodicSyntheticStimulus
    {
        m_PeriodicSyntheticStimulusEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_PeriodicSyntheticStimulusEClass->setClassifierID(
                PERIODICSYNTHETICSTIMULUS);
        m_PeriodicSyntheticStimulusEClass->setEPackage(_this());
        getEClassifiers().push_back(m_PeriodicSyntheticStimulusEClass);
    }
    // m_PeriodicSyntheticStimulus__occurrenceTimes has already been allocated above
    m_PeriodicSyntheticStimulus__occurrenceTimes->setFeatureID(
            ::amalthea::AmaltheaPackage::PERIODICSYNTHETICSTIMULUS__OCCURRENCETIMES);
    m_PeriodicSyntheticStimulusEClass->getEStructuralFeatures().push_back(
            m_PeriodicSyntheticStimulus__occurrenceTimes);

    // CustomStimulus
    {
        m_CustomStimulusEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_CustomStimulusEClass->setClassifierID(CUSTOMSTIMULUS);
        m_CustomStimulusEClass->setEPackage(_this());
        getEClassifiers().push_back(m_CustomStimulusEClass);
    }

    // SingleStimulus
    {
        m_SingleStimulusEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_SingleStimulusEClass->setClassifierID(SINGLESTIMULUS);
        m_SingleStimulusEClass->setEPackage(_this());
        getEClassifiers().push_back(m_SingleStimulusEClass);
    }
    // m_SingleStimulus__occurrence has already been allocated above
    m_SingleStimulus__occurrence->setFeatureID(
            ::amalthea::AmaltheaPackage::SINGLESTIMULUS__OCCURRENCE);
    m_SingleStimulusEClass->getEStructuralFeatures().push_back(
            m_SingleStimulus__occurrence);

    // InterProcessStimulus
    {
        m_InterProcessStimulusEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_InterProcessStimulusEClass->setClassifierID(INTERPROCESSSTIMULUS);
        m_InterProcessStimulusEClass->setEPackage(_this());
        getEClassifiers().push_back(m_InterProcessStimulusEClass);
    }
    // m_InterProcessStimulus__counter has already been allocated above
    m_InterProcessStimulus__counter->setFeatureID(
            ::amalthea::AmaltheaPackage::INTERPROCESSSTIMULUS__COUNTER);
    m_InterProcessStimulusEClass->getEStructuralFeatures().push_back(
            m_InterProcessStimulus__counter);
    // m_InterProcessStimulus__explicitTriggers has already been allocated above
    m_InterProcessStimulus__explicitTriggers->setFeatureID(
            ::amalthea::AmaltheaPackage::INTERPROCESSSTIMULUS__EXPLICITTRIGGERS);
    m_InterProcessStimulusEClass->getEStructuralFeatures().push_back(
            m_InterProcessStimulus__explicitTriggers);

    // PeriodicBurstStimulus
    {
        m_PeriodicBurstStimulusEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_PeriodicBurstStimulusEClass->setClassifierID(PERIODICBURSTSTIMULUS);
        m_PeriodicBurstStimulusEClass->setEPackage(_this());
        getEClassifiers().push_back(m_PeriodicBurstStimulusEClass);
    }
    // m_PeriodicBurstStimulus__occurrenceCount has already been allocated above
    m_PeriodicBurstStimulus__occurrenceCount->setFeatureID(
            ::amalthea::AmaltheaPackage::PERIODICBURSTSTIMULUS__OCCURRENCECOUNT);
    m_PeriodicBurstStimulusEClass->getEStructuralFeatures().push_back(
            m_PeriodicBurstStimulus__occurrenceCount);
    // m_PeriodicBurstStimulus__burstLength has already been allocated above
    m_PeriodicBurstStimulus__burstLength->setFeatureID(
            ::amalthea::AmaltheaPackage::PERIODICBURSTSTIMULUS__BURSTLENGTH);
    m_PeriodicBurstStimulusEClass->getEStructuralFeatures().push_back(
            m_PeriodicBurstStimulus__burstLength);
    // m_PeriodicBurstStimulus__occurrenceMinDistance has already been allocated above
    m_PeriodicBurstStimulus__occurrenceMinDistance->setFeatureID(
            ::amalthea::AmaltheaPackage::PERIODICBURSTSTIMULUS__OCCURRENCEMINDISTANCE);
    m_PeriodicBurstStimulusEClass->getEStructuralFeatures().push_back(
            m_PeriodicBurstStimulus__occurrenceMinDistance);

    // EventStimulus
    {
        m_EventStimulusEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_EventStimulusEClass->setClassifierID(EVENTSTIMULUS);
        m_EventStimulusEClass->setEPackage(_this());
        getEClassifiers().push_back(m_EventStimulusEClass);
    }
    // m_EventStimulus__triggeringEvents has already been allocated above
    m_EventStimulus__triggeringEvents->setFeatureID(
            ::amalthea::AmaltheaPackage::EVENTSTIMULUS__TRIGGERINGEVENTS);
    m_EventStimulusEClass->getEStructuralFeatures().push_back(
            m_EventStimulus__triggeringEvents);
    // m_EventStimulus__counter has already been allocated above
    m_EventStimulus__counter->setFeatureID(
            ::amalthea::AmaltheaPackage::EVENTSTIMULUS__COUNTER);
    m_EventStimulusEClass->getEStructuralFeatures().push_back(
            m_EventStimulus__counter);

    // ArrivalCurveStimulus
    {
        m_ArrivalCurveStimulusEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_ArrivalCurveStimulusEClass->setClassifierID(ARRIVALCURVESTIMULUS);
        m_ArrivalCurveStimulusEClass->setEPackage(_this());
        getEClassifiers().push_back(m_ArrivalCurveStimulusEClass);
    }
    // m_ArrivalCurveStimulus__entries has already been allocated above
    m_ArrivalCurveStimulus__entries->setFeatureID(
            ::amalthea::AmaltheaPackage::ARRIVALCURVESTIMULUS__ENTRIES);
    m_ArrivalCurveStimulusEClass->getEStructuralFeatures().push_back(
            m_ArrivalCurveStimulus__entries);

    // ArrivalCurveEntry
    {
        m_ArrivalCurveEntryEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_ArrivalCurveEntryEClass->setClassifierID(ARRIVALCURVEENTRY);
        m_ArrivalCurveEntryEClass->setEPackage(_this());
        getEClassifiers().push_back(m_ArrivalCurveEntryEClass);
    }
    // m_ArrivalCurveEntry__numberOfOccurrences has already been allocated above
    m_ArrivalCurveEntry__numberOfOccurrences->setFeatureID(
            ::amalthea::AmaltheaPackage::ARRIVALCURVEENTRY__NUMBEROFOCCURRENCES);
    m_ArrivalCurveEntryEClass->getEStructuralFeatures().push_back(
            m_ArrivalCurveEntry__numberOfOccurrences);
    // m_ArrivalCurveEntry__lowerTimeBorder has already been allocated above
    m_ArrivalCurveEntry__lowerTimeBorder->setFeatureID(
            ::amalthea::AmaltheaPackage::ARRIVALCURVEENTRY__LOWERTIMEBORDER);
    m_ArrivalCurveEntryEClass->getEStructuralFeatures().push_back(
            m_ArrivalCurveEntry__lowerTimeBorder);
    // m_ArrivalCurveEntry__upperTimeBorder has already been allocated above
    m_ArrivalCurveEntry__upperTimeBorder->setFeatureID(
            ::amalthea::AmaltheaPackage::ARRIVALCURVEENTRY__UPPERTIMEBORDER);
    m_ArrivalCurveEntryEClass->getEStructuralFeatures().push_back(
            m_ArrivalCurveEntry__upperTimeBorder);

    // Clock
    {
        m_ClockEClass = ::ecore::Ptr < ::ecore::EClass > (new ::ecore::EClass);
        m_ClockEClass->setClassifierID(CLOCK);
        m_ClockEClass->setEPackage(_this());
        getEClassifiers().push_back(m_ClockEClass);
    }

    // ClockFunction
    {
        m_ClockFunctionEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_ClockFunctionEClass->setClassifierID(CLOCKFUNCTION);
        m_ClockFunctionEClass->setEPackage(_this());
        getEClassifiers().push_back(m_ClockFunctionEClass);
    }
    // m_ClockFunction__curveType has already been allocated above
    m_ClockFunction__curveType->setFeatureID(
            ::amalthea::AmaltheaPackage::CLOCKFUNCTION__CURVETYPE);
    m_ClockFunctionEClass->getEStructuralFeatures().push_back(
            m_ClockFunction__curveType);
    // m_ClockFunction__period has already been allocated above
    m_ClockFunction__period->setFeatureID(
            ::amalthea::AmaltheaPackage::CLOCKFUNCTION__PERIOD);
    m_ClockFunctionEClass->getEStructuralFeatures().push_back(
            m_ClockFunction__period);
    // m_ClockFunction__peakToPeak has already been allocated above
    m_ClockFunction__peakToPeak->setFeatureID(
            ::amalthea::AmaltheaPackage::CLOCKFUNCTION__PEAKTOPEAK);
    m_ClockFunctionEClass->getEStructuralFeatures().push_back(
            m_ClockFunction__peakToPeak);
    // m_ClockFunction__xOffset has already been allocated above
    m_ClockFunction__xOffset->setFeatureID(
            ::amalthea::AmaltheaPackage::CLOCKFUNCTION__XOFFSET);
    m_ClockFunctionEClass->getEStructuralFeatures().push_back(
            m_ClockFunction__xOffset);
    // m_ClockFunction__yOffset has already been allocated above
    m_ClockFunction__yOffset->setFeatureID(
            ::amalthea::AmaltheaPackage::CLOCKFUNCTION__YOFFSET);
    m_ClockFunctionEClass->getEStructuralFeatures().push_back(
            m_ClockFunction__yOffset);

    // ClockStepList
    {
        m_ClockStepListEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_ClockStepListEClass->setClassifierID(CLOCKSTEPLIST);
        m_ClockStepListEClass->setEPackage(_this());
        getEClassifiers().push_back(m_ClockStepListEClass);
    }
    // m_ClockStepList__entries has already been allocated above
    m_ClockStepList__entries->setFeatureID(
            ::amalthea::AmaltheaPackage::CLOCKSTEPLIST__ENTRIES);
    m_ClockStepListEClass->getEStructuralFeatures().push_back(
            m_ClockStepList__entries);
    // m_ClockStepList__period has already been allocated above
    m_ClockStepList__period->setFeatureID(
            ::amalthea::AmaltheaPackage::CLOCKSTEPLIST__PERIOD);
    m_ClockStepListEClass->getEStructuralFeatures().push_back(
            m_ClockStepList__period);

    // ClockStep
    {
        m_ClockStepEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_ClockStepEClass->setClassifierID(CLOCKSTEP);
        m_ClockStepEClass->setEPackage(_this());
        getEClassifiers().push_back(m_ClockStepEClass);
    }
    // m_ClockStep__frequency has already been allocated above
    m_ClockStep__frequency->setFeatureID(
            ::amalthea::AmaltheaPackage::CLOCKSTEP__FREQUENCY);
    m_ClockStepEClass->getEStructuralFeatures().push_back(
            m_ClockStep__frequency);
    // m_ClockStep__time has already been allocated above
    m_ClockStep__time->setFeatureID(
            ::amalthea::AmaltheaPackage::CLOCKSTEP__TIME);
    m_ClockStepEClass->getEStructuralFeatures().push_back(m_ClockStep__time);

    // SWModel
    {
        m_SWModelEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_SWModelEClass->setClassifierID(SWMODEL);
        m_SWModelEClass->setEPackage(_this());
        getEClassifiers().push_back(m_SWModelEClass);
    }
    // m_SWModel__isrs has already been allocated above
    m_SWModel__isrs->setFeatureID(::amalthea::AmaltheaPackage::SWMODEL__ISRS);
    m_SWModelEClass->getEStructuralFeatures().push_back(m_SWModel__isrs);
    // m_SWModel__tasks has already been allocated above
    m_SWModel__tasks->setFeatureID(::amalthea::AmaltheaPackage::SWMODEL__TASKS);
    m_SWModelEClass->getEStructuralFeatures().push_back(m_SWModel__tasks);
    // m_SWModel__runnables has already been allocated above
    m_SWModel__runnables->setFeatureID(
            ::amalthea::AmaltheaPackage::SWMODEL__RUNNABLES);
    m_SWModelEClass->getEStructuralFeatures().push_back(m_SWModel__runnables);
    // m_SWModel__labels has already been allocated above
    m_SWModel__labels->setFeatureID(
            ::amalthea::AmaltheaPackage::SWMODEL__LABELS);
    m_SWModelEClass->getEStructuralFeatures().push_back(m_SWModel__labels);
    // m_SWModel__channels has already been allocated above
    m_SWModel__channels->setFeatureID(
            ::amalthea::AmaltheaPackage::SWMODEL__CHANNELS);
    m_SWModelEClass->getEStructuralFeatures().push_back(m_SWModel__channels);
    // m_SWModel__processPrototypes has already been allocated above
    m_SWModel__processPrototypes->setFeatureID(
            ::amalthea::AmaltheaPackage::SWMODEL__PROCESSPROTOTYPES);
    m_SWModelEClass->getEStructuralFeatures().push_back(
            m_SWModel__processPrototypes);
    // m_SWModel__sections has already been allocated above
    m_SWModel__sections->setFeatureID(
            ::amalthea::AmaltheaPackage::SWMODEL__SECTIONS);
    m_SWModelEClass->getEStructuralFeatures().push_back(m_SWModel__sections);
    // m_SWModel__activations has already been allocated above
    m_SWModel__activations->setFeatureID(
            ::amalthea::AmaltheaPackage::SWMODEL__ACTIVATIONS);
    m_SWModelEClass->getEStructuralFeatures().push_back(m_SWModel__activations);
    // m_SWModel__events has already been allocated above
    m_SWModel__events->setFeatureID(
            ::amalthea::AmaltheaPackage::SWMODEL__EVENTS);
    m_SWModelEClass->getEStructuralFeatures().push_back(m_SWModel__events);
    // m_SWModel__typeDefinitions has already been allocated above
    m_SWModel__typeDefinitions->setFeatureID(
            ::amalthea::AmaltheaPackage::SWMODEL__TYPEDEFINITIONS);
    m_SWModelEClass->getEStructuralFeatures().push_back(
            m_SWModel__typeDefinitions);
    // m_SWModel__customEntities has already been allocated above
    m_SWModel__customEntities->setFeatureID(
            ::amalthea::AmaltheaPackage::SWMODEL__CUSTOMENTITIES);
    m_SWModelEClass->getEStructuralFeatures().push_back(
            m_SWModel__customEntities);
    // m_SWModel__processChains has already been allocated above
    m_SWModel__processChains->setFeatureID(
            ::amalthea::AmaltheaPackage::SWMODEL__PROCESSCHAINS);
    m_SWModelEClass->getEStructuralFeatures().push_back(
            m_SWModel__processChains);
    // m_SWModel__modes has already been allocated above
    m_SWModel__modes->setFeatureID(::amalthea::AmaltheaPackage::SWMODEL__MODES);
    m_SWModelEClass->getEStructuralFeatures().push_back(m_SWModel__modes);
    // m_SWModel__modeLabels has already been allocated above
    m_SWModel__modeLabels->setFeatureID(
            ::amalthea::AmaltheaPackage::SWMODEL__MODELABELS);
    m_SWModelEClass->getEStructuralFeatures().push_back(m_SWModel__modeLabels);

    // AbstractMemoryElement
    {
        m_AbstractMemoryElementEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_AbstractMemoryElementEClass->setClassifierID(ABSTRACTMEMORYELEMENT);
        m_AbstractMemoryElementEClass->setEPackage(_this());
        getEClassifiers().push_back(m_AbstractMemoryElementEClass);
    }
    // m_AbstractMemoryElement__size has already been allocated above
    m_AbstractMemoryElement__size->setFeatureID(
            ::amalthea::AmaltheaPackage::ABSTRACTMEMORYELEMENT__SIZE);
    m_AbstractMemoryElementEClass->getEStructuralFeatures().push_back(
            m_AbstractMemoryElement__size);
    // m_AbstractMemoryElement__mappings has already been allocated above
    m_AbstractMemoryElement__mappings->setFeatureID(
            ::amalthea::AmaltheaPackage::ABSTRACTMEMORYELEMENT__MAPPINGS);
    m_AbstractMemoryElementEClass->getEStructuralFeatures().push_back(
            m_AbstractMemoryElement__mappings);

    // AbstractProcess
    {
        m_AbstractProcessEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_AbstractProcessEClass->setClassifierID(ABSTRACTPROCESS);
        m_AbstractProcessEClass->setEPackage(_this());
        getEClassifiers().push_back(m_AbstractProcessEClass);
    }
    // m_AbstractProcess__referringComponents has already been allocated above
    m_AbstractProcess__referringComponents->setFeatureID(
            ::amalthea::AmaltheaPackage::ABSTRACTPROCESS__REFERRINGCOMPONENTS);
    m_AbstractProcessEClass->getEStructuralFeatures().push_back(
            m_AbstractProcess__referringComponents);

    // CustomEntity
    {
        m_CustomEntityEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_CustomEntityEClass->setClassifierID(CUSTOMENTITY);
        m_CustomEntityEClass->setEPackage(_this());
        getEClassifiers().push_back(m_CustomEntityEClass);
    }
    // m_CustomEntity__typeName has already been allocated above
    m_CustomEntity__typeName->setFeatureID(
            ::amalthea::AmaltheaPackage::CUSTOMENTITY__TYPENAME);
    m_CustomEntityEClass->getEStructuralFeatures().push_back(
            m_CustomEntity__typeName);

    // ProcessChain
    {
        m_ProcessChainEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_ProcessChainEClass->setClassifierID(PROCESSCHAIN);
        m_ProcessChainEClass->setEPackage(_this());
        getEClassifiers().push_back(m_ProcessChainEClass);
    }
    // m_ProcessChain__processes has already been allocated above
    m_ProcessChain__processes->setFeatureID(
            ::amalthea::AmaltheaPackage::PROCESSCHAIN__PROCESSES);
    m_ProcessChainEClass->getEStructuralFeatures().push_back(
            m_ProcessChain__processes);

    // Process
    {
        m_ProcessEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_ProcessEClass->setClassifierID(PROCESS);
        m_ProcessEClass->setEPackage(_this());
        getEClassifiers().push_back(m_ProcessEClass);
    }
    // m_Process__activityGraph has already been allocated above
    m_Process__activityGraph->setFeatureID(
            ::amalthea::AmaltheaPackage::PROCESS__ACTIVITYGRAPH);
    m_ProcessEClass->getEStructuralFeatures().push_back(
            m_Process__activityGraph);
    // m_Process__stimuli has already been allocated above
    m_Process__stimuli->setFeatureID(
            ::amalthea::AmaltheaPackage::PROCESS__STIMULI);
    m_ProcessEClass->getEStructuralFeatures().push_back(m_Process__stimuli);

    // IActivityGraphItemContainer
    {
        m_IActivityGraphItemContainerEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_IActivityGraphItemContainerEClass->setClassifierID(
                IACTIVITYGRAPHITEMCONTAINER);
        m_IActivityGraphItemContainerEClass->setEPackage(_this());
        getEClassifiers().push_back(m_IActivityGraphItemContainerEClass);
    }
    // m_IActivityGraphItemContainer__items has already been allocated above
    m_IActivityGraphItemContainer__items->setFeatureID(
            ::amalthea::AmaltheaPackage::IACTIVITYGRAPHITEMCONTAINER__ITEMS);
    m_IActivityGraphItemContainerEClass->getEStructuralFeatures().push_back(
            m_IActivityGraphItemContainer__items);

    // ActivityGraph
    {
        m_ActivityGraphEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_ActivityGraphEClass->setClassifierID(ACTIVITYGRAPH);
        m_ActivityGraphEClass->setEPackage(_this());
        getEClassifiers().push_back(m_ActivityGraphEClass);
    }

    // ActivityGraphItem
    {
        m_ActivityGraphItemEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_ActivityGraphItemEClass->setClassifierID(ACTIVITYGRAPHITEM);
        m_ActivityGraphItemEClass->setEPackage(_this());
        getEClassifiers().push_back(m_ActivityGraphItemEClass);
    }
    // m_ActivityGraphItem__containingProcess has already been allocated above
    m_ActivityGraphItem__containingProcess->setFeatureID(
            ::amalthea::AmaltheaPackage::ACTIVITYGRAPHITEM__CONTAININGPROCESS);
    m_ActivityGraphItemEClass->getEStructuralFeatures().push_back(
            m_ActivityGraphItem__containingProcess);
    // m_ActivityGraphItem__containingRunnable has already been allocated above
    m_ActivityGraphItem__containingRunnable->setFeatureID(
            ::amalthea::AmaltheaPackage::ACTIVITYGRAPHITEM__CONTAININGRUNNABLE);
    m_ActivityGraphItemEClass->getEStructuralFeatures().push_back(
            m_ActivityGraphItem__containingRunnable);
    // m_ActivityGraphItem__containingActivityGraph has already been allocated above
    m_ActivityGraphItem__containingActivityGraph->setFeatureID(
            ::amalthea::AmaltheaPackage::ACTIVITYGRAPHITEM__CONTAININGACTIVITYGRAPH);
    m_ActivityGraphItemEClass->getEStructuralFeatures().push_back(
            m_ActivityGraphItem__containingActivityGraph);

    // ModeSwitch
    {
        m_ModeSwitchEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_ModeSwitchEClass->setClassifierID(MODESWITCH);
        m_ModeSwitchEClass->setEPackage(_this());
        getEClassifiers().push_back(m_ModeSwitchEClass);
    }
    // m_ModeSwitch__entries has already been allocated above
    m_ModeSwitch__entries->setFeatureID(
            ::amalthea::AmaltheaPackage::MODESWITCH__ENTRIES);
    m_ModeSwitchEClass->getEStructuralFeatures().push_back(
            m_ModeSwitch__entries);
    // m_ModeSwitch__defaultEntry has already been allocated above
    m_ModeSwitch__defaultEntry->setFeatureID(
            ::amalthea::AmaltheaPackage::MODESWITCH__DEFAULTENTRY);
    m_ModeSwitchEClass->getEStructuralFeatures().push_back(
            m_ModeSwitch__defaultEntry);

    // ModeSwitchEntry
    {
        m_ModeSwitchEntryEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_ModeSwitchEntryEClass->setClassifierID(MODESWITCHENTRY);
        m_ModeSwitchEntryEClass->setEPackage(_this());
        getEClassifiers().push_back(m_ModeSwitchEntryEClass);
    }
    // m_ModeSwitchEntry__condition has already been allocated above
    m_ModeSwitchEntry__condition->setFeatureID(
            ::amalthea::AmaltheaPackage::MODESWITCHENTRY__CONDITION);
    m_ModeSwitchEntryEClass->getEStructuralFeatures().push_back(
            m_ModeSwitchEntry__condition);

    // ModeSwitchDefault
    {
        m_ModeSwitchDefaultEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_ModeSwitchDefaultEClass->setClassifierID(MODESWITCHDEFAULT);
        m_ModeSwitchDefaultEClass->setEPackage(_this());
        getEClassifiers().push_back(m_ModeSwitchDefaultEClass);
    }

    // ProbabilitySwitch
    {
        m_ProbabilitySwitchEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_ProbabilitySwitchEClass->setClassifierID(PROBABILITYSWITCH);
        m_ProbabilitySwitchEClass->setEPackage(_this());
        getEClassifiers().push_back(m_ProbabilitySwitchEClass);
    }
    // m_ProbabilitySwitch__entries has already been allocated above
    m_ProbabilitySwitch__entries->setFeatureID(
            ::amalthea::AmaltheaPackage::PROBABILITYSWITCH__ENTRIES);
    m_ProbabilitySwitchEClass->getEStructuralFeatures().push_back(
            m_ProbabilitySwitch__entries);

    // ProbabilitySwitchEntry
    {
        m_ProbabilitySwitchEntryEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_ProbabilitySwitchEntryEClass->setClassifierID(PROBABILITYSWITCHENTRY);
        m_ProbabilitySwitchEntryEClass->setEPackage(_this());
        getEClassifiers().push_back(m_ProbabilitySwitchEntryEClass);
    }
    // m_ProbabilitySwitchEntry__probability has already been allocated above
    m_ProbabilitySwitchEntry__probability->setFeatureID(
            ::amalthea::AmaltheaPackage::PROBABILITYSWITCHENTRY__PROBABILITY);
    m_ProbabilitySwitchEntryEClass->getEStructuralFeatures().push_back(
            m_ProbabilitySwitchEntry__probability);

    // Counter
    {
        m_CounterEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_CounterEClass->setClassifierID(COUNTER);
        m_CounterEClass->setEPackage(_this());
        getEClassifiers().push_back(m_CounterEClass);
    }
    // m_Counter__prescaler has already been allocated above
    m_Counter__prescaler->setFeatureID(
            ::amalthea::AmaltheaPackage::COUNTER__PRESCALER);
    m_CounterEClass->getEStructuralFeatures().push_back(m_Counter__prescaler);
    // m_Counter__offset has already been allocated above
    m_Counter__offset->setFeatureID(
            ::amalthea::AmaltheaPackage::COUNTER__OFFSET);
    m_CounterEClass->getEStructuralFeatures().push_back(m_Counter__offset);

    // WaitEvent
    {
        m_WaitEventEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_WaitEventEClass->setClassifierID(WAITEVENT);
        m_WaitEventEClass->setEPackage(_this());
        getEClassifiers().push_back(m_WaitEventEClass);
    }
    // m_WaitEvent__maskType has already been allocated above
    m_WaitEvent__maskType->setFeatureID(
            ::amalthea::AmaltheaPackage::WAITEVENT__MASKTYPE);
    m_WaitEventEClass->getEStructuralFeatures().push_back(
            m_WaitEvent__maskType);
    // m_WaitEvent__waitingBehaviour has already been allocated above
    m_WaitEvent__waitingBehaviour->setFeatureID(
            ::amalthea::AmaltheaPackage::WAITEVENT__WAITINGBEHAVIOUR);
    m_WaitEventEClass->getEStructuralFeatures().push_back(
            m_WaitEvent__waitingBehaviour);
    // m_WaitEvent__eventMask has already been allocated above
    m_WaitEvent__eventMask->setFeatureID(
            ::amalthea::AmaltheaPackage::WAITEVENT__EVENTMASK);
    m_WaitEventEClass->getEStructuralFeatures().push_back(
            m_WaitEvent__eventMask);
    // m_WaitEvent__counter has already been allocated above
    m_WaitEvent__counter->setFeatureID(
            ::amalthea::AmaltheaPackage::WAITEVENT__COUNTER);
    m_WaitEventEClass->getEStructuralFeatures().push_back(m_WaitEvent__counter);

    // SetEvent
    {
        m_SetEventEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_SetEventEClass->setClassifierID(SETEVENT);
        m_SetEventEClass->setEPackage(_this());
        getEClassifiers().push_back(m_SetEventEClass);
    }
    // m_SetEvent__eventMask has already been allocated above
    m_SetEvent__eventMask->setFeatureID(
            ::amalthea::AmaltheaPackage::SETEVENT__EVENTMASK);
    m_SetEventEClass->getEStructuralFeatures().push_back(m_SetEvent__eventMask);
    // m_SetEvent__process has already been allocated above
    m_SetEvent__process->setFeatureID(
            ::amalthea::AmaltheaPackage::SETEVENT__PROCESS);
    m_SetEventEClass->getEStructuralFeatures().push_back(m_SetEvent__process);
    // m_SetEvent__counter has already been allocated above
    m_SetEvent__counter->setFeatureID(
            ::amalthea::AmaltheaPackage::SETEVENT__COUNTER);
    m_SetEventEClass->getEStructuralFeatures().push_back(m_SetEvent__counter);

    // ClearEvent
    {
        m_ClearEventEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_ClearEventEClass->setClassifierID(CLEAREVENT);
        m_ClearEventEClass->setEPackage(_this());
        getEClassifiers().push_back(m_ClearEventEClass);
    }
    // m_ClearEvent__eventMask has already been allocated above
    m_ClearEvent__eventMask->setFeatureID(
            ::amalthea::AmaltheaPackage::CLEAREVENT__EVENTMASK);
    m_ClearEventEClass->getEStructuralFeatures().push_back(
            m_ClearEvent__eventMask);
    // m_ClearEvent__counter has already been allocated above
    m_ClearEvent__counter->setFeatureID(
            ::amalthea::AmaltheaPackage::CLEAREVENT__COUNTER);
    m_ClearEventEClass->getEStructuralFeatures().push_back(
            m_ClearEvent__counter);

    // EventMask
    {
        m_EventMaskEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_EventMaskEClass->setClassifierID(EVENTMASK);
        m_EventMaskEClass->setEPackage(_this());
        getEClassifiers().push_back(m_EventMaskEClass);
    }
    // m_EventMask__events has already been allocated above
    m_EventMask__events->setFeatureID(
            ::amalthea::AmaltheaPackage::EVENTMASK__EVENTS);
    m_EventMaskEClass->getEStructuralFeatures().push_back(m_EventMask__events);

    // OsEvent
    {
        m_OsEventEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_OsEventEClass->setClassifierID(OSEVENT);
        m_OsEventEClass->setEPackage(_this());
        getEClassifiers().push_back(m_OsEventEClass);
    }
    // m_OsEvent__communicationOverheadInBit has already been allocated above
    m_OsEvent__communicationOverheadInBit->setFeatureID(
            ::amalthea::AmaltheaPackage::OSEVENT__COMMUNICATIONOVERHEADINBIT);
    m_OsEventEClass->getEStructuralFeatures().push_back(
            m_OsEvent__communicationOverheadInBit);
    // m_OsEvent__referringComponents has already been allocated above
    m_OsEvent__referringComponents->setFeatureID(
            ::amalthea::AmaltheaPackage::OSEVENT__REFERRINGCOMPONENTS);
    m_OsEventEClass->getEStructuralFeatures().push_back(
            m_OsEvent__referringComponents);

    // InterProcessTrigger
    {
        m_InterProcessTriggerEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_InterProcessTriggerEClass->setClassifierID(INTERPROCESSTRIGGER);
        m_InterProcessTriggerEClass->setEPackage(_this());
        getEClassifiers().push_back(m_InterProcessTriggerEClass);
    }
    // m_InterProcessTrigger__stimulus has already been allocated above
    m_InterProcessTrigger__stimulus->setFeatureID(
            ::amalthea::AmaltheaPackage::INTERPROCESSTRIGGER__STIMULUS);
    m_InterProcessTriggerEClass->getEStructuralFeatures().push_back(
            m_InterProcessTrigger__stimulus);
    // m_InterProcessTrigger__counter has already been allocated above
    m_InterProcessTrigger__counter->setFeatureID(
            ::amalthea::AmaltheaPackage::INTERPROCESSTRIGGER__COUNTER);
    m_InterProcessTriggerEClass->getEStructuralFeatures().push_back(
            m_InterProcessTrigger__counter);

    // EnforcedMigration
    {
        m_EnforcedMigrationEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_EnforcedMigrationEClass->setClassifierID(ENFORCEDMIGRATION);
        m_EnforcedMigrationEClass->setEPackage(_this());
        getEClassifiers().push_back(m_EnforcedMigrationEClass);
    }
    // m_EnforcedMigration__resourceOwner has already been allocated above
    m_EnforcedMigration__resourceOwner->setFeatureID(
            ::amalthea::AmaltheaPackage::ENFORCEDMIGRATION__RESOURCEOWNER);
    m_EnforcedMigrationEClass->getEStructuralFeatures().push_back(
            m_EnforcedMigration__resourceOwner);

    // SchedulePoint
    {
        m_SchedulePointEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_SchedulePointEClass->setClassifierID(SCHEDULEPOINT);
        m_SchedulePointEClass->setEPackage(_this());
        getEClassifiers().push_back(m_SchedulePointEClass);
    }

    // TerminateProcess
    {
        m_TerminateProcessEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_TerminateProcessEClass->setClassifierID(TERMINATEPROCESS);
        m_TerminateProcessEClass->setEPackage(_this());
        getEClassifiers().push_back(m_TerminateProcessEClass);
    }
    // m_TerminateProcess__counter has already been allocated above
    m_TerminateProcess__counter->setFeatureID(
            ::amalthea::AmaltheaPackage::TERMINATEPROCESS__COUNTER);
    m_TerminateProcessEClass->getEStructuralFeatures().push_back(
            m_TerminateProcess__counter);

    // Task
    {
        m_TaskEClass = ::ecore::Ptr < ::ecore::EClass > (new ::ecore::EClass);
        m_TaskEClass->setClassifierID(TASK);
        m_TaskEClass->setEPackage(_this());
        getEClassifiers().push_back(m_TaskEClass);
    }
    // m_Task__preemption has already been allocated above
    m_Task__preemption->setFeatureID(
            ::amalthea::AmaltheaPackage::TASK__PREEMPTION);
    m_TaskEClass->getEStructuralFeatures().push_back(m_Task__preemption);
    // m_Task__multipleTaskActivationLimit has already been allocated above
    m_Task__multipleTaskActivationLimit->setFeatureID(
            ::amalthea::AmaltheaPackage::TASK__MULTIPLETASKACTIVATIONLIMIT);
    m_TaskEClass->getEStructuralFeatures().push_back(
            m_Task__multipleTaskActivationLimit);

    // ISR
    {
        m_ISREClass = ::ecore::Ptr < ::ecore::EClass > (new ::ecore::EClass);
        m_ISREClass->setClassifierID(ISR);
        m_ISREClass->setEPackage(_this());
        getEClassifiers().push_back(m_ISREClass);
    }
    // m_ISR__category has already been allocated above
    m_ISR__category->setFeatureID(::amalthea::AmaltheaPackage::ISR__CATEGORY);
    m_ISREClass->getEStructuralFeatures().push_back(m_ISR__category);

    // ProcessPrototype
    {
        m_ProcessPrototypeEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_ProcessPrototypeEClass->setClassifierID(PROCESSPROTOTYPE);
        m_ProcessPrototypeEClass->setEPackage(_this());
        getEClassifiers().push_back(m_ProcessPrototypeEClass);
    }
    // m_ProcessPrototype__preemption has already been allocated above
    m_ProcessPrototype__preemption->setFeatureID(
            ::amalthea::AmaltheaPackage::PROCESSPROTOTYPE__PREEMPTION);
    m_ProcessPrototypeEClass->getEStructuralFeatures().push_back(
            m_ProcessPrototype__preemption);
    // m_ProcessPrototype__firstRunnable has already been allocated above
    m_ProcessPrototype__firstRunnable->setFeatureID(
            ::amalthea::AmaltheaPackage::PROCESSPROTOTYPE__FIRSTRUNNABLE);
    m_ProcessPrototypeEClass->getEStructuralFeatures().push_back(
            m_ProcessPrototype__firstRunnable);
    // m_ProcessPrototype__lastRunnable has already been allocated above
    m_ProcessPrototype__lastRunnable->setFeatureID(
            ::amalthea::AmaltheaPackage::PROCESSPROTOTYPE__LASTRUNNABLE);
    m_ProcessPrototypeEClass->getEStructuralFeatures().push_back(
            m_ProcessPrototype__lastRunnable);
    // m_ProcessPrototype__accessPrecedenceSpec has already been allocated above
    m_ProcessPrototype__accessPrecedenceSpec->setFeatureID(
            ::amalthea::AmaltheaPackage::PROCESSPROTOTYPE__ACCESSPRECEDENCESPEC);
    m_ProcessPrototypeEClass->getEStructuralFeatures().push_back(
            m_ProcessPrototype__accessPrecedenceSpec);
    // m_ProcessPrototype__orderPrecedenceSpec has already been allocated above
    m_ProcessPrototype__orderPrecedenceSpec->setFeatureID(
            ::amalthea::AmaltheaPackage::PROCESSPROTOTYPE__ORDERPRECEDENCESPEC);
    m_ProcessPrototypeEClass->getEStructuralFeatures().push_back(
            m_ProcessPrototype__orderPrecedenceSpec);
    // m_ProcessPrototype__chainedPrototypes has already been allocated above
    m_ProcessPrototype__chainedPrototypes->setFeatureID(
            ::amalthea::AmaltheaPackage::PROCESSPROTOTYPE__CHAINEDPROTOTYPES);
    m_ProcessPrototypeEClass->getEStructuralFeatures().push_back(
            m_ProcessPrototype__chainedPrototypes);
    // m_ProcessPrototype__activation has already been allocated above
    m_ProcessPrototype__activation->setFeatureID(
            ::amalthea::AmaltheaPackage::PROCESSPROTOTYPE__ACTIVATION);
    m_ProcessPrototypeEClass->getEStructuralFeatures().push_back(
            m_ProcessPrototype__activation);
    // m_ProcessPrototype__runnableCalls has already been allocated above
    m_ProcessPrototype__runnableCalls->setFeatureID(
            ::amalthea::AmaltheaPackage::PROCESSPROTOTYPE__RUNNABLECALLS);
    m_ProcessPrototypeEClass->getEStructuralFeatures().push_back(
            m_ProcessPrototype__runnableCalls);

    // ChainedProcessPrototype
    {
        m_ChainedProcessPrototypeEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_ChainedProcessPrototypeEClass->setClassifierID(
                CHAINEDPROCESSPROTOTYPE);
        m_ChainedProcessPrototypeEClass->setEPackage(_this());
        getEClassifiers().push_back(m_ChainedProcessPrototypeEClass);
    }
    // m_ChainedProcessPrototype__apply has already been allocated above
    m_ChainedProcessPrototype__apply->setFeatureID(
            ::amalthea::AmaltheaPackage::CHAINEDPROCESSPROTOTYPE__APPLY);
    m_ChainedProcessPrototypeEClass->getEStructuralFeatures().push_back(
            m_ChainedProcessPrototype__apply);
    // m_ChainedProcessPrototype__offset has already been allocated above
    m_ChainedProcessPrototype__offset->setFeatureID(
            ::amalthea::AmaltheaPackage::CHAINEDPROCESSPROTOTYPE__OFFSET);
    m_ChainedProcessPrototypeEClass->getEStructuralFeatures().push_back(
            m_ChainedProcessPrototype__offset);
    // m_ChainedProcessPrototype__prototype has already been allocated above
    m_ChainedProcessPrototype__prototype->setFeatureID(
            ::amalthea::AmaltheaPackage::CHAINEDPROCESSPROTOTYPE__PROTOTYPE);
    m_ChainedProcessPrototypeEClass->getEStructuralFeatures().push_back(
            m_ChainedProcessPrototype__prototype);

    // GeneralPrecedence
    {
        m_GeneralPrecedenceEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_GeneralPrecedenceEClass->setClassifierID(GENERALPRECEDENCE);
        m_GeneralPrecedenceEClass->setEPackage(_this());
        getEClassifiers().push_back(m_GeneralPrecedenceEClass);
    }
    // m_GeneralPrecedence__origin has already been allocated above
    m_GeneralPrecedence__origin->setFeatureID(
            ::amalthea::AmaltheaPackage::GENERALPRECEDENCE__ORIGIN);
    m_GeneralPrecedenceEClass->getEStructuralFeatures().push_back(
            m_GeneralPrecedence__origin);
    // m_GeneralPrecedence__target has already been allocated above
    m_GeneralPrecedence__target->setFeatureID(
            ::amalthea::AmaltheaPackage::GENERALPRECEDENCE__TARGET);
    m_GeneralPrecedenceEClass->getEStructuralFeatures().push_back(
            m_GeneralPrecedence__target);

    // AccessPrecedenceSpec
    {
        m_AccessPrecedenceSpecEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_AccessPrecedenceSpecEClass->setClassifierID(ACCESSPRECEDENCESPEC);
        m_AccessPrecedenceSpecEClass->setEPackage(_this());
        getEClassifiers().push_back(m_AccessPrecedenceSpecEClass);
    }
    // m_AccessPrecedenceSpec__orderType has already been allocated above
    m_AccessPrecedenceSpec__orderType->setFeatureID(
            ::amalthea::AmaltheaPackage::ACCESSPRECEDENCESPEC__ORDERTYPE);
    m_AccessPrecedenceSpecEClass->getEStructuralFeatures().push_back(
            m_AccessPrecedenceSpec__orderType);
    // m_AccessPrecedenceSpec__label has already been allocated above
    m_AccessPrecedenceSpec__label->setFeatureID(
            ::amalthea::AmaltheaPackage::ACCESSPRECEDENCESPEC__LABEL);
    m_AccessPrecedenceSpecEClass->getEStructuralFeatures().push_back(
            m_AccessPrecedenceSpec__label);

    // OrderPrecedenceSpec
    {
        m_OrderPrecedenceSpecEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_OrderPrecedenceSpecEClass->setClassifierID(ORDERPRECEDENCESPEC);
        m_OrderPrecedenceSpecEClass->setEPackage(_this());
        getEClassifiers().push_back(m_OrderPrecedenceSpecEClass);
    }
    // m_OrderPrecedenceSpec__orderType has already been allocated above
    m_OrderPrecedenceSpec__orderType->setFeatureID(
            ::amalthea::AmaltheaPackage::ORDERPRECEDENCESPEC__ORDERTYPE);
    m_OrderPrecedenceSpecEClass->getEStructuralFeatures().push_back(
            m_OrderPrecedenceSpec__orderType);

    // IDependsOn
    {
        m_IDependsOnEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_IDependsOnEClass->setClassifierID(IDEPENDSON);
        m_IDependsOnEClass->setEPackage(_this());
        getEClassifiers().push_back(m_IDependsOnEClass);
    }
    // m_IDependsOn__dependsOn has already been allocated above
    m_IDependsOn__dependsOn->setFeatureID(
            ::amalthea::AmaltheaPackage::IDEPENDSON__DEPENDSON);
    m_IDependsOnEClass->getEStructuralFeatures().push_back(
            m_IDependsOn__dependsOn);

    // DataDependency
    {
        m_DataDependencyEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_DataDependencyEClass->setClassifierID(DATADEPENDENCY);
        m_DataDependencyEClass->setEPackage(_this());
        getEClassifiers().push_back(m_DataDependencyEClass);
    }
    // m_DataDependency__labels has already been allocated above
    m_DataDependency__labels->setFeatureID(
            ::amalthea::AmaltheaPackage::DATADEPENDENCY__LABELS);
    m_DataDependencyEClass->getEStructuralFeatures().push_back(
            m_DataDependency__labels);
    // m_DataDependency__parameters has already been allocated above
    m_DataDependency__parameters->setFeatureID(
            ::amalthea::AmaltheaPackage::DATADEPENDENCY__PARAMETERS);
    m_DataDependencyEClass->getEStructuralFeatures().push_back(
            m_DataDependency__parameters);
    // m_DataDependency__callArguments has already been allocated above
    m_DataDependency__callArguments->setFeatureID(
            ::amalthea::AmaltheaPackage::DATADEPENDENCY__CALLARGUMENTS);
    m_DataDependencyEClass->getEStructuralFeatures().push_back(
            m_DataDependency__callArguments);
    // m_DataDependency__containingRunnable has already been allocated above
    m_DataDependency__containingRunnable->setFeatureID(
            ::amalthea::AmaltheaPackage::DATADEPENDENCY__CONTAININGRUNNABLE);
    m_DataDependencyEClass->getEStructuralFeatures().push_back(
            m_DataDependency__containingRunnable);

    // RunnableParameter
    {
        m_RunnableParameterEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_RunnableParameterEClass->setClassifierID(RUNNABLEPARAMETER);
        m_RunnableParameterEClass->setEPackage(_this());
        getEClassifiers().push_back(m_RunnableParameterEClass);
    }
    // m_RunnableParameter__direction has already been allocated above
    m_RunnableParameter__direction->setFeatureID(
            ::amalthea::AmaltheaPackage::RUNNABLEPARAMETER__DIRECTION);
    m_RunnableParameterEClass->getEStructuralFeatures().push_back(
            m_RunnableParameter__direction);
    // m_RunnableParameter__containingRunnable has already been allocated above
    m_RunnableParameter__containingRunnable->setFeatureID(
            ::amalthea::AmaltheaPackage::RUNNABLEPARAMETER__CONTAININGRUNNABLE);
    m_RunnableParameterEClass->getEStructuralFeatures().push_back(
            m_RunnableParameter__containingRunnable);
    // m_RunnableParameter__dataType has already been allocated above
    m_RunnableParameter__dataType->setFeatureID(
            ::amalthea::AmaltheaPackage::RUNNABLEPARAMETER__DATATYPE);
    m_RunnableParameterEClass->getEStructuralFeatures().push_back(
            m_RunnableParameter__dataType);

    // Runnable
    {
        m_RunnableEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_RunnableEClass->setClassifierID(RUNNABLE);
        m_RunnableEClass->setEPackage(_this());
        getEClassifiers().push_back(m_RunnableEClass);
    }
    // m_Runnable__callback has already been allocated above
    m_Runnable__callback->setFeatureID(
            ::amalthea::AmaltheaPackage::RUNNABLE__CALLBACK);
    m_RunnableEClass->getEStructuralFeatures().push_back(m_Runnable__callback);
    // m_Runnable__service has already been allocated above
    m_Runnable__service->setFeatureID(
            ::amalthea::AmaltheaPackage::RUNNABLE__SERVICE);
    m_RunnableEClass->getEStructuralFeatures().push_back(m_Runnable__service);
    // m_Runnable__asilLevel has already been allocated above
    m_Runnable__asilLevel->setFeatureID(
            ::amalthea::AmaltheaPackage::RUNNABLE__ASILLEVEL);
    m_RunnableEClass->getEStructuralFeatures().push_back(m_Runnable__asilLevel);
    // m_Runnable__executionCondition has already been allocated above
    m_Runnable__executionCondition->setFeatureID(
            ::amalthea::AmaltheaPackage::RUNNABLE__EXECUTIONCONDITION);
    m_RunnableEClass->getEStructuralFeatures().push_back(
            m_Runnable__executionCondition);
    // m_Runnable__parameters has already been allocated above
    m_Runnable__parameters->setFeatureID(
            ::amalthea::AmaltheaPackage::RUNNABLE__PARAMETERS);
    m_RunnableEClass->getEStructuralFeatures().push_back(
            m_Runnable__parameters);
    // m_Runnable__activityGraph has already been allocated above
    m_Runnable__activityGraph->setFeatureID(
            ::amalthea::AmaltheaPackage::RUNNABLE__ACTIVITYGRAPH);
    m_RunnableEClass->getEStructuralFeatures().push_back(
            m_Runnable__activityGraph);
    // m_Runnable__activations has already been allocated above
    m_Runnable__activations->setFeatureID(
            ::amalthea::AmaltheaPackage::RUNNABLE__ACTIVATIONS);
    m_RunnableEClass->getEStructuralFeatures().push_back(
            m_Runnable__activations);
    // m_Runnable__section has already been allocated above
    m_Runnable__section->setFeatureID(
            ::amalthea::AmaltheaPackage::RUNNABLE__SECTION);
    m_RunnableEClass->getEStructuralFeatures().push_back(m_Runnable__section);
    // m_Runnable__runnableCalls has already been allocated above
    m_Runnable__runnableCalls->setFeatureID(
            ::amalthea::AmaltheaPackage::RUNNABLE__RUNNABLECALLS);
    m_RunnableEClass->getEStructuralFeatures().push_back(
            m_Runnable__runnableCalls);
    // m_Runnable__referringComponents has already been allocated above
    m_Runnable__referringComponents->setFeatureID(
            ::amalthea::AmaltheaPackage::RUNNABLE__REFERRINGCOMPONENTS);
    m_RunnableEClass->getEStructuralFeatures().push_back(
            m_Runnable__referringComponents);

    // Label
    {
        m_LabelEClass = ::ecore::Ptr < ::ecore::EClass > (new ::ecore::EClass);
        m_LabelEClass->setClassifierID(LABEL);
        m_LabelEClass->setEPackage(_this());
        getEClassifiers().push_back(m_LabelEClass);
    }
    // m_Label__constant has already been allocated above
    m_Label__constant->setFeatureID(
            ::amalthea::AmaltheaPackage::LABEL__CONSTANT);
    m_LabelEClass->getEStructuralFeatures().push_back(m_Label__constant);
    // m_Label__bVolatile has already been allocated above
    m_Label__bVolatile->setFeatureID(
            ::amalthea::AmaltheaPackage::LABEL__BVOLATILE);
    m_LabelEClass->getEStructuralFeatures().push_back(m_Label__bVolatile);
    // m_Label__dataStability has already been allocated above
    m_Label__dataStability->setFeatureID(
            ::amalthea::AmaltheaPackage::LABEL__DATASTABILITY);
    m_LabelEClass->getEStructuralFeatures().push_back(m_Label__dataStability);
    // m_Label__stabilityLevel has already been allocated above
    m_Label__stabilityLevel->setFeatureID(
            ::amalthea::AmaltheaPackage::LABEL__STABILITYLEVEL);
    m_LabelEClass->getEStructuralFeatures().push_back(m_Label__stabilityLevel);
    // m_Label__dataType has already been allocated above
    m_Label__dataType->setFeatureID(
            ::amalthea::AmaltheaPackage::LABEL__DATATYPE);
    m_LabelEClass->getEStructuralFeatures().push_back(m_Label__dataType);
    // m_Label__section has already been allocated above
    m_Label__section->setFeatureID(::amalthea::AmaltheaPackage::LABEL__SECTION);
    m_LabelEClass->getEStructuralFeatures().push_back(m_Label__section);
    // m_Label__labelAccesses has already been allocated above
    m_Label__labelAccesses->setFeatureID(
            ::amalthea::AmaltheaPackage::LABEL__LABELACCESSES);
    m_LabelEClass->getEStructuralFeatures().push_back(m_Label__labelAccesses);
    // m_Label__referringComponents has already been allocated above
    m_Label__referringComponents->setFeatureID(
            ::amalthea::AmaltheaPackage::LABEL__REFERRINGCOMPONENTS);
    m_LabelEClass->getEStructuralFeatures().push_back(
            m_Label__referringComponents);

    // Channel
    {
        m_ChannelEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_ChannelEClass->setClassifierID(CHANNEL);
        m_ChannelEClass->setEPackage(_this());
        getEClassifiers().push_back(m_ChannelEClass);
    }
    // m_Channel__defaultElements has already been allocated above
    m_Channel__defaultElements->setFeatureID(
            ::amalthea::AmaltheaPackage::CHANNEL__DEFAULTELEMENTS);
    m_ChannelEClass->getEStructuralFeatures().push_back(
            m_Channel__defaultElements);
    // m_Channel__maxElements has already been allocated above
    m_Channel__maxElements->setFeatureID(
            ::amalthea::AmaltheaPackage::CHANNEL__MAXELEMENTS);
    m_ChannelEClass->getEStructuralFeatures().push_back(m_Channel__maxElements);
    // m_Channel__elementType has already been allocated above
    m_Channel__elementType->setFeatureID(
            ::amalthea::AmaltheaPackage::CHANNEL__ELEMENTTYPE);
    m_ChannelEClass->getEStructuralFeatures().push_back(m_Channel__elementType);
    // m_Channel__channelAccesses has already been allocated above
    m_Channel__channelAccesses->setFeatureID(
            ::amalthea::AmaltheaPackage::CHANNEL__CHANNELACCESSES);
    m_ChannelEClass->getEStructuralFeatures().push_back(
            m_Channel__channelAccesses);

    // ModeLabel
    {
        m_ModeLabelEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_ModeLabelEClass->setClassifierID(MODELABEL);
        m_ModeLabelEClass->setEPackage(_this());
        getEClassifiers().push_back(m_ModeLabelEClass);
    }
    // m_ModeLabel__initialValue has already been allocated above
    m_ModeLabel__initialValue->setFeatureID(
            ::amalthea::AmaltheaPackage::MODELABEL__INITIALVALUE);
    m_ModeLabelEClass->getEStructuralFeatures().push_back(
            m_ModeLabel__initialValue);
    // m_ModeLabel__mode has already been allocated above
    m_ModeLabel__mode->setFeatureID(
            ::amalthea::AmaltheaPackage::MODELABEL__MODE);
    m_ModeLabelEClass->getEStructuralFeatures().push_back(m_ModeLabel__mode);

    // Section
    {
        m_SectionEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_SectionEClass->setClassifierID(SECTION);
        m_SectionEClass->setEPackage(_this());
        getEClassifiers().push_back(m_SectionEClass);
    }
    // m_Section__asilLevel has already been allocated above
    m_Section__asilLevel->setFeatureID(
            ::amalthea::AmaltheaPackage::SECTION__ASILLEVEL);
    m_SectionEClass->getEStructuralFeatures().push_back(m_Section__asilLevel);
    // m_Section__labels has already been allocated above
    m_Section__labels->setFeatureID(
            ::amalthea::AmaltheaPackage::SECTION__LABELS);
    m_SectionEClass->getEStructuralFeatures().push_back(m_Section__labels);
    // m_Section__runnables has already been allocated above
    m_Section__runnables->setFeatureID(
            ::amalthea::AmaltheaPackage::SECTION__RUNNABLES);
    m_SectionEClass->getEStructuralFeatures().push_back(m_Section__runnables);

    // ComputationItem
    {
        m_ComputationItemEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_ComputationItemEClass->setClassifierID(COMPUTATIONITEM);
        m_ComputationItemEClass->setEPackage(_this());
        getEClassifiers().push_back(m_ComputationItemEClass);
    }

    // ExecutionNeed
    {
        m_ExecutionNeedEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_ExecutionNeedEClass->setClassifierID(EXECUTIONNEED);
        m_ExecutionNeedEClass->setEPackage(_this());
        getEClassifiers().push_back(m_ExecutionNeedEClass);
    }
    // m_ExecutionNeed__needs has already been allocated above
    m_ExecutionNeed__needs->setFeatureID(
            ::amalthea::AmaltheaPackage::EXECUTIONNEED__NEEDS);
    m_ExecutionNeedEClass->getEStructuralFeatures().push_back(
            m_ExecutionNeed__needs);

    // NeedEntry
    {
        m_NeedEntryEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_NeedEntryEClass->setClassifierID(NEEDENTRY);
        m_NeedEntryEClass->setEPackage(_this());
        getEClassifiers().push_back(m_NeedEntryEClass);
    }
    // m_NeedEntry__key has already been allocated above
    m_NeedEntry__key->setFeatureID(::amalthea::AmaltheaPackage::NEEDENTRY__KEY);
    m_NeedEntryEClass->getEStructuralFeatures().push_back(m_NeedEntry__key);
    // m_NeedEntry__value has already been allocated above
    m_NeedEntry__value->setFeatureID(
            ::amalthea::AmaltheaPackage::NEEDENTRY__VALUE);
    m_NeedEntryEClass->getEStructuralFeatures().push_back(m_NeedEntry__value);

    // Ticks
    {
        m_TicksEClass = ::ecore::Ptr < ::ecore::EClass > (new ::ecore::EClass);
        m_TicksEClass->setClassifierID(TICKS);
        m_TicksEClass->setEPackage(_this());
        getEClassifiers().push_back(m_TicksEClass);
    }
    // m_Ticks__default has already been allocated above
    m_Ticks__default->setFeatureID(::amalthea::AmaltheaPackage::TICKS__DEFAULT);
    m_TicksEClass->getEStructuralFeatures().push_back(m_Ticks__default);
    // m_Ticks__extended has already been allocated above
    m_Ticks__extended->setFeatureID(
            ::amalthea::AmaltheaPackage::TICKS__EXTENDED);
    m_TicksEClass->getEStructuralFeatures().push_back(m_Ticks__extended);

    // TicksEntry
    {
        m_TicksEntryEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_TicksEntryEClass->setClassifierID(TICKSENTRY);
        m_TicksEntryEClass->setEPackage(_this());
        getEClassifiers().push_back(m_TicksEntryEClass);
    }
    // m_TicksEntry__key has already been allocated above
    m_TicksEntry__key->setFeatureID(
            ::amalthea::AmaltheaPackage::TICKSENTRY__KEY);
    m_TicksEntryEClass->getEStructuralFeatures().push_back(m_TicksEntry__key);
    // m_TicksEntry__value has already been allocated above
    m_TicksEntry__value->setFeatureID(
            ::amalthea::AmaltheaPackage::TICKSENTRY__VALUE);
    m_TicksEntryEClass->getEStructuralFeatures().push_back(m_TicksEntry__value);

    // ModeLabelAccess
    {
        m_ModeLabelAccessEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_ModeLabelAccessEClass->setClassifierID(MODELABELACCESS);
        m_ModeLabelAccessEClass->setEPackage(_this());
        getEClassifiers().push_back(m_ModeLabelAccessEClass);
    }
    // m_ModeLabelAccess__access has already been allocated above
    m_ModeLabelAccess__access->setFeatureID(
            ::amalthea::AmaltheaPackage::MODELABELACCESS__ACCESS);
    m_ModeLabelAccessEClass->getEStructuralFeatures().push_back(
            m_ModeLabelAccess__access);
    // m_ModeLabelAccess__value has already been allocated above
    m_ModeLabelAccess__value->setFeatureID(
            ::amalthea::AmaltheaPackage::MODELABELACCESS__VALUE);
    m_ModeLabelAccessEClass->getEStructuralFeatures().push_back(
            m_ModeLabelAccess__value);
    // m_ModeLabelAccess__step has already been allocated above
    m_ModeLabelAccess__step->setFeatureID(
            ::amalthea::AmaltheaPackage::MODELABELACCESS__STEP);
    m_ModeLabelAccessEClass->getEStructuralFeatures().push_back(
            m_ModeLabelAccess__step);
    // m_ModeLabelAccess__data has already been allocated above
    m_ModeLabelAccess__data->setFeatureID(
            ::amalthea::AmaltheaPackage::MODELABELACCESS__DATA);
    m_ModeLabelAccessEClass->getEStructuralFeatures().push_back(
            m_ModeLabelAccess__data);

    // LabelAccess
    {
        m_LabelAccessEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_LabelAccessEClass->setClassifierID(LABELACCESS);
        m_LabelAccessEClass->setEPackage(_this());
        getEClassifiers().push_back(m_LabelAccessEClass);
    }
    // m_LabelAccess__access has already been allocated above
    m_LabelAccess__access->setFeatureID(
            ::amalthea::AmaltheaPackage::LABELACCESS__ACCESS);
    m_LabelAccessEClass->getEStructuralFeatures().push_back(
            m_LabelAccess__access);
    // m_LabelAccess__dataStability has already been allocated above
    m_LabelAccess__dataStability->setFeatureID(
            ::amalthea::AmaltheaPackage::LABELACCESS__DATASTABILITY);
    m_LabelAccessEClass->getEStructuralFeatures().push_back(
            m_LabelAccess__dataStability);
    // m_LabelAccess__implementation has already been allocated above
    m_LabelAccess__implementation->setFeatureID(
            ::amalthea::AmaltheaPackage::LABELACCESS__IMPLEMENTATION);
    m_LabelAccessEClass->getEStructuralFeatures().push_back(
            m_LabelAccess__implementation);
    // m_LabelAccess__data has already been allocated above
    m_LabelAccess__data->setFeatureID(
            ::amalthea::AmaltheaPackage::LABELACCESS__DATA);
    m_LabelAccessEClass->getEStructuralFeatures().push_back(
            m_LabelAccess__data);
    // m_LabelAccess__statistic has already been allocated above
    m_LabelAccess__statistic->setFeatureID(
            ::amalthea::AmaltheaPackage::LABELACCESS__STATISTIC);
    m_LabelAccessEClass->getEStructuralFeatures().push_back(
            m_LabelAccess__statistic);
    // m_LabelAccess__transmissionPolicy has already been allocated above
    m_LabelAccess__transmissionPolicy->setFeatureID(
            ::amalthea::AmaltheaPackage::LABELACCESS__TRANSMISSIONPOLICY);
    m_LabelAccessEClass->getEStructuralFeatures().push_back(
            m_LabelAccess__transmissionPolicy);

    // ChannelAccess
    {
        m_ChannelAccessEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_ChannelAccessEClass->setClassifierID(CHANNELACCESS);
        m_ChannelAccessEClass->setEPackage(_this());
        getEClassifiers().push_back(m_ChannelAccessEClass);
    }
    // m_ChannelAccess__elements has already been allocated above
    m_ChannelAccess__elements->setFeatureID(
            ::amalthea::AmaltheaPackage::CHANNELACCESS__ELEMENTS);
    m_ChannelAccessEClass->getEStructuralFeatures().push_back(
            m_ChannelAccess__elements);
    // m_ChannelAccess__data has already been allocated above
    m_ChannelAccess__data->setFeatureID(
            ::amalthea::AmaltheaPackage::CHANNELACCESS__DATA);
    m_ChannelAccessEClass->getEStructuralFeatures().push_back(
            m_ChannelAccess__data);
    // m_ChannelAccess__transmissionPolicy has already been allocated above
    m_ChannelAccess__transmissionPolicy->setFeatureID(
            ::amalthea::AmaltheaPackage::CHANNELACCESS__TRANSMISSIONPOLICY);
    m_ChannelAccessEClass->getEStructuralFeatures().push_back(
            m_ChannelAccess__transmissionPolicy);

    // ChannelSend
    {
        m_ChannelSendEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_ChannelSendEClass->setClassifierID(CHANNELSEND);
        m_ChannelSendEClass->setEPackage(_this());
        getEClassifiers().push_back(m_ChannelSendEClass);
    }

    // ChannelReceive
    {
        m_ChannelReceiveEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_ChannelReceiveEClass->setClassifierID(CHANNELRECEIVE);
        m_ChannelReceiveEClass->setEPackage(_this());
        getEClassifiers().push_back(m_ChannelReceiveEClass);
    }
    // m_ChannelReceive__receiveOperation has already been allocated above
    m_ChannelReceive__receiveOperation->setFeatureID(
            ::amalthea::AmaltheaPackage::CHANNELRECEIVE__RECEIVEOPERATION);
    m_ChannelReceiveEClass->getEStructuralFeatures().push_back(
            m_ChannelReceive__receiveOperation);
    // m_ChannelReceive__dataMustBeNew has already been allocated above
    m_ChannelReceive__dataMustBeNew->setFeatureID(
            ::amalthea::AmaltheaPackage::CHANNELRECEIVE__DATAMUSTBENEW);
    m_ChannelReceiveEClass->getEStructuralFeatures().push_back(
            m_ChannelReceive__dataMustBeNew);
    // m_ChannelReceive__elementIndex has already been allocated above
    m_ChannelReceive__elementIndex->setFeatureID(
            ::amalthea::AmaltheaPackage::CHANNELRECEIVE__ELEMENTINDEX);
    m_ChannelReceiveEClass->getEStructuralFeatures().push_back(
            m_ChannelReceive__elementIndex);
    // m_ChannelReceive__lowerBound has already been allocated above
    m_ChannelReceive__lowerBound->setFeatureID(
            ::amalthea::AmaltheaPackage::CHANNELRECEIVE__LOWERBOUND);
    m_ChannelReceiveEClass->getEStructuralFeatures().push_back(
            m_ChannelReceive__lowerBound);

    // SemaphoreAccess
    {
        m_SemaphoreAccessEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_SemaphoreAccessEClass->setClassifierID(SEMAPHOREACCESS);
        m_SemaphoreAccessEClass->setEPackage(_this());
        getEClassifiers().push_back(m_SemaphoreAccessEClass);
    }
    // m_SemaphoreAccess__access has already been allocated above
    m_SemaphoreAccess__access->setFeatureID(
            ::amalthea::AmaltheaPackage::SEMAPHOREACCESS__ACCESS);
    m_SemaphoreAccessEClass->getEStructuralFeatures().push_back(
            m_SemaphoreAccess__access);
    // m_SemaphoreAccess__waitingBehaviour has already been allocated above
    m_SemaphoreAccess__waitingBehaviour->setFeatureID(
            ::amalthea::AmaltheaPackage::SEMAPHOREACCESS__WAITINGBEHAVIOUR);
    m_SemaphoreAccessEClass->getEStructuralFeatures().push_back(
            m_SemaphoreAccess__waitingBehaviour);
    // m_SemaphoreAccess__semaphore has already been allocated above
    m_SemaphoreAccess__semaphore->setFeatureID(
            ::amalthea::AmaltheaPackage::SEMAPHOREACCESS__SEMAPHORE);
    m_SemaphoreAccessEClass->getEStructuralFeatures().push_back(
            m_SemaphoreAccess__semaphore);

    // SenderReceiverCommunication
    {
        m_SenderReceiverCommunicationEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_SenderReceiverCommunicationEClass->setClassifierID(
                SENDERRECEIVERCOMMUNICATION);
        m_SenderReceiverCommunicationEClass->setEPackage(_this());
        getEClassifiers().push_back(m_SenderReceiverCommunicationEClass);
    }
    // m_SenderReceiverCommunication__buffered has already been allocated above
    m_SenderReceiverCommunication__buffered->setFeatureID(
            ::amalthea::AmaltheaPackage::SENDERRECEIVERCOMMUNICATION__BUFFERED);
    m_SenderReceiverCommunicationEClass->getEStructuralFeatures().push_back(
            m_SenderReceiverCommunication__buffered);
    // m_SenderReceiverCommunication__label has already been allocated above
    m_SenderReceiverCommunication__label->setFeatureID(
            ::amalthea::AmaltheaPackage::SENDERRECEIVERCOMMUNICATION__LABEL);
    m_SenderReceiverCommunicationEClass->getEStructuralFeatures().push_back(
            m_SenderReceiverCommunication__label);
    // m_SenderReceiverCommunication__port has already been allocated above
    m_SenderReceiverCommunication__port->setFeatureID(
            ::amalthea::AmaltheaPackage::SENDERRECEIVERCOMMUNICATION__PORT);
    m_SenderReceiverCommunicationEClass->getEStructuralFeatures().push_back(
            m_SenderReceiverCommunication__port);

    // SenderReceiverRead
    {
        m_SenderReceiverReadEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_SenderReceiverReadEClass->setClassifierID(SENDERRECEIVERREAD);
        m_SenderReceiverReadEClass->setEPackage(_this());
        getEClassifiers().push_back(m_SenderReceiverReadEClass);
    }

    // SenderReceiverWrite
    {
        m_SenderReceiverWriteEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_SenderReceiverWriteEClass->setClassifierID(SENDERRECEIVERWRITE);
        m_SenderReceiverWriteEClass->setEPackage(_this());
        getEClassifiers().push_back(m_SenderReceiverWriteEClass);
    }
    // m_SenderReceiverWrite__notifiedRunnables has already been allocated above
    m_SenderReceiverWrite__notifiedRunnables->setFeatureID(
            ::amalthea::AmaltheaPackage::SENDERRECEIVERWRITE__NOTIFIEDRUNNABLES);
    m_SenderReceiverWriteEClass->getEStructuralFeatures().push_back(
            m_SenderReceiverWrite__notifiedRunnables);

    // ServerCall
    {
        m_ServerCallEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_ServerCallEClass->setClassifierID(SERVERCALL);
        m_ServerCallEClass->setEPackage(_this());
        getEClassifiers().push_back(m_ServerCallEClass);
    }
    // m_ServerCall__serverRunnable has already been allocated above
    m_ServerCall__serverRunnable->setFeatureID(
            ::amalthea::AmaltheaPackage::SERVERCALL__SERVERRUNNABLE);
    m_ServerCallEClass->getEStructuralFeatures().push_back(
            m_ServerCall__serverRunnable);
    // m_ServerCall__port has already been allocated above
    m_ServerCall__port->setFeatureID(
            ::amalthea::AmaltheaPackage::SERVERCALL__PORT);
    m_ServerCallEClass->getEStructuralFeatures().push_back(m_ServerCall__port);

    // SynchronousServerCall
    {
        m_SynchronousServerCallEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_SynchronousServerCallEClass->setClassifierID(SYNCHRONOUSSERVERCALL);
        m_SynchronousServerCallEClass->setEPackage(_this());
        getEClassifiers().push_back(m_SynchronousServerCallEClass);
    }
    // m_SynchronousServerCall__waitingBehaviour has already been allocated above
    m_SynchronousServerCall__waitingBehaviour->setFeatureID(
            ::amalthea::AmaltheaPackage::SYNCHRONOUSSERVERCALL__WAITINGBEHAVIOUR);
    m_SynchronousServerCallEClass->getEStructuralFeatures().push_back(
            m_SynchronousServerCall__waitingBehaviour);

    // AsynchronousServerCall
    {
        m_AsynchronousServerCallEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_AsynchronousServerCallEClass->setClassifierID(ASYNCHRONOUSSERVERCALL);
        m_AsynchronousServerCallEClass->setEPackage(_this());
        getEClassifiers().push_back(m_AsynchronousServerCallEClass);
    }
    // m_AsynchronousServerCall__resultRunnable has already been allocated above
    m_AsynchronousServerCall__resultRunnable->setFeatureID(
            ::amalthea::AmaltheaPackage::ASYNCHRONOUSSERVERCALL__RESULTRUNNABLE);
    m_AsynchronousServerCallEClass->getEStructuralFeatures().push_back(
            m_AsynchronousServerCall__resultRunnable);

    // GetResultServerCall
    {
        m_GetResultServerCallEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_GetResultServerCallEClass->setClassifierID(GETRESULTSERVERCALL);
        m_GetResultServerCallEClass->setEPackage(_this());
        getEClassifiers().push_back(m_GetResultServerCallEClass);
    }
    // m_GetResultServerCall__blockingType has already been allocated above
    m_GetResultServerCall__blockingType->setFeatureID(
            ::amalthea::AmaltheaPackage::GETRESULTSERVERCALL__BLOCKINGTYPE);
    m_GetResultServerCallEClass->getEStructuralFeatures().push_back(
            m_GetResultServerCall__blockingType);

    // Group
    {
        m_GroupEClass = ::ecore::Ptr < ::ecore::EClass > (new ::ecore::EClass);
        m_GroupEClass->setClassifierID(GROUP);
        m_GroupEClass->setEPackage(_this());
        getEClassifiers().push_back(m_GroupEClass);
    }
    // m_Group__ordered has already been allocated above
    m_Group__ordered->setFeatureID(::amalthea::AmaltheaPackage::GROUP__ORDERED);
    m_GroupEClass->getEStructuralFeatures().push_back(m_Group__ordered);

    // CallArgument
    {
        m_CallArgumentEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_CallArgumentEClass->setClassifierID(CALLARGUMENT);
        m_CallArgumentEClass->setEPackage(_this());
        getEClassifiers().push_back(m_CallArgumentEClass);
    }
    // m_CallArgument__containingCall has already been allocated above
    m_CallArgument__containingCall->setFeatureID(
            ::amalthea::AmaltheaPackage::CALLARGUMENT__CONTAININGCALL);
    m_CallArgumentEClass->getEStructuralFeatures().push_back(
            m_CallArgument__containingCall);
    // m_CallArgument__parameter has already been allocated above
    m_CallArgument__parameter->setFeatureID(
            ::amalthea::AmaltheaPackage::CALLARGUMENT__PARAMETER);
    m_CallArgumentEClass->getEStructuralFeatures().push_back(
            m_CallArgument__parameter);

    // RunnableCall
    {
        m_RunnableCallEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_RunnableCallEClass->setClassifierID(RUNNABLECALL);
        m_RunnableCallEClass->setEPackage(_this());
        getEClassifiers().push_back(m_RunnableCallEClass);
    }
    // m_RunnableCall__runnable has already been allocated above
    m_RunnableCall__runnable->setFeatureID(
            ::amalthea::AmaltheaPackage::RUNNABLECALL__RUNNABLE);
    m_RunnableCallEClass->getEStructuralFeatures().push_back(
            m_RunnableCall__runnable);
    // m_RunnableCall__arguments has already been allocated above
    m_RunnableCall__arguments->setFeatureID(
            ::amalthea::AmaltheaPackage::RUNNABLECALL__ARGUMENTS);
    m_RunnableCallEClass->getEStructuralFeatures().push_back(
            m_RunnableCall__arguments);
    // m_RunnableCall__counter has already been allocated above
    m_RunnableCall__counter->setFeatureID(
            ::amalthea::AmaltheaPackage::RUNNABLECALL__COUNTER);
    m_RunnableCallEClass->getEStructuralFeatures().push_back(
            m_RunnableCall__counter);
    // m_RunnableCall__statistic has already been allocated above
    m_RunnableCall__statistic->setFeatureID(
            ::amalthea::AmaltheaPackage::RUNNABLECALL__STATISTIC);
    m_RunnableCallEClass->getEStructuralFeatures().push_back(
            m_RunnableCall__statistic);

    // CustomEventTrigger
    {
        m_CustomEventTriggerEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_CustomEventTriggerEClass->setClassifierID(CUSTOMEVENTTRIGGER);
        m_CustomEventTriggerEClass->setEPackage(_this());
        getEClassifiers().push_back(m_CustomEventTriggerEClass);
    }
    // m_CustomEventTrigger__event has already been allocated above
    m_CustomEventTrigger__event->setFeatureID(
            ::amalthea::AmaltheaPackage::CUSTOMEVENTTRIGGER__EVENT);
    m_CustomEventTriggerEClass->getEStructuralFeatures().push_back(
            m_CustomEventTrigger__event);

    // DataType
    {
        m_DataTypeEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_DataTypeEClass->setClassifierID(DATATYPE);
        m_DataTypeEClass->setEPackage(_this());
        getEClassifiers().push_back(m_DataTypeEClass);
    }

    // CompoundType
    {
        m_CompoundTypeEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_CompoundTypeEClass->setClassifierID(COMPOUNDTYPE);
        m_CompoundTypeEClass->setEPackage(_this());
        getEClassifiers().push_back(m_CompoundTypeEClass);
    }

    // Struct
    {
        m_StructEClass = ::ecore::Ptr < ::ecore::EClass > (new ::ecore::EClass);
        m_StructEClass->setClassifierID(STRUCT);
        m_StructEClass->setEPackage(_this());
        getEClassifiers().push_back(m_StructEClass);
    }
    // m_Struct__entries has already been allocated above
    m_Struct__entries->setFeatureID(
            ::amalthea::AmaltheaPackage::STRUCT__ENTRIES);
    m_StructEClass->getEStructuralFeatures().push_back(m_Struct__entries);

    // StructEntry
    {
        m_StructEntryEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_StructEntryEClass->setClassifierID(STRUCTENTRY);
        m_StructEntryEClass->setEPackage(_this());
        getEClassifiers().push_back(m_StructEntryEClass);
    }
    // m_StructEntry__dataType has already been allocated above
    m_StructEntry__dataType->setFeatureID(
            ::amalthea::AmaltheaPackage::STRUCTENTRY__DATATYPE);
    m_StructEntryEClass->getEStructuralFeatures().push_back(
            m_StructEntry__dataType);

    // Array
    {
        m_ArrayEClass = ::ecore::Ptr < ::ecore::EClass > (new ::ecore::EClass);
        m_ArrayEClass->setClassifierID(ARRAY);
        m_ArrayEClass->setEPackage(_this());
        getEClassifiers().push_back(m_ArrayEClass);
    }
    // m_Array__numberElements has already been allocated above
    m_Array__numberElements->setFeatureID(
            ::amalthea::AmaltheaPackage::ARRAY__NUMBERELEMENTS);
    m_ArrayEClass->getEStructuralFeatures().push_back(m_Array__numberElements);
    // m_Array__dataType has already been allocated above
    m_Array__dataType->setFeatureID(
            ::amalthea::AmaltheaPackage::ARRAY__DATATYPE);
    m_ArrayEClass->getEStructuralFeatures().push_back(m_Array__dataType);

    // Pointer
    {
        m_PointerEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_PointerEClass->setClassifierID(POINTER);
        m_PointerEClass->setEPackage(_this());
        getEClassifiers().push_back(m_PointerEClass);
    }
    // m_Pointer__dataType has already been allocated above
    m_Pointer__dataType->setFeatureID(
            ::amalthea::AmaltheaPackage::POINTER__DATATYPE);
    m_PointerEClass->getEStructuralFeatures().push_back(m_Pointer__dataType);

    // TypeRef
    {
        m_TypeRefEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_TypeRefEClass->setClassifierID(TYPEREF);
        m_TypeRefEClass->setEPackage(_this());
        getEClassifiers().push_back(m_TypeRefEClass);
    }
    // m_TypeRef__typeDef has already been allocated above
    m_TypeRef__typeDef->setFeatureID(
            ::amalthea::AmaltheaPackage::TYPEREF__TYPEDEF);
    m_TypeRefEClass->getEStructuralFeatures().push_back(m_TypeRef__typeDef);

    // Alias
    {
        m_AliasEClass = ::ecore::Ptr < ::ecore::EClass > (new ::ecore::EClass);
        m_AliasEClass->setClassifierID(ALIAS);
        m_AliasEClass->setEPackage(_this());
        getEClassifiers().push_back(m_AliasEClass);
    }
    // m_Alias__target has already been allocated above
    m_Alias__target->setFeatureID(::amalthea::AmaltheaPackage::ALIAS__TARGET);
    m_AliasEClass->getEStructuralFeatures().push_back(m_Alias__target);
    // m_Alias__alias has already been allocated above
    m_Alias__alias->setFeatureID(::amalthea::AmaltheaPackage::ALIAS__ALIAS);
    m_AliasEClass->getEStructuralFeatures().push_back(m_Alias__alias);

    // TypeDefinition
    {
        m_TypeDefinitionEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_TypeDefinitionEClass->setClassifierID(TYPEDEFINITION);
        m_TypeDefinitionEClass->setEPackage(_this());
        getEClassifiers().push_back(m_TypeDefinitionEClass);
    }
    // m_TypeDefinition__size has already been allocated above
    m_TypeDefinition__size->setFeatureID(
            ::amalthea::AmaltheaPackage::TYPEDEFINITION__SIZE);
    m_TypeDefinitionEClass->getEStructuralFeatures().push_back(
            m_TypeDefinition__size);

    // DataTypeDefinition
    {
        m_DataTypeDefinitionEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_DataTypeDefinitionEClass->setClassifierID(DATATYPEDEFINITION);
        m_DataTypeDefinitionEClass->setEPackage(_this());
        getEClassifiers().push_back(m_DataTypeDefinitionEClass);
    }
    // m_DataTypeDefinition__dataType has already been allocated above
    m_DataTypeDefinition__dataType->setFeatureID(
            ::amalthea::AmaltheaPackage::DATATYPEDEFINITION__DATATYPE);
    m_DataTypeDefinitionEClass->getEStructuralFeatures().push_back(
            m_DataTypeDefinition__dataType);

    // BaseTypeDefinition
    {
        m_BaseTypeDefinitionEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_BaseTypeDefinitionEClass->setClassifierID(BASETYPEDEFINITION);
        m_BaseTypeDefinitionEClass->setEPackage(_this());
        getEClassifiers().push_back(m_BaseTypeDefinitionEClass);
    }
    // m_BaseTypeDefinition__aliases has already been allocated above
    m_BaseTypeDefinition__aliases->setFeatureID(
            ::amalthea::AmaltheaPackage::BASETYPEDEFINITION__ALIASES);
    m_BaseTypeDefinitionEClass->getEStructuralFeatures().push_back(
            m_BaseTypeDefinition__aliases);

    // Activation
    {
        m_ActivationEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_ActivationEClass->setClassifierID(ACTIVATION);
        m_ActivationEClass->setEPackage(_this());
        getEClassifiers().push_back(m_ActivationEClass);
    }

    // PeriodicActivation
    {
        m_PeriodicActivationEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_PeriodicActivationEClass->setClassifierID(PERIODICACTIVATION);
        m_PeriodicActivationEClass->setEPackage(_this());
        getEClassifiers().push_back(m_PeriodicActivationEClass);
    }
    // m_PeriodicActivation__min has already been allocated above
    m_PeriodicActivation__min->setFeatureID(
            ::amalthea::AmaltheaPackage::PERIODICACTIVATION__MIN);
    m_PeriodicActivationEClass->getEStructuralFeatures().push_back(
            m_PeriodicActivation__min);
    // m_PeriodicActivation__max has already been allocated above
    m_PeriodicActivation__max->setFeatureID(
            ::amalthea::AmaltheaPackage::PERIODICACTIVATION__MAX);
    m_PeriodicActivationEClass->getEStructuralFeatures().push_back(
            m_PeriodicActivation__max);
    // m_PeriodicActivation__recurrence has already been allocated above
    m_PeriodicActivation__recurrence->setFeatureID(
            ::amalthea::AmaltheaPackage::PERIODICACTIVATION__RECURRENCE);
    m_PeriodicActivationEClass->getEStructuralFeatures().push_back(
            m_PeriodicActivation__recurrence);
    // m_PeriodicActivation__offset has already been allocated above
    m_PeriodicActivation__offset->setFeatureID(
            ::amalthea::AmaltheaPackage::PERIODICACTIVATION__OFFSET);
    m_PeriodicActivationEClass->getEStructuralFeatures().push_back(
            m_PeriodicActivation__offset);

    // VariableRateActivation
    {
        m_VariableRateActivationEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_VariableRateActivationEClass->setClassifierID(VARIABLERATEACTIVATION);
        m_VariableRateActivationEClass->setEPackage(_this());
        getEClassifiers().push_back(m_VariableRateActivationEClass);
    }
    // m_VariableRateActivation__step has already been allocated above
    m_VariableRateActivation__step->setFeatureID(
            ::amalthea::AmaltheaPackage::VARIABLERATEACTIVATION__STEP);
    m_VariableRateActivationEClass->getEStructuralFeatures().push_back(
            m_VariableRateActivation__step);
    // m_VariableRateActivation__occurrencesPerStep has already been allocated above
    m_VariableRateActivation__occurrencesPerStep->setFeatureID(
            ::amalthea::AmaltheaPackage::VARIABLERATEACTIVATION__OCCURRENCESPERSTEP);
    m_VariableRateActivationEClass->getEStructuralFeatures().push_back(
            m_VariableRateActivation__occurrencesPerStep);

    // SporadicActivation
    {
        m_SporadicActivationEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_SporadicActivationEClass->setClassifierID(SPORADICACTIVATION);
        m_SporadicActivationEClass->setEPackage(_this());
        getEClassifiers().push_back(m_SporadicActivationEClass);
    }
    // m_SporadicActivation__occurrence has already been allocated above
    m_SporadicActivation__occurrence->setFeatureID(
            ::amalthea::AmaltheaPackage::SPORADICACTIVATION__OCCURRENCE);
    m_SporadicActivationEClass->getEStructuralFeatures().push_back(
            m_SporadicActivation__occurrence);

    // SingleActivation
    {
        m_SingleActivationEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_SingleActivationEClass->setClassifierID(SINGLEACTIVATION);
        m_SingleActivationEClass->setEPackage(_this());
        getEClassifiers().push_back(m_SingleActivationEClass);
    }
    // m_SingleActivation__min has already been allocated above
    m_SingleActivation__min->setFeatureID(
            ::amalthea::AmaltheaPackage::SINGLEACTIVATION__MIN);
    m_SingleActivationEClass->getEStructuralFeatures().push_back(
            m_SingleActivation__min);
    // m_SingleActivation__max has already been allocated above
    m_SingleActivation__max->setFeatureID(
            ::amalthea::AmaltheaPackage::SINGLEACTIVATION__MAX);
    m_SingleActivationEClass->getEStructuralFeatures().push_back(
            m_SingleActivation__max);

    // EventActivation
    {
        m_EventActivationEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_EventActivationEClass->setClassifierID(EVENTACTIVATION);
        m_EventActivationEClass->setEPackage(_this());
        getEClassifiers().push_back(m_EventActivationEClass);
    }
    // m_EventActivation__triggeringEvents has already been allocated above
    m_EventActivation__triggeringEvents->setFeatureID(
            ::amalthea::AmaltheaPackage::EVENTACTIVATION__TRIGGERINGEVENTS);
    m_EventActivationEClass->getEStructuralFeatures().push_back(
            m_EventActivation__triggeringEvents);
    // m_EventActivation__counter has already been allocated above
    m_EventActivation__counter->setFeatureID(
            ::amalthea::AmaltheaPackage::EVENTACTIVATION__COUNTER);
    m_EventActivationEClass->getEStructuralFeatures().push_back(
            m_EventActivation__counter);

    // CustomActivation
    {
        m_CustomActivationEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_CustomActivationEClass->setClassifierID(CUSTOMACTIVATION);
        m_CustomActivationEClass->setEPackage(_this());
        getEClassifiers().push_back(m_CustomActivationEClass);
    }

    // LabelAccessStatistic
    {
        m_LabelAccessStatisticEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_LabelAccessStatisticEClass->setClassifierID(LABELACCESSSTATISTIC);
        m_LabelAccessStatisticEClass->setEPackage(_this());
        getEClassifiers().push_back(m_LabelAccessStatisticEClass);
    }
    // m_LabelAccessStatistic__value has already been allocated above
    m_LabelAccessStatistic__value->setFeatureID(
            ::amalthea::AmaltheaPackage::LABELACCESSSTATISTIC__VALUE);
    m_LabelAccessStatisticEClass->getEStructuralFeatures().push_back(
            m_LabelAccessStatistic__value);
    // m_LabelAccessStatistic__cacheMisses has already been allocated above
    m_LabelAccessStatistic__cacheMisses->setFeatureID(
            ::amalthea::AmaltheaPackage::LABELACCESSSTATISTIC__CACHEMISSES);
    m_LabelAccessStatisticEClass->getEStructuralFeatures().push_back(
            m_LabelAccessStatistic__cacheMisses);

    // RunEntityCallStatistic
    {
        m_RunEntityCallStatisticEClass = ::ecore::Ptr < ::ecore::EClass
                > (new ::ecore::EClass);
        m_RunEntityCallStatisticEClass->setClassifierID(RUNENTITYCALLSTATISTIC);
        m_RunEntityCallStatisticEClass->setEPackage(_this());
        getEClassifiers().push_back(m_RunEntityCallStatisticEClass);
    }
    // m_RunEntityCallStatistic__statistic has already been allocated above
    m_RunEntityCallStatistic__statistic->setFeatureID(
            ::amalthea::AmaltheaPackage::RUNENTITYCALLSTATISTIC__STATISTIC);
    m_RunEntityCallStatisticEClass->getEStructuralFeatures().push_back(
            m_RunEntityCallStatistic__statistic);

    // Create enums

    {
        m_RelationalOperatorEEnum = ::ecore::Ptr < ::ecore::EEnum
                > (new ::ecore::EEnum);
        m_RelationalOperatorEEnum->setClassifierID(RELATIONALOPERATOR);
        m_RelationalOperatorEEnum->setEPackage(_this());
        getEClassifiers().push_back(m_RelationalOperatorEEnum);
    }

    {
        m_TimeUnitEEnum = ::ecore::Ptr < ::ecore::EEnum > (new ::ecore::EEnum);
        m_TimeUnitEEnum->setClassifierID(TIMEUNIT);
        m_TimeUnitEEnum->setEPackage(_this());
        getEClassifiers().push_back(m_TimeUnitEEnum);
    }

    {
        m_FrequencyUnitEEnum = ::ecore::Ptr < ::ecore::EEnum
                > (new ::ecore::EEnum);
        m_FrequencyUnitEEnum->setClassifierID(FREQUENCYUNIT);
        m_FrequencyUnitEEnum->setEPackage(_this());
        getEClassifiers().push_back(m_FrequencyUnitEEnum);
    }

    {
        m_VoltageUnitEEnum = ::ecore::Ptr < ::ecore::EEnum
                > (new ::ecore::EEnum);
        m_VoltageUnitEEnum->setClassifierID(VOLTAGEUNIT);
        m_VoltageUnitEEnum->setEPackage(_this());
        getEClassifiers().push_back(m_VoltageUnitEEnum);
    }

    {
        m_DataSizeUnitEEnum = ::ecore::Ptr < ::ecore::EEnum
                > (new ::ecore::EEnum);
        m_DataSizeUnitEEnum->setClassifierID(DATASIZEUNIT);
        m_DataSizeUnitEEnum->setEPackage(_this());
        getEClassifiers().push_back(m_DataSizeUnitEEnum);
    }

    {
        m_DataRateUnitEEnum = ::ecore::Ptr < ::ecore::EEnum
                > (new ::ecore::EEnum);
        m_DataRateUnitEEnum->setClassifierID(DATARATEUNIT);
        m_DataRateUnitEEnum->setEPackage(_this());
        getEClassifiers().push_back(m_DataRateUnitEEnum);
    }

    {
        m_SamplingTypeEEnum = ::ecore::Ptr < ::ecore::EEnum
                > (new ::ecore::EEnum);
        m_SamplingTypeEEnum->setClassifierID(SAMPLINGTYPE);
        m_SamplingTypeEEnum->setEPackage(_this());
        getEClassifiers().push_back(m_SamplingTypeEEnum);
    }

    {
        m_InterfaceKindEEnum = ::ecore::Ptr < ::ecore::EEnum
                > (new ::ecore::EEnum);
        m_InterfaceKindEEnum->setClassifierID(INTERFACEKIND);
        m_InterfaceKindEEnum->setEPackage(_this());
        getEClassifiers().push_back(m_InterfaceKindEEnum);
    }

    {
        m_RunnableOrderTypeEEnum = ::ecore::Ptr < ::ecore::EEnum
                > (new ::ecore::EEnum);
        m_RunnableOrderTypeEEnum->setClassifierID(RUNNABLEORDERTYPE);
        m_RunnableOrderTypeEEnum->setEPackage(_this());
        getEClassifiers().push_back(m_RunnableOrderTypeEEnum);
    }

    {
        m_EventChainItemTypeEEnum = ::ecore::Ptr < ::ecore::EEnum
                > (new ::ecore::EEnum);
        m_EventChainItemTypeEEnum->setClassifierID(EVENTCHAINITEMTYPE);
        m_EventChainItemTypeEEnum->setEPackage(_this());
        getEClassifiers().push_back(m_EventChainItemTypeEEnum);
    }

    {
        m_SynchronizationTypeEEnum = ::ecore::Ptr < ::ecore::EEnum
                > (new ::ecore::EEnum);
        m_SynchronizationTypeEEnum->setClassifierID(SYNCHRONIZATIONTYPE);
        m_SynchronizationTypeEEnum->setEPackage(_this());
        getEClassifiers().push_back(m_SynchronizationTypeEEnum);
    }

    {
        m_MappingTypeEEnum = ::ecore::Ptr < ::ecore::EEnum
                > (new ::ecore::EEnum);
        m_MappingTypeEEnum->setClassifierID(MAPPINGTYPE);
        m_MappingTypeEEnum->setEPackage(_this());
        getEClassifiers().push_back(m_MappingTypeEEnum);
    }

    {
        m_LatencyTypeEEnum = ::ecore::Ptr < ::ecore::EEnum
                > (new ::ecore::EEnum);
        m_LatencyTypeEEnum->setClassifierID(LATENCYTYPE);
        m_LatencyTypeEEnum->setEPackage(_this());
        getEClassifiers().push_back(m_LatencyTypeEEnum);
    }

    {
        m_SeverityEEnum = ::ecore::Ptr < ::ecore::EEnum > (new ::ecore::EEnum);
        m_SeverityEEnum->setClassifierID(SEVERITY);
        m_SeverityEEnum->setEPackage(_this());
        getEClassifiers().push_back(m_SeverityEEnum);
    }

    {
        m_LimitTypeEEnum = ::ecore::Ptr < ::ecore::EEnum > (new ::ecore::EEnum);
        m_LimitTypeEEnum->setClassifierID(LIMITTYPE);
        m_LimitTypeEEnum->setEPackage(_this());
        getEClassifiers().push_back(m_LimitTypeEEnum);
    }

    {
        m_TimeMetricEEnum = ::ecore::Ptr < ::ecore::EEnum
                > (new ::ecore::EEnum);
        m_TimeMetricEEnum->setClassifierID(TIMEMETRIC);
        m_TimeMetricEEnum->setEPackage(_this());
        getEClassifiers().push_back(m_TimeMetricEEnum);
    }

    {
        m_CountMetricEEnum = ::ecore::Ptr < ::ecore::EEnum
                > (new ::ecore::EEnum);
        m_CountMetricEEnum->setClassifierID(COUNTMETRIC);
        m_CountMetricEEnum->setEPackage(_this());
        getEClassifiers().push_back(m_CountMetricEEnum);
    }

    {
        m_PercentageMetricEEnum = ::ecore::Ptr < ::ecore::EEnum
                > (new ::ecore::EEnum);
        m_PercentageMetricEEnum->setClassifierID(PERCENTAGEMETRIC);
        m_PercentageMetricEEnum->setEPackage(_this());
        getEClassifiers().push_back(m_PercentageMetricEEnum);
    }

    {
        m_CPUPercentageMetricEEnum = ::ecore::Ptr < ::ecore::EEnum
                > (new ::ecore::EEnum);
        m_CPUPercentageMetricEEnum->setClassifierID(CPUPERCENTAGEMETRIC);
        m_CPUPercentageMetricEEnum->setEPackage(_this());
        getEClassifiers().push_back(m_CPUPercentageMetricEEnum);
    }

    {
        m_FrequencyMetricEEnum = ::ecore::Ptr < ::ecore::EEnum
                > (new ::ecore::EEnum);
        m_FrequencyMetricEEnum->setClassifierID(FREQUENCYMETRIC);
        m_FrequencyMetricEEnum->setEPackage(_this());
        getEClassifiers().push_back(m_FrequencyMetricEEnum);
    }

    {
        m_CoherencyDirectionEEnum = ::ecore::Ptr < ::ecore::EEnum
                > (new ::ecore::EEnum);
        m_CoherencyDirectionEEnum->setClassifierID(COHERENCYDIRECTION);
        m_CoherencyDirectionEEnum->setEPackage(_this());
        getEClassifiers().push_back(m_CoherencyDirectionEEnum);
    }

    {
        m_ProcessEventTypeEEnum = ::ecore::Ptr < ::ecore::EEnum
                > (new ::ecore::EEnum);
        m_ProcessEventTypeEEnum->setClassifierID(PROCESSEVENTTYPE);
        m_ProcessEventTypeEEnum->setEPackage(_this());
        getEClassifiers().push_back(m_ProcessEventTypeEEnum);
    }

    {
        m_RunnableEventTypeEEnum = ::ecore::Ptr < ::ecore::EEnum
                > (new ::ecore::EEnum);
        m_RunnableEventTypeEEnum->setClassifierID(RUNNABLEEVENTTYPE);
        m_RunnableEventTypeEEnum->setEPackage(_this());
        getEClassifiers().push_back(m_RunnableEventTypeEEnum);
    }

    {
        m_LabelEventTypeEEnum = ::ecore::Ptr < ::ecore::EEnum
                > (new ::ecore::EEnum);
        m_LabelEventTypeEEnum->setClassifierID(LABELEVENTTYPE);
        m_LabelEventTypeEEnum->setEPackage(_this());
        getEClassifiers().push_back(m_LabelEventTypeEEnum);
    }

    {
        m_ChannelEventTypeEEnum = ::ecore::Ptr < ::ecore::EEnum
                > (new ::ecore::EEnum);
        m_ChannelEventTypeEEnum->setClassifierID(CHANNELEVENTTYPE);
        m_ChannelEventTypeEEnum->setEPackage(_this());
        getEClassifiers().push_back(m_ChannelEventTypeEEnum);
    }

    {
        m_SemaphoreEventTypeEEnum = ::ecore::Ptr < ::ecore::EEnum
                > (new ::ecore::EEnum);
        m_SemaphoreEventTypeEEnum->setClassifierID(SEMAPHOREEVENTTYPE);
        m_SemaphoreEventTypeEEnum->setEPackage(_this());
        getEClassifiers().push_back(m_SemaphoreEventTypeEEnum);
    }

    {
        m_ComponentEventTypeEEnum = ::ecore::Ptr < ::ecore::EEnum
                > (new ::ecore::EEnum);
        m_ComponentEventTypeEEnum->setClassifierID(COMPONENTEVENTTYPE);
        m_ComponentEventTypeEEnum->setEPackage(_this());
        getEClassifiers().push_back(m_ComponentEventTypeEEnum);
    }

    {
        m_MemoryTypeEEnum = ::ecore::Ptr < ::ecore::EEnum
                > (new ::ecore::EEnum);
        m_MemoryTypeEEnum->setClassifierID(MEMORYTYPE);
        m_MemoryTypeEEnum->setEPackage(_this());
        getEClassifiers().push_back(m_MemoryTypeEEnum);
    }

    {
        m_StructureTypeEEnum = ::ecore::Ptr < ::ecore::EEnum
                > (new ::ecore::EEnum);
        m_StructureTypeEEnum->setClassifierID(STRUCTURETYPE);
        m_StructureTypeEEnum->setEPackage(_this());
        getEClassifiers().push_back(m_StructureTypeEEnum);
    }

    {
        m_CacheTypeEEnum = ::ecore::Ptr < ::ecore::EEnum > (new ::ecore::EEnum);
        m_CacheTypeEEnum->setClassifierID(CACHETYPE);
        m_CacheTypeEEnum->setEPackage(_this());
        getEClassifiers().push_back(m_CacheTypeEEnum);
    }

    {
        m_PortTypeEEnum = ::ecore::Ptr < ::ecore::EEnum > (new ::ecore::EEnum);
        m_PortTypeEEnum->setClassifierID(PORTTYPE);
        m_PortTypeEEnum->setEPackage(_this());
        getEClassifiers().push_back(m_PortTypeEEnum);
    }

    {
        m_SchedPolicyEEnum = ::ecore::Ptr < ::ecore::EEnum
                > (new ::ecore::EEnum);
        m_SchedPolicyEEnum->setClassifierID(SCHEDPOLICY);
        m_SchedPolicyEEnum->setEPackage(_this());
        getEClassifiers().push_back(m_SchedPolicyEEnum);
    }

    {
        m_WriteStrategyEEnum = ::ecore::Ptr < ::ecore::EEnum
                > (new ::ecore::EEnum);
        m_WriteStrategyEEnum->setClassifierID(WRITESTRATEGY);
        m_WriteStrategyEEnum->setEPackage(_this());
        getEClassifiers().push_back(m_WriteStrategyEEnum);
    }

    {
        m_PuTypeEEnum = ::ecore::Ptr < ::ecore::EEnum > (new ::ecore::EEnum);
        m_PuTypeEEnum->setClassifierID(PUTYPE);
        m_PuTypeEEnum->setEPackage(_this());
        getEClassifiers().push_back(m_PuTypeEEnum);
    }

    {
        m_PortInterfaceEEnum = ::ecore::Ptr < ::ecore::EEnum
                > (new ::ecore::EEnum);
        m_PortInterfaceEEnum->setClassifierID(PORTINTERFACE);
        m_PortInterfaceEEnum->setEPackage(_this());
        getEClassifiers().push_back(m_PortInterfaceEEnum);
    }

    {
        m_HwFeatureTypeEEnum = ::ecore::Ptr < ::ecore::EEnum
                > (new ::ecore::EEnum);
        m_HwFeatureTypeEEnum->setClassifierID(HWFEATURETYPE);
        m_HwFeatureTypeEEnum->setEPackage(_this());
        getEClassifiers().push_back(m_HwFeatureTypeEEnum);
    }

    {
        m_MemoryAddressMappingTypeEEnum = ::ecore::Ptr < ::ecore::EEnum
                > (new ::ecore::EEnum);
        m_MemoryAddressMappingTypeEEnum->setClassifierID(
                MEMORYADDRESSMAPPINGTYPE);
        m_MemoryAddressMappingTypeEEnum->setEPackage(_this());
        getEClassifiers().push_back(m_MemoryAddressMappingTypeEEnum);
    }

    {
        m_OsDataConsistencyModeEEnum = ::ecore::Ptr < ::ecore::EEnum
                > (new ::ecore::EEnum);
        m_OsDataConsistencyModeEEnum->setClassifierID(OSDATACONSISTENCYMODE);
        m_OsDataConsistencyModeEEnum->setEPackage(_this());
        getEClassifiers().push_back(m_OsDataConsistencyModeEEnum);
    }

    {
        m_AccessMultiplicityEEnum = ::ecore::Ptr < ::ecore::EEnum
                > (new ::ecore::EEnum);
        m_AccessMultiplicityEEnum->setClassifierID(ACCESSMULTIPLICITY);
        m_AccessMultiplicityEEnum->setEPackage(_this());
        getEClassifiers().push_back(m_AccessMultiplicityEEnum);
    }

    {
        m_DataStabilityLevelEEnum = ::ecore::Ptr < ::ecore::EEnum
                > (new ::ecore::EEnum);
        m_DataStabilityLevelEEnum->setClassifierID(DATASTABILITYLEVEL);
        m_DataStabilityLevelEEnum->setEPackage(_this());
        getEClassifiers().push_back(m_DataStabilityLevelEEnum);
    }

    {
        m_SemaphoreTypeEEnum = ::ecore::Ptr < ::ecore::EEnum
                > (new ::ecore::EEnum);
        m_SemaphoreTypeEEnum->setClassifierID(SEMAPHORETYPE);
        m_SemaphoreTypeEEnum->setEPackage(_this());
        getEClassifiers().push_back(m_SemaphoreTypeEEnum);
    }

    {
        m_ConditionEEnum = ::ecore::Ptr < ::ecore::EEnum > (new ::ecore::EEnum);
        m_ConditionEEnum->setClassifierID(CONDITION);
        m_ConditionEEnum->setEPackage(_this());
        getEClassifiers().push_back(m_ConditionEEnum);
    }

    {
        m_GroupingTypeEEnum = ::ecore::Ptr < ::ecore::EEnum
                > (new ::ecore::EEnum);
        m_GroupingTypeEEnum->setClassifierID(GROUPINGTYPE);
        m_GroupingTypeEEnum->setEPackage(_this());
        getEClassifiers().push_back(m_GroupingTypeEEnum);
    }

    {
        m_CurveTypeEEnum = ::ecore::Ptr < ::ecore::EEnum > (new ::ecore::EEnum);
        m_CurveTypeEEnum->setClassifierID(CURVETYPE);
        m_CurveTypeEEnum->setEPackage(_this());
        getEClassifiers().push_back(m_CurveTypeEEnum);
    }

    {
        m_WaitEventTypeEEnum = ::ecore::Ptr < ::ecore::EEnum
                > (new ::ecore::EEnum);
        m_WaitEventTypeEEnum->setClassifierID(WAITEVENTTYPE);
        m_WaitEventTypeEEnum->setEPackage(_this());
        getEClassifiers().push_back(m_WaitEventTypeEEnum);
    }

    {
        m_WaitingBehaviourEEnum = ::ecore::Ptr < ::ecore::EEnum
                > (new ::ecore::EEnum);
        m_WaitingBehaviourEEnum->setClassifierID(WAITINGBEHAVIOUR);
        m_WaitingBehaviourEEnum->setEPackage(_this());
        getEClassifiers().push_back(m_WaitingBehaviourEEnum);
    }

    {
        m_ISRCategoryEEnum = ::ecore::Ptr < ::ecore::EEnum
                > (new ::ecore::EEnum);
        m_ISRCategoryEEnum->setClassifierID(ISRCATEGORY);
        m_ISRCategoryEEnum->setEPackage(_this());
        getEClassifiers().push_back(m_ISRCategoryEEnum);
    }

    {
        m_AccessPrecedenceTypeEEnum = ::ecore::Ptr < ::ecore::EEnum
                > (new ::ecore::EEnum);
        m_AccessPrecedenceTypeEEnum->setClassifierID(ACCESSPRECEDENCETYPE);
        m_AccessPrecedenceTypeEEnum->setEPackage(_this());
        getEClassifiers().push_back(m_AccessPrecedenceTypeEEnum);
    }

    {
        m_OrderTypeEEnum = ::ecore::Ptr < ::ecore::EEnum > (new ::ecore::EEnum);
        m_OrderTypeEEnum->setClassifierID(ORDERTYPE);
        m_OrderTypeEEnum->setEPackage(_this());
        getEClassifiers().push_back(m_OrderTypeEEnum);
    }

    {
        m_DirectionTypeEEnum = ::ecore::Ptr < ::ecore::EEnum
                > (new ::ecore::EEnum);
        m_DirectionTypeEEnum->setClassifierID(DIRECTIONTYPE);
        m_DirectionTypeEEnum->setEPackage(_this());
        getEClassifiers().push_back(m_DirectionTypeEEnum);
    }

    {
        m_LabelDataStabilityEEnum = ::ecore::Ptr < ::ecore::EEnum
                > (new ::ecore::EEnum);
        m_LabelDataStabilityEEnum->setClassifierID(LABELDATASTABILITY);
        m_LabelDataStabilityEEnum->setEPackage(_this());
        getEClassifiers().push_back(m_LabelDataStabilityEEnum);
    }

    {
        m_ModeLabelAccessEnumEEnum = ::ecore::Ptr < ::ecore::EEnum
                > (new ::ecore::EEnum);
        m_ModeLabelAccessEnumEEnum->setClassifierID(MODELABELACCESSENUM);
        m_ModeLabelAccessEnumEEnum->setEPackage(_this());
        getEClassifiers().push_back(m_ModeLabelAccessEnumEEnum);
    }

    {
        m_ReceiveOperationEEnum = ::ecore::Ptr < ::ecore::EEnum
                > (new ::ecore::EEnum);
        m_ReceiveOperationEEnum->setClassifierID(RECEIVEOPERATION);
        m_ReceiveOperationEEnum->setEPackage(_this());
        getEClassifiers().push_back(m_ReceiveOperationEEnum);
    }

    {
        m_LabelAccessDataStabilityEEnum = ::ecore::Ptr < ::ecore::EEnum
                > (new ::ecore::EEnum);
        m_LabelAccessDataStabilityEEnum->setClassifierID(
                LABELACCESSDATASTABILITY);
        m_LabelAccessDataStabilityEEnum->setEPackage(_this());
        getEClassifiers().push_back(m_LabelAccessDataStabilityEEnum);
    }

    {
        m_LabelAccessEnumEEnum = ::ecore::Ptr < ::ecore::EEnum
                > (new ::ecore::EEnum);
        m_LabelAccessEnumEEnum->setClassifierID(LABELACCESSENUM);
        m_LabelAccessEnumEEnum->setEPackage(_this());
        getEClassifiers().push_back(m_LabelAccessEnumEEnum);
    }

    {
        m_LabelAccessImplementationEEnum = ::ecore::Ptr < ::ecore::EEnum
                > (new ::ecore::EEnum);
        m_LabelAccessImplementationEEnum->setClassifierID(
                LABELACCESSIMPLEMENTATION);
        m_LabelAccessImplementationEEnum->setEPackage(_this());
        getEClassifiers().push_back(m_LabelAccessImplementationEEnum);
    }

    {
        m_SemaphoreAccessEnumEEnum = ::ecore::Ptr < ::ecore::EEnum
                > (new ::ecore::EEnum);
        m_SemaphoreAccessEnumEEnum->setClassifierID(SEMAPHOREACCESSENUM);
        m_SemaphoreAccessEnumEEnum->setEPackage(_this());
        getEClassifiers().push_back(m_SemaphoreAccessEnumEEnum);
    }

    {
        m_BlockingTypeEEnum = ::ecore::Ptr < ::ecore::EEnum
                > (new ::ecore::EEnum);
        m_BlockingTypeEEnum->setClassifierID(BLOCKINGTYPE);
        m_BlockingTypeEEnum->setEPackage(_this());
        getEClassifiers().push_back(m_BlockingTypeEEnum);
    }

    {
        m_PreemptionEEnum = ::ecore::Ptr < ::ecore::EEnum
                > (new ::ecore::EEnum);
        m_PreemptionEEnum->setClassifierID(PREEMPTION);
        m_PreemptionEEnum->setEPackage(_this());
        getEClassifiers().push_back(m_PreemptionEEnum);
    }

    {
        m_ConcurrencyTypeEEnum = ::ecore::Ptr < ::ecore::EEnum
                > (new ::ecore::EEnum);
        m_ConcurrencyTypeEEnum->setClassifierID(CONCURRENCYTYPE);
        m_ConcurrencyTypeEEnum->setEPackage(_this());
        getEClassifiers().push_back(m_ConcurrencyTypeEEnum);
    }

    {
        m_ASILTypeEEnum = ::ecore::Ptr < ::ecore::EEnum > (new ::ecore::EEnum);
        m_ASILTypeEEnum->setClassifierID(ASILTYPE);
        m_ASILTypeEEnum->setEPackage(_this());
        getEClassifiers().push_back(m_ASILTypeEEnum);
    }

    // Create data types

    {
        m_AddressEDataType = ::ecore::Ptr < ::ecore::EDataType
                > (new ::ecore::EDataType);
        m_AddressEDataType->setClassifierID(ADDRESS);
        m_AddressEDataType->setEPackage(_this());
        getEClassifiers().push_back(m_AddressEDataType);
    }

    {
        m_PositiveIntEDataType = ::ecore::Ptr < ::ecore::EDataType
                > (new ::ecore::EDataType);
        m_PositiveIntEDataType->setClassifierID(POSITIVEINT);
        m_PositiveIntEDataType->setEPackage(_this());
        getEClassifiers().push_back(m_PositiveIntEDataType);
    }

    {
        m_PositiveLongEDataType = ::ecore::Ptr < ::ecore::EDataType
                > (new ::ecore::EDataType);
        m_PositiveLongEDataType->setClassifierID(POSITIVELONG);
        m_PositiveLongEDataType->setEPackage(_this());
        getEClassifiers().push_back(m_PositiveLongEDataType);
    }

    {
        m_PositiveDoubleEDataType = ::ecore::Ptr < ::ecore::EDataType
                > (new ::ecore::EDataType);
        m_PositiveDoubleEDataType->setClassifierID(POSITIVEDOUBLE);
        m_PositiveDoubleEDataType->setEPackage(_this());
        getEClassifiers().push_back(m_PositiveDoubleEDataType);
    }

    {
        m_NonNegativeIntEDataType = ::ecore::Ptr < ::ecore::EDataType
                > (new ::ecore::EDataType);
        m_NonNegativeIntEDataType->setClassifierID(NONNEGATIVEINT);
        m_NonNegativeIntEDataType->setEPackage(_this());
        getEClassifiers().push_back(m_NonNegativeIntEDataType);
    }

    {
        m_NonNegativeLongEDataType = ::ecore::Ptr < ::ecore::EDataType
                > (new ::ecore::EDataType);
        m_NonNegativeLongEDataType->setClassifierID(NONNEGATIVELONG);
        m_NonNegativeLongEDataType->setEPackage(_this());
        getEClassifiers().push_back(m_NonNegativeLongEDataType);
    }

    {
        m_NonNegativeDoubleEDataType = ::ecore::Ptr < ::ecore::EDataType
                > (new ::ecore::EDataType);
        m_NonNegativeDoubleEDataType->setClassifierID(NONNEGATIVEDOUBLE);
        m_NonNegativeDoubleEDataType->setEPackage(_this());
        getEClassifiers().push_back(m_NonNegativeDoubleEDataType);
    }

    // Initialize package
    setName("amalthea");
    setNsPrefix("am");
    setNsURI("http://app4mc.eclipse.org/amalthea/1.0.0");

    // TODO: bounds for type parameters

    // Add supertypes to classes
    m_AmaltheaEClass->getESuperTypes().push_back(m_BaseObjectEClass);
    m_CommonElementsEClass->getESuperTypes().push_back(m_BaseObjectEClass);
    m_BaseObjectEClass->getESuperTypes().push_back(m_IAnnotatableEClass);
    m_ReferableObjectEClass->getESuperTypes().push_back(m_IReferableEClass);
    m_ReferableBaseObjectEClass->getESuperTypes().push_back(
            m_IAnnotatableEClass);
    m_ReferableBaseObjectEClass->getESuperTypes().push_back(m_IReferableEClass);
    m_IReferableEClass->getESuperTypes().push_back(m_INamedEClass);
    m_TagEClass->getESuperTypes().push_back(m_ReferableBaseObjectEClass);
    m_TagEClass->getESuperTypes().push_back(m_IDescriptionEClass);
    m_NamespaceEClass->getESuperTypes().push_back(m_ReferableObjectEClass);
    m_ClassifierEClass->getESuperTypes().push_back(m_ReferableBaseObjectEClass);
    m_ClassifierEClass->getESuperTypes().push_back(m_IDescriptionEClass);
    m_CoreClassifierEClass->getESuperTypes().push_back(m_ClassifierEClass);
    m_MemoryClassifierEClass->getESuperTypes().push_back(m_ClassifierEClass);
    m_TimeEClass->getESuperTypes().push_back(m_QuantityEClass);
    m_TimeEClass->getESuperTypes().push_back(m_ValueEClass);
    m_TimeEClass->getESuperTypes().push_back(m_TimeComparableEClass);
    m_FrequencyEClass->getESuperTypes().push_back(m_QuantityEClass);
    m_VoltageEClass->getESuperTypes().push_back(m_QuantityEClass);
    m_DataSizeEClass->getESuperTypes().push_back(m_QuantityEClass);
    m_DataRateEClass->getESuperTypes().push_back(m_QuantityEClass);
    m_DataRateEClass->getESuperTypes().push_back(m_DataRateComparableEClass);
    m_ListObjectEClass->getESuperTypes().push_back(m_ValueEClass);
    m_StringObjectEClass->getESuperTypes().push_back(m_ValueEClass);
    m_BigIntegerObjectEClass->getESuperTypes().push_back(m_ValueEClass);
    m_ReferenceObjectEClass->getESuperTypes().push_back(m_ValueEClass);
    m_IntegerObjectEClass->getESuperTypes().push_back(m_ValueEClass);
    m_LongObjectEClass->getESuperTypes().push_back(m_ValueEClass);
    m_FloatObjectEClass->getESuperTypes().push_back(m_ValueEClass);
    m_DoubleObjectEClass->getESuperTypes().push_back(m_ValueEClass);
    m_BooleanObjectEClass->getESuperTypes().push_back(m_ValueEClass);
    m_MinAvgMaxStatisticEClass->getESuperTypes().push_back(
            m_NumericStatisticEClass);
    m_SingleValueStatisticEClass->getESuperTypes().push_back(
            m_NumericStatisticEClass);
    m_TimeConstantEClass->getESuperTypes().push_back(m_ITimeDeviationEClass);
    m_TimeHistogramEClass->getESuperTypes().push_back(m_ITimeDeviationEClass);
    m_TimeHistogramEntryEClass->getESuperTypes().push_back(
            m_TimeIntervalEClass);
    m_BoundedTimeDistributionEClass->getESuperTypes().push_back(
            m_TimeIntervalEClass);
    m_BoundedTimeDistributionEClass->getESuperTypes().push_back(
            m_ITimeDeviationEClass);
    m_TruncatedTimeDistributionEClass->getESuperTypes().push_back(
            m_ITimeDeviationEClass);
    m_TimeBoundariesEClass->getESuperTypes().push_back(
            m_BoundedTimeDistributionEClass);
    m_TimeStatisticsEClass->getESuperTypes().push_back(
            m_BoundedTimeDistributionEClass);
    m_TimeUniformDistributionEClass->getESuperTypes().push_back(
            m_BoundedTimeDistributionEClass);
    m_TimeGaussDistributionEClass->getESuperTypes().push_back(
            m_TruncatedTimeDistributionEClass);
    m_TimeWeibullEstimatorsDistributionEClass->getESuperTypes().push_back(
            m_BoundedTimeDistributionEClass);
    m_TimeBetaDistributionEClass->getESuperTypes().push_back(
            m_BoundedTimeDistributionEClass);
    m_DiscreteValueConstantEClass->getESuperTypes().push_back(
            m_IDiscreteValueDeviationEClass);
    m_DiscreteValueHistogramEClass->getESuperTypes().push_back(
            m_IDiscreteValueDeviationEClass);
    m_DiscreteValueHistogramEntryEClass->getESuperTypes().push_back(
            m_DiscreteValueIntervalEClass);
    m_BoundedDiscreteValueDistributionEClass->getESuperTypes().push_back(
            m_DiscreteValueIntervalEClass);
    m_BoundedDiscreteValueDistributionEClass->getESuperTypes().push_back(
            m_IDiscreteValueDeviationEClass);
    m_TruncatedDiscreteValueDistributionEClass->getESuperTypes().push_back(
            m_IDiscreteValueDeviationEClass);
    m_DiscreteValueBoundariesEClass->getESuperTypes().push_back(
            m_BoundedDiscreteValueDistributionEClass);
    m_DiscreteValueStatisticsEClass->getESuperTypes().push_back(
            m_BoundedDiscreteValueDistributionEClass);
    m_DiscreteValueUniformDistributionEClass->getESuperTypes().push_back(
            m_BoundedDiscreteValueDistributionEClass);
    m_DiscreteValueGaussDistributionEClass->getESuperTypes().push_back(
            m_TruncatedDiscreteValueDistributionEClass);
    m_DiscreteValueWeibullEstimatorsDistributionEClass->getESuperTypes().push_back(
            m_BoundedDiscreteValueDistributionEClass);
    m_DiscreteValueBetaDistributionEClass->getESuperTypes().push_back(
            m_BoundedDiscreteValueDistributionEClass);
    m_ContinuousValueConstantEClass->getESuperTypes().push_back(
            m_IContinuousValueDeviationEClass);
    m_ContinuousValueHistogramEClass->getESuperTypes().push_back(
            m_IContinuousValueDeviationEClass);
    m_ContinuousValueHistogramEntryEClass->getESuperTypes().push_back(
            m_ContinuousValueIntervalEClass);
    m_BoundedContinuousValueDistributionEClass->getESuperTypes().push_back(
            m_ContinuousValueIntervalEClass);
    m_BoundedContinuousValueDistributionEClass->getESuperTypes().push_back(
            m_IContinuousValueDeviationEClass);
    m_TruncatedContinuousValueDistributionEClass->getESuperTypes().push_back(
            m_IContinuousValueDeviationEClass);
    m_ContinuousValueBoundariesEClass->getESuperTypes().push_back(
            m_BoundedContinuousValueDistributionEClass);
    m_ContinuousValueStatisticsEClass->getESuperTypes().push_back(
            m_BoundedContinuousValueDistributionEClass);
    m_ContinuousValueUniformDistributionEClass->getESuperTypes().push_back(
            m_BoundedContinuousValueDistributionEClass);
    m_ContinuousValueGaussDistributionEClass->getESuperTypes().push_back(
            m_TruncatedContinuousValueDistributionEClass);
    m_ContinuousValueWeibullEstimatorsDistributionEClass->getESuperTypes().push_back(
            m_BoundedContinuousValueDistributionEClass);
    m_ContinuousValueBetaDistributionEClass->getESuperTypes().push_back(
            m_BoundedContinuousValueDistributionEClass);
    m_ModeEClass->getESuperTypes().push_back(m_ReferableBaseObjectEClass);
    m_NumericModeEClass->getESuperTypes().push_back(m_ModeEClass);
    m_EnumModeEClass->getESuperTypes().push_back(m_ModeEClass);
    m_ModeLiteralEClass->getESuperTypes().push_back(
            m_ReferableBaseObjectEClass);
    m_ComponentsModelEClass->getESuperTypes().push_back(m_BaseObjectEClass);
    m_ComponentsModelEClass->getESuperTypes().push_back(
            m_IComponentContainerEClass);
    m_ComponentsModelEClass->getESuperTypes().push_back(
            m_IInterfaceContainerEClass);
    m_ComponentInterfaceEClass->getESuperTypes().push_back(
            m_ReferableBaseObjectEClass);
    m_ComponentInterfaceEClass->getESuperTypes().push_back(m_ITaggableEClass);
    m_MainInterfaceEClass->getESuperTypes().push_back(
            m_ComponentInterfaceEClass);
    m_MainInterfaceEClass->getESuperTypes().push_back(m_INamespaceMemberEClass);
    m_MainInterfaceEClass->getESuperTypes().push_back(
            m_IComponentStructureMemberEClass);
    m_SubInterfaceEClass->getESuperTypes().push_back(
            m_ComponentInterfaceEClass);
    m_ComponentPortEClass->getESuperTypes().push_back(
            m_ReferableBaseObjectEClass);
    m_ComponentPortEClass->getESuperTypes().push_back(m_ITaggableEClass);
    m_ComponentStructureEClass->getESuperTypes().push_back(
            m_ReferableObjectEClass);
    m_ComponentEClass->getESuperTypes().push_back(m_ReferableBaseObjectEClass);
    m_ComponentEClass->getESuperTypes().push_back(m_ITaggableEClass);
    m_ComponentEClass->getESuperTypes().push_back(m_INamespaceMemberEClass);
    m_ComponentEClass->getESuperTypes().push_back(
            m_IComponentStructureMemberEClass);
    m_CompositeEClass->getESuperTypes().push_back(m_ComponentEClass);
    m_CompositeEClass->getESuperTypes().push_back(m_ISystemEClass);
    m_SystemEClass->getESuperTypes().push_back(m_ReferableBaseObjectEClass);
    m_SystemEClass->getESuperTypes().push_back(m_ITaggableEClass);
    m_SystemEClass->getESuperTypes().push_back(m_ISystemEClass);
    m_ComponentInstanceEClass->getESuperTypes().push_back(
            m_ReferableBaseObjectEClass);
    m_ComponentInstanceEClass->getESuperTypes().push_back(m_ITaggableEClass);
    m_ConnectorEClass->getESuperTypes().push_back(m_BaseObjectEClass);
    m_ConnectorEClass->getESuperTypes().push_back(m_INamedEClass);
    m_ConnectorEClass->getESuperTypes().push_back(m_ITaggableEClass);
    m_QualifiedPortEClass->getESuperTypes().push_back(m_BaseObjectEClass);
    m_ConfigModelEClass->getESuperTypes().push_back(m_BaseObjectEClass);
    m_EventConfigEClass->getESuperTypes().push_back(m_BaseObjectEClass);
    m_EventConfigEClass->getESuperTypes().push_back(m_INamedEClass);
    m_ConstraintsModelEClass->getESuperTypes().push_back(m_BaseObjectEClass);
    m_RunnableSequencingConstraintEClass->getESuperTypes().push_back(
            m_ReferableBaseObjectEClass);
    m_AffinityConstraintEClass->getESuperTypes().push_back(
            m_ReferableBaseObjectEClass);
    m_SeparationConstraintEClass->getESuperTypes().push_back(
            m_AffinityConstraintEClass);
    m_PairingConstraintEClass->getESuperTypes().push_back(
            m_AffinityConstraintEClass);
    m_RunnableSeparationConstraintEClass->getESuperTypes().push_back(
            m_SeparationConstraintEClass);
    m_RunnableSeparationConstraintEClass->getESuperTypes().push_back(
            m_RunnableConstraintEClass);
    m_RunnableSeparationConstraintEClass->getESuperTypes().push_back(
            m_BaseObjectEClass);
    m_ProcessSeparationConstraintEClass->getESuperTypes().push_back(
            m_SeparationConstraintEClass);
    m_ProcessSeparationConstraintEClass->getESuperTypes().push_back(
            m_ProcessConstraintEClass);
    m_ProcessSeparationConstraintEClass->getESuperTypes().push_back(
            m_BaseObjectEClass);
    m_DataSeparationConstraintEClass->getESuperTypes().push_back(
            m_SeparationConstraintEClass);
    m_DataSeparationConstraintEClass->getESuperTypes().push_back(
            m_DataConstraintEClass);
    m_DataSeparationConstraintEClass->getESuperTypes().push_back(
            m_BaseObjectEClass);
    m_RunnablePairingConstraintEClass->getESuperTypes().push_back(
            m_PairingConstraintEClass);
    m_RunnablePairingConstraintEClass->getESuperTypes().push_back(
            m_RunnableConstraintEClass);
    m_RunnablePairingConstraintEClass->getESuperTypes().push_back(
            m_BaseObjectEClass);
    m_ProcessPairingConstraintEClass->getESuperTypes().push_back(
            m_PairingConstraintEClass);
    m_ProcessPairingConstraintEClass->getESuperTypes().push_back(
            m_ProcessConstraintEClass);
    m_ProcessPairingConstraintEClass->getESuperTypes().push_back(
            m_BaseObjectEClass);
    m_DataPairingConstraintEClass->getESuperTypes().push_back(
            m_PairingConstraintEClass);
    m_DataPairingConstraintEClass->getESuperTypes().push_back(
            m_DataConstraintEClass);
    m_DataPairingConstraintEClass->getESuperTypes().push_back(
            m_BaseObjectEClass);
    m_TargetMemoryEClass->getESuperTypes().push_back(
            m_DataConstraintTargetEClass);
    m_TargetMemoryEClass->getESuperTypes().push_back(m_BaseObjectEClass);
    m_TargetCoreEClass->getESuperTypes().push_back(
            m_RunnableConstraintTargetEClass);
    m_TargetCoreEClass->getESuperTypes().push_back(
            m_ProcessConstraintTargetEClass);
    m_TargetCoreEClass->getESuperTypes().push_back(m_BaseObjectEClass);
    m_TargetSchedulerEClass->getESuperTypes().push_back(
            m_RunnableConstraintTargetEClass);
    m_TargetSchedulerEClass->getESuperTypes().push_back(
            m_ProcessConstraintTargetEClass);
    m_TargetSchedulerEClass->getESuperTypes().push_back(m_BaseObjectEClass);
    m_LabelEntityGroupEClass->getESuperTypes().push_back(m_LabelGroupEClass);
    m_LabelEntityGroupEClass->getESuperTypes().push_back(m_BaseObjectEClass);
    m_RunnableEntityGroupEClass->getESuperTypes().push_back(
            m_RunnableGroupEClass);
    m_RunnableEntityGroupEClass->getESuperTypes().push_back(m_BaseObjectEClass);
    m_ProcessEntityGroupEClass->getESuperTypes().push_back(
            m_ProcessGroupEClass);
    m_ProcessEntityGroupEClass->getESuperTypes().push_back(m_BaseObjectEClass);
    m_TagGroupEClass->getESuperTypes().push_back(m_RunnableGroupEClass);
    m_TagGroupEClass->getESuperTypes().push_back(m_ProcessGroupEClass);
    m_TagGroupEClass->getESuperTypes().push_back(m_BaseObjectEClass);
    m_AbstractEventChainEClass->getESuperTypes().push_back(m_BaseObjectEClass);
    m_AbstractEventChainEClass->getESuperTypes().push_back(m_INamedEClass);
    m_EventChainEClass->getESuperTypes().push_back(m_AbstractEventChainEClass);
    m_EventChainEClass->getESuperTypes().push_back(m_IReferableEClass);
    m_SubEventChainEClass->getESuperTypes().push_back(
            m_AbstractEventChainEClass);
    m_EventChainReferenceEClass->getESuperTypes().push_back(m_BaseObjectEClass);
    m_EventChainReferenceEClass->getESuperTypes().push_back(
            m_EventChainItemEClass);
    m_EventChainContainerEClass->getESuperTypes().push_back(m_BaseObjectEClass);
    m_EventChainContainerEClass->getESuperTypes().push_back(
            m_EventChainItemEClass);
    m_TimingConstraintEClass->getESuperTypes().push_back(
            m_ReferableBaseObjectEClass);
    m_PhysicalSectionConstraintEClass->getESuperTypes().push_back(
            m_ReferableBaseObjectEClass);
    m_SynchronizationConstraintEClass->getESuperTypes().push_back(
            m_TimingConstraintEClass);
    m_EventSynchronizationConstraintEClass->getESuperTypes().push_back(
            m_SynchronizationConstraintEClass);
    m_EventChainSynchronizationConstraintEClass->getESuperTypes().push_back(
            m_SynchronizationConstraintEClass);
    m_DelayConstraintEClass->getESuperTypes().push_back(
            m_TimingConstraintEClass);
    m_EventChainLatencyConstraintEClass->getESuperTypes().push_back(
            m_TimingConstraintEClass);
    m_RepetitionConstraintEClass->getESuperTypes().push_back(
            m_TimingConstraintEClass);
    m_DataAgeConstraintEClass->getESuperTypes().push_back(
            m_ReferableBaseObjectEClass);
    m_DataAgeCycleEClass->getESuperTypes().push_back(m_DataAgeEClass);
    m_DataAgeTimeEClass->getESuperTypes().push_back(m_DataAgeEClass);
    m_RequirementEClass->getESuperTypes().push_back(m_BaseObjectEClass);
    m_RequirementEClass->getESuperTypes().push_back(m_INamedEClass);
    m_ProcessRequirementEClass->getESuperTypes().push_back(m_RequirementEClass);
    m_RunnableRequirementEClass->getESuperTypes().push_back(
            m_RequirementEClass);
    m_ArchitectureRequirementEClass->getESuperTypes().push_back(
            m_RequirementEClass);
    m_ProcessChainRequirementEClass->getESuperTypes().push_back(
            m_RequirementEClass);
    m_CPUPercentageRequirementLimitEClass->getESuperTypes().push_back(
            m_RequirementLimitEClass);
    m_FrequencyRequirementLimitEClass->getESuperTypes().push_back(
            m_RequirementLimitEClass);
    m_PercentageRequirementLimitEClass->getESuperTypes().push_back(
            m_RequirementLimitEClass);
    m_CountRequirementLimitEClass->getESuperTypes().push_back(
            m_RequirementLimitEClass);
    m_TimeRequirementLimitEClass->getESuperTypes().push_back(
            m_RequirementLimitEClass);
    m_DataCoherencyGroupEClass->getESuperTypes().push_back(
            m_ReferableBaseObjectEClass);
    m_DataStabilityGroupEClass->getESuperTypes().push_back(
            m_ReferableBaseObjectEClass);
    m_ProcessScopeEClass->getESuperTypes().push_back(m_DataGroupScopeEClass);
    m_RunnableScopeEClass->getESuperTypes().push_back(m_DataGroupScopeEClass);
    m_ComponentScopeEClass->getESuperTypes().push_back(m_DataGroupScopeEClass);
    m_EventModelEClass->getESuperTypes().push_back(m_BaseObjectEClass);
    m_EventEClass->getESuperTypes().push_back(m_ReferableBaseObjectEClass);
    m_EventEClass->getESuperTypes().push_back(m_ITaggableEClass);
    m_EventEClass->getESuperTypes().push_back(m_IDescriptionEClass);
    m_EventSetEClass->getESuperTypes().push_back(m_EventEClass);
    m_EntityEventEClass->getESuperTypes().push_back(m_EventEClass);
    m_TriggerEventEClass->getESuperTypes().push_back(m_EntityEventEClass);
    m_CustomEventEClass->getESuperTypes().push_back(m_TriggerEventEClass);
    m_StimulusEventEClass->getESuperTypes().push_back(m_EntityEventEClass);
    m_ProcessEventEClass->getESuperTypes().push_back(m_EntityEventEClass);
    m_ProcessChainEventEClass->getESuperTypes().push_back(m_EntityEventEClass);
    m_RunnableEventEClass->getESuperTypes().push_back(m_TriggerEventEClass);
    m_LabelEventEClass->getESuperTypes().push_back(m_TriggerEventEClass);
    m_ChannelEventEClass->getESuperTypes().push_back(m_TriggerEventEClass);
    m_SemaphoreEventEClass->getESuperTypes().push_back(m_EntityEventEClass);
    m_ComponentEventEClass->getESuperTypes().push_back(m_EntityEventEClass);
    m_HWModelEClass->getESuperTypes().push_back(m_BaseObjectEClass);
    m_HwStructureEClass->getESuperTypes().push_back(
            m_ReferableBaseObjectEClass);
    m_HwStructureEClass->getESuperTypes().push_back(m_ITaggableEClass);
    m_HwModuleEClass->getESuperTypes().push_back(m_ReferableBaseObjectEClass);
    m_HwModuleEClass->getESuperTypes().push_back(m_ITaggableEClass);
    m_HwDomainEClass->getESuperTypes().push_back(m_ReferableBaseObjectEClass);
    m_HwDomainEClass->getESuperTypes().push_back(m_ITaggableEClass);
    m_FrequencyDomainEClass->getESuperTypes().push_back(m_HwDomainEClass);
    m_PowerDomainEClass->getESuperTypes().push_back(m_HwDomainEClass);
    m_ProcessingUnitEClass->getESuperTypes().push_back(m_HwModuleEClass);
    m_ProcessingUnitEClass->getESuperTypes().push_back(m_HwDestinationEClass);
    m_ProcessingUnitEClass->getESuperTypes().push_back(m_HwPathElementEClass);
    m_MemoryEClass->getESuperTypes().push_back(m_HwModuleEClass);
    m_MemoryEClass->getESuperTypes().push_back(m_HwDestinationEClass);
    m_CacheEClass->getESuperTypes().push_back(m_HwModuleEClass);
    m_CacheEClass->getESuperTypes().push_back(m_HwPathElementEClass);
    m_HwFeatureCategoryEClass->getESuperTypes().push_back(
            m_ReferableBaseObjectEClass);
    m_HwFeatureCategoryEClass->getESuperTypes().push_back(m_IDescriptionEClass);
    m_HwFeatureEClass->getESuperTypes().push_back(m_ReferableBaseObjectEClass);
    m_HwPortEClass->getESuperTypes().push_back(m_ReferableBaseObjectEClass);
    m_HwPortEClass->getESuperTypes().push_back(m_ITaggableEClass);
    m_ConnectionHandlerEClass->getESuperTypes().push_back(m_HwModuleEClass);
    m_ConnectionHandlerEClass->getESuperTypes().push_back(
            m_HwPathElementEClass);
    m_HwConnectionEClass->getESuperTypes().push_back(
            m_ReferableBaseObjectEClass);
    m_HwConnectionEClass->getESuperTypes().push_back(m_HwPathElementEClass);
    m_HwConnectionEClass->getESuperTypes().push_back(m_ITaggableEClass);
    m_HwAccessElementEClass->getESuperTypes().push_back(m_ITaggableEClass);
    m_HwAccessElementEClass->getESuperTypes().push_back(m_INamedEClass);
    m_HwDefinitionEClass->getESuperTypes().push_back(
            m_ReferableBaseObjectEClass);
    m_HwDefinitionEClass->getESuperTypes().push_back(m_ITaggableEClass);
    m_ProcessingUnitDefinitionEClass->getESuperTypes().push_back(
            m_HwDefinitionEClass);
    m_ConnectionHandlerDefinitionEClass->getESuperTypes().push_back(
            m_HwDefinitionEClass);
    m_MemoryDefinitionEClass->getESuperTypes().push_back(m_HwDefinitionEClass);
    m_CacheDefinitionEClass->getESuperTypes().push_back(m_HwDefinitionEClass);
    m_HwAccessPathEClass->getESuperTypes().push_back(m_HwPathEClass);
    m_HwAccessPathEClass->getESuperTypes().push_back(m_INamedEClass);
    m_HwPathElementEClass->getESuperTypes().push_back(m_IReferableEClass);
    m_HwDestinationEClass->getESuperTypes().push_back(m_IReferableEClass);
    m_MappingModelEClass->getESuperTypes().push_back(m_BaseObjectEClass);
    m_SchedulerAllocationEClass->getESuperTypes().push_back(m_BaseObjectEClass);
    m_TaskAllocationEClass->getESuperTypes().push_back(m_BaseObjectEClass);
    m_ISRAllocationEClass->getESuperTypes().push_back(m_BaseObjectEClass);
    m_RunnableAllocationEClass->getESuperTypes().push_back(m_BaseObjectEClass);
    m_MemoryMappingEClass->getESuperTypes().push_back(m_BaseObjectEClass);
    m_PhysicalSectionMappingEClass->getESuperTypes().push_back(
            m_ReferableBaseObjectEClass);
    m_OSModelEClass->getESuperTypes().push_back(m_BaseObjectEClass);
    m_OsDataConsistencyEClass->getESuperTypes().push_back(m_BaseObjectEClass);
    m_SemaphoreEClass->getESuperTypes().push_back(m_ReferableBaseObjectEClass);
    m_SchedulerEClass->getESuperTypes().push_back(m_ReferableBaseObjectEClass);
    m_TaskSchedulerEClass->getESuperTypes().push_back(m_SchedulerEClass);
    m_InterruptControllerEClass->getESuperTypes().push_back(m_SchedulerEClass);
    m_AlgorithmEClass->getESuperTypes().push_back(m_BaseObjectEClass);
    m_InterruptSchedulingAlgorithmEClass->getESuperTypes().push_back(
            m_AlgorithmEClass);
    m_TaskSchedulingAlgorithmEClass->getESuperTypes().push_back(
            m_AlgorithmEClass);
    m_FixedPriorityEClass->getESuperTypes().push_back(
            m_TaskSchedulingAlgorithmEClass);
    m_FixedPriorityPreemptiveEClass->getESuperTypes().push_back(
            m_FixedPriorityEClass);
    m_FixedPriorityPreemptiveWithBudgetEnforcementEClass->getESuperTypes().push_back(
            m_FixedPriorityEClass);
    m_OSEKEClass->getESuperTypes().push_back(m_FixedPriorityEClass);
    m_DeadlineMonotonicEClass->getESuperTypes().push_back(
            m_FixedPriorityEClass);
    m_RateMonotonicEClass->getESuperTypes().push_back(m_FixedPriorityEClass);
    m_PfairEClass->getESuperTypes().push_back(m_TaskSchedulingAlgorithmEClass);
    m_PfairPD2EClass->getESuperTypes().push_back(m_PfairEClass);
    m_PartlyPFairPD2EClass->getESuperTypes().push_back(m_PfairEClass);
    m_EarlyReleaseFairPD2EClass->getESuperTypes().push_back(m_PfairEClass);
    m_PartlyEarlyReleaseFairPD2EClass->getESuperTypes().push_back(
            m_PfairEClass);
    m_DynamicPriorityEClass->getESuperTypes().push_back(
            m_TaskSchedulingAlgorithmEClass);
    m_LeastLocalRemainingExecutionTimeFirstEClass->getESuperTypes().push_back(
            m_DynamicPriorityEClass);
    m_EarliestDeadlineFirstEClass->getESuperTypes().push_back(
            m_DynamicPriorityEClass);
    m_PriorityBasedRoundRobinEClass->getESuperTypes().push_back(
            m_DynamicPriorityEClass);
    m_ReservationBasedServerEClass->getESuperTypes().push_back(
            m_TaskSchedulingAlgorithmEClass);
    m_DeferrableServerEClass->getESuperTypes().push_back(
            m_ReservationBasedServerEClass);
    m_PollingPeriodicServerEClass->getESuperTypes().push_back(
            m_ReservationBasedServerEClass);
    m_SporadicServerEClass->getESuperTypes().push_back(
            m_ReservationBasedServerEClass);
    m_ConstantBandwidthServerEClass->getESuperTypes().push_back(
            m_ReservationBasedServerEClass);
    m_ConstantBandwidthServerWithCASHEClass->getESuperTypes().push_back(
            m_ReservationBasedServerEClass);
    m_GroupingEClass->getESuperTypes().push_back(
            m_TaskSchedulingAlgorithmEClass);
    m_UserSpecificSchedulingAlgorithmEClass->getESuperTypes().push_back(
            m_TaskSchedulingAlgorithmEClass);
    m_UserSpecificSchedulingAlgorithmEClass->getESuperTypes().push_back(
            m_InterruptSchedulingAlgorithmEClass);
    m_PriorityBasedEClass->getESuperTypes().push_back(
            m_InterruptSchedulingAlgorithmEClass);
    m_OperatingSystemEClass->getESuperTypes().push_back(m_BaseObjectEClass);
    m_OperatingSystemEClass->getESuperTypes().push_back(m_INamedEClass);
    m_VendorOperatingSystemEClass->getESuperTypes().push_back(
            m_OperatingSystemEClass);
    m_OsOverheadEClass->getESuperTypes().push_back(m_ReferableBaseObjectEClass);
    m_OsAPIOverheadEClass->getESuperTypes().push_back(m_BaseObjectEClass);
    m_OsISROverheadEClass->getESuperTypes().push_back(m_BaseObjectEClass);
    m_PropertyConstraintsModelEClass->getESuperTypes().push_back(
            m_BaseObjectEClass);
    m_CoreAllocationConstraintEClass->getESuperTypes().push_back(
            m_BaseObjectEClass);
    m_MemoryMappingConstraintEClass->getESuperTypes().push_back(
            m_BaseObjectEClass);
    m_ProcessAllocationConstraintEClass->getESuperTypes().push_back(
            m_CoreAllocationConstraintEClass);
    m_ProcessPrototypeAllocationConstraintEClass->getESuperTypes().push_back(
            m_CoreAllocationConstraintEClass);
    m_RunnableAllocationConstraintEClass->getESuperTypes().push_back(
            m_CoreAllocationConstraintEClass);
    m_AbstractElementMappingConstraintEClass->getESuperTypes().push_back(
            m_MemoryMappingConstraintEClass);
    m_ClassificationEClass->getESuperTypes().push_back(m_BaseObjectEClass);
    m_CoreClassificationEClass->getESuperTypes().push_back(
            m_ClassificationEClass);
    m_MemoryClassificationEClass->getESuperTypes().push_back(
            m_ClassificationEClass);
    m_StimuliModelEClass->getESuperTypes().push_back(m_BaseObjectEClass);
    m_StimulusEClass->getESuperTypes().push_back(m_ReferableBaseObjectEClass);
    m_StimulusEClass->getESuperTypes().push_back(m_ITaggableEClass);
    m_ModeValueListEClass->getESuperTypes().push_back(m_BaseObjectEClass);
    m_ModeValueEClass->getESuperTypes().push_back(m_BaseObjectEClass);
    m_ModeAssignmentEClass->getESuperTypes().push_back(m_ModeValueEClass);
    m_ModeConditionDisjunctionEClass->getESuperTypes().push_back(
            m_BaseObjectEClass);
    m_ModeConditionDisjunctionEntryEClass->getESuperTypes().push_back(
            m_BaseObjectEClass);
    m_ModeConditionEClass->getESuperTypes().push_back(
            m_ModeConditionDisjunctionEntryEClass);
    m_ModeValueConditionEClass->getESuperTypes().push_back(m_ModeValueEClass);
    m_ModeValueConditionEClass->getESuperTypes().push_back(
            m_ModeConditionEClass);
    m_ModeLabelConditionEClass->getESuperTypes().push_back(
            m_ModeConditionEClass);
    m_ModeConditionConjunctionEClass->getESuperTypes().push_back(
            m_ModeConditionDisjunctionEntryEClass);
    m_PeriodicStimulusEClass->getESuperTypes().push_back(m_StimulusEClass);
    m_PeriodicStimulusEClass->getESuperTypes().push_back(m_FixedPeriodicEClass);
    m_RelativePeriodicStimulusEClass->getESuperTypes().push_back(
            m_StimulusEClass);
    m_VariableRateStimulusEClass->getESuperTypes().push_back(m_StimulusEClass);
    m_ScenarioEClass->getESuperTypes().push_back(m_BaseObjectEClass);
    m_PeriodicSyntheticStimulusEClass->getESuperTypes().push_back(
            m_StimulusEClass);
    m_PeriodicSyntheticStimulusEClass->getESuperTypes().push_back(
            m_FixedPeriodicEClass);
    m_CustomStimulusEClass->getESuperTypes().push_back(m_StimulusEClass);
    m_CustomStimulusEClass->getESuperTypes().push_back(m_IDescriptionEClass);
    m_SingleStimulusEClass->getESuperTypes().push_back(m_StimulusEClass);
    m_InterProcessStimulusEClass->getESuperTypes().push_back(m_StimulusEClass);
    m_PeriodicBurstStimulusEClass->getESuperTypes().push_back(m_StimulusEClass);
    m_PeriodicBurstStimulusEClass->getESuperTypes().push_back(
            m_FixedPeriodicEClass);
    m_EventStimulusEClass->getESuperTypes().push_back(m_StimulusEClass);
    m_ArrivalCurveStimulusEClass->getESuperTypes().push_back(m_StimulusEClass);
    m_ArrivalCurveEntryEClass->getESuperTypes().push_back(m_BaseObjectEClass);
    m_ClockEClass->getESuperTypes().push_back(m_ReferableBaseObjectEClass);
    m_ClockFunctionEClass->getESuperTypes().push_back(m_ClockEClass);
    m_ClockStepListEClass->getESuperTypes().push_back(m_ClockEClass);
    m_ClockStepEClass->getESuperTypes().push_back(m_BaseObjectEClass);
    m_SWModelEClass->getESuperTypes().push_back(m_BaseObjectEClass);
    m_AbstractMemoryElementEClass->getESuperTypes().push_back(
            m_ReferableBaseObjectEClass);
    m_AbstractMemoryElementEClass->getESuperTypes().push_back(
            m_ITaggableEClass);
    m_AbstractProcessEClass->getESuperTypes().push_back(
            m_AbstractMemoryElementEClass);
    m_CustomEntityEClass->getESuperTypes().push_back(
            m_AbstractMemoryElementEClass);
    m_CustomEntityEClass->getESuperTypes().push_back(m_IDescriptionEClass);
    m_ProcessChainEClass->getESuperTypes().push_back(
            m_ReferableBaseObjectEClass);
    m_ProcessEClass->getESuperTypes().push_back(m_AbstractProcessEClass);
    m_ActivityGraphEClass->getESuperTypes().push_back(m_BaseObjectEClass);
    m_ActivityGraphEClass->getESuperTypes().push_back(
            m_IActivityGraphItemContainerEClass);
    m_ActivityGraphItemEClass->getESuperTypes().push_back(m_BaseObjectEClass);
    m_ModeSwitchEClass->getESuperTypes().push_back(m_ActivityGraphItemEClass);
    m_ModeSwitchEntryEClass->getESuperTypes().push_back(m_BaseObjectEClass);
    m_ModeSwitchEntryEClass->getESuperTypes().push_back(m_INamedEClass);
    m_ModeSwitchEntryEClass->getESuperTypes().push_back(
            m_IActivityGraphItemContainerEClass);
    m_ModeSwitchDefaultEClass->getESuperTypes().push_back(m_BaseObjectEClass);
    m_ModeSwitchDefaultEClass->getESuperTypes().push_back(
            m_IActivityGraphItemContainerEClass);
    m_ProbabilitySwitchEClass->getESuperTypes().push_back(
            m_ActivityGraphItemEClass);
    m_ProbabilitySwitchEntryEClass->getESuperTypes().push_back(
            m_BaseObjectEClass);
    m_ProbabilitySwitchEntryEClass->getESuperTypes().push_back(
            m_IActivityGraphItemContainerEClass);
    m_CounterEClass->getESuperTypes().push_back(m_BaseObjectEClass);
    m_WaitEventEClass->getESuperTypes().push_back(m_ActivityGraphItemEClass);
    m_SetEventEClass->getESuperTypes().push_back(m_ActivityGraphItemEClass);
    m_ClearEventEClass->getESuperTypes().push_back(m_ActivityGraphItemEClass);
    m_EventMaskEClass->getESuperTypes().push_back(m_BaseObjectEClass);
    m_OsEventEClass->getESuperTypes().push_back(m_ReferableBaseObjectEClass);
    m_OsEventEClass->getESuperTypes().push_back(m_ITaggableEClass);
    m_InterProcessTriggerEClass->getESuperTypes().push_back(
            m_ActivityGraphItemEClass);
    m_EnforcedMigrationEClass->getESuperTypes().push_back(
            m_ActivityGraphItemEClass);
    m_SchedulePointEClass->getESuperTypes().push_back(
            m_ActivityGraphItemEClass);
    m_TerminateProcessEClass->getESuperTypes().push_back(
            m_ActivityGraphItemEClass);
    m_TaskEClass->getESuperTypes().push_back(m_ProcessEClass);
    m_ISREClass->getESuperTypes().push_back(m_ProcessEClass);
    m_ProcessPrototypeEClass->getESuperTypes().push_back(
            m_AbstractProcessEClass);
    m_ChainedProcessPrototypeEClass->getESuperTypes().push_back(
            m_BaseObjectEClass);
    m_GeneralPrecedenceEClass->getESuperTypes().push_back(m_BaseObjectEClass);
    m_AccessPrecedenceSpecEClass->getESuperTypes().push_back(
            m_GeneralPrecedenceEClass);
    m_OrderPrecedenceSpecEClass->getESuperTypes().push_back(
            m_GeneralPrecedenceEClass);
    m_DataDependencyEClass->getESuperTypes().push_back(m_BaseObjectEClass);
    m_RunnableParameterEClass->getESuperTypes().push_back(
            m_ReferableBaseObjectEClass);
    m_RunnableParameterEClass->getESuperTypes().push_back(m_IDependsOnEClass);
    m_RunnableEClass->getESuperTypes().push_back(m_AbstractMemoryElementEClass);
    m_RunnableEClass->getESuperTypes().push_back(m_INamespaceMemberEClass);
    m_LabelEClass->getESuperTypes().push_back(m_AbstractMemoryElementEClass);
    m_LabelEClass->getESuperTypes().push_back(m_IDisplayNameEClass);
    m_LabelEClass->getESuperTypes().push_back(m_INamespaceMemberEClass);
    m_ChannelEClass->getESuperTypes().push_back(m_AbstractMemoryElementEClass);
    m_ChannelEClass->getESuperTypes().push_back(m_IDisplayNameEClass);
    m_ChannelEClass->getESuperTypes().push_back(m_INamespaceMemberEClass);
    m_ModeLabelEClass->getESuperTypes().push_back(
            m_AbstractMemoryElementEClass);
    m_ModeLabelEClass->getESuperTypes().push_back(m_IDisplayNameEClass);
    m_SectionEClass->getESuperTypes().push_back(m_ReferableBaseObjectEClass);
    m_ComputationItemEClass->getESuperTypes().push_back(
            m_ActivityGraphItemEClass);
    m_ExecutionNeedEClass->getESuperTypes().push_back(
            m_ActivityGraphItemEClass);
    m_TicksEClass->getESuperTypes().push_back(m_ComputationItemEClass);
    m_ModeLabelAccessEClass->getESuperTypes().push_back(
            m_ActivityGraphItemEClass);
    m_LabelAccessEClass->getESuperTypes().push_back(m_ComputationItemEClass);
    m_LabelAccessEClass->getESuperTypes().push_back(m_ITaggableEClass);
    m_LabelAccessEClass->getESuperTypes().push_back(m_IDependsOnEClass);
    m_ChannelAccessEClass->getESuperTypes().push_back(
            m_ActivityGraphItemEClass);
    m_ChannelSendEClass->getESuperTypes().push_back(m_ChannelAccessEClass);
    m_ChannelReceiveEClass->getESuperTypes().push_back(m_ChannelAccessEClass);
    m_SemaphoreAccessEClass->getESuperTypes().push_back(
            m_ActivityGraphItemEClass);
    m_SenderReceiverCommunicationEClass->getESuperTypes().push_back(
            m_ActivityGraphItemEClass);
    m_SenderReceiverReadEClass->getESuperTypes().push_back(
            m_SenderReceiverCommunicationEClass);
    m_SenderReceiverWriteEClass->getESuperTypes().push_back(
            m_SenderReceiverCommunicationEClass);
    m_ServerCallEClass->getESuperTypes().push_back(m_ActivityGraphItemEClass);
    m_SynchronousServerCallEClass->getESuperTypes().push_back(
            m_ServerCallEClass);
    m_AsynchronousServerCallEClass->getESuperTypes().push_back(
            m_ServerCallEClass);
    m_GetResultServerCallEClass->getESuperTypes().push_back(m_ServerCallEClass);
    m_GroupEClass->getESuperTypes().push_back(m_ActivityGraphItemEClass);
    m_GroupEClass->getESuperTypes().push_back(m_INamedEClass);
    m_GroupEClass->getESuperTypes().push_back(
            m_IActivityGraphItemContainerEClass);
    m_CallArgumentEClass->getESuperTypes().push_back(m_ReferableObjectEClass);
    m_CallArgumentEClass->getESuperTypes().push_back(m_IDependsOnEClass);
    m_RunnableCallEClass->getESuperTypes().push_back(m_ActivityGraphItemEClass);
    m_RunnableCallEClass->getESuperTypes().push_back(m_ITaggableEClass);
    m_CustomEventTriggerEClass->getESuperTypes().push_back(
            m_ActivityGraphItemEClass);
    m_CompoundTypeEClass->getESuperTypes().push_back(m_BaseObjectEClass);
    m_CompoundTypeEClass->getESuperTypes().push_back(m_DataTypeEClass);
    m_StructEClass->getESuperTypes().push_back(m_CompoundTypeEClass);
    m_StructEClass->getESuperTypes().push_back(m_ITaggableEClass);
    m_StructEntryEClass->getESuperTypes().push_back(m_BaseObjectEClass);
    m_StructEntryEClass->getESuperTypes().push_back(m_INamedEClass);
    m_StructEntryEClass->getESuperTypes().push_back(m_ITaggableEClass);
    m_ArrayEClass->getESuperTypes().push_back(m_CompoundTypeEClass);
    m_PointerEClass->getESuperTypes().push_back(m_CompoundTypeEClass);
    m_TypeRefEClass->getESuperTypes().push_back(m_BaseObjectEClass);
    m_TypeRefEClass->getESuperTypes().push_back(m_DataTypeEClass);
    m_AliasEClass->getESuperTypes().push_back(m_BaseObjectEClass);
    m_TypeDefinitionEClass->getESuperTypes().push_back(
            m_ReferableBaseObjectEClass);
    m_TypeDefinitionEClass->getESuperTypes().push_back(
            m_INamespaceMemberEClass);
    m_DataTypeDefinitionEClass->getESuperTypes().push_back(
            m_TypeDefinitionEClass);
    m_BaseTypeDefinitionEClass->getESuperTypes().push_back(
            m_TypeDefinitionEClass);
    m_ActivationEClass->getESuperTypes().push_back(m_ReferableBaseObjectEClass);
    m_ActivationEClass->getESuperTypes().push_back(m_ITaggableEClass);
    m_PeriodicActivationEClass->getESuperTypes().push_back(m_ActivationEClass);
    m_VariableRateActivationEClass->getESuperTypes().push_back(
            m_ActivationEClass);
    m_VariableRateActivationEClass->getESuperTypes().push_back(
            m_IDescriptionEClass);
    m_SporadicActivationEClass->getESuperTypes().push_back(m_ActivationEClass);
    m_SporadicActivationEClass->getESuperTypes().push_back(
            m_IDescriptionEClass);
    m_SingleActivationEClass->getESuperTypes().push_back(m_ActivationEClass);
    m_EventActivationEClass->getESuperTypes().push_back(m_ActivationEClass);
    m_CustomActivationEClass->getESuperTypes().push_back(m_ActivationEClass);
    m_CustomActivationEClass->getESuperTypes().push_back(m_IDescriptionEClass);
    m_LabelAccessStatisticEClass->getESuperTypes().push_back(
            m_BaseObjectEClass);
    m_RunEntityCallStatisticEClass->getESuperTypes().push_back(
            m_BaseObjectEClass);

    // TODO: Initialize classes and features; add operations and parameters
    // TODO: GenericTypes
    // Amalthea
    m_AmaltheaEClass->setName("Amalthea");
    m_AmaltheaEClass->setAbstract(false);
    m_AmaltheaEClass->setInterface(false);
    m_Amalthea__version->setEType(
            dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEString());
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute > (m_Amalthea__version),
            "version", false, true, true, "", false, true, true, false, 0, 1,
            false, false);
    m_Amalthea__version->setID(false);
    m_Amalthea__commonElements->setEType(m_CommonElementsEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_Amalthea__commonElements),
            "commonElements", true, false, false, "", false, false, true, true,
            0, 1, false, false);
    m_Amalthea__commonElements->setContainment(true);
    m_Amalthea__commonElements->setResolveProxies(false);
    m_Amalthea__swModel->setEType(m_SWModelEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_Amalthea__swModel),
            "swModel", true, false, false, "", false, false, true, true, 0, 1,
            false, false);
    m_Amalthea__swModel->setContainment(true);
    m_Amalthea__swModel->setResolveProxies(false);
    m_Amalthea__hwModel->setEType(m_HWModelEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_Amalthea__hwModel),
            "hwModel", true, false, false, "", false, false, true, true, 0, 1,
            false, false);
    m_Amalthea__hwModel->setContainment(true);
    m_Amalthea__hwModel->setResolveProxies(false);
    m_Amalthea__osModel->setEType(m_OSModelEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_Amalthea__osModel),
            "osModel", true, false, false, "", false, false, true, true, 0, 1,
            false, false);
    m_Amalthea__osModel->setContainment(true);
    m_Amalthea__osModel->setResolveProxies(false);
    m_Amalthea__stimuliModel->setEType(m_StimuliModelEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_Amalthea__stimuliModel),
            "stimuliModel", true, false, false, "", false, false, true, true, 0,
            1, false, false);
    m_Amalthea__stimuliModel->setContainment(true);
    m_Amalthea__stimuliModel->setResolveProxies(false);
    m_Amalthea__eventModel->setEType(m_EventModelEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_Amalthea__eventModel),
            "eventModel", true, false, false, "", false, false, true, true, 0,
            1, false, false);
    m_Amalthea__eventModel->setContainment(true);
    m_Amalthea__eventModel->setResolveProxies(false);
    m_Amalthea__constraintsModel->setEType(m_ConstraintsModelEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_Amalthea__constraintsModel),
            "constraintsModel", true, false, false, "", false, false, true,
            true, 0, 1, false, false);
    m_Amalthea__constraintsModel->setContainment(true);
    m_Amalthea__constraintsModel->setResolveProxies(false);
    m_Amalthea__propertyConstraintsModel->setEType(
            m_PropertyConstraintsModelEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_Amalthea__propertyConstraintsModel),
            "propertyConstraintsModel", true, false, false, "", false, false,
            true, true, 0, 1, false, false);
    m_Amalthea__propertyConstraintsModel->setContainment(true);
    m_Amalthea__propertyConstraintsModel->setResolveProxies(false);
    m_Amalthea__mappingModel->setEType(m_MappingModelEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_Amalthea__mappingModel),
            "mappingModel", true, false, false, "", false, false, true, true, 0,
            1, false, false);
    m_Amalthea__mappingModel->setContainment(true);
    m_Amalthea__mappingModel->setResolveProxies(false);
    m_Amalthea__componentsModel->setEType(m_ComponentsModelEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_Amalthea__componentsModel),
            "componentsModel", true, false, false, "", false, false, true, true,
            0, 1, false, false);
    m_Amalthea__componentsModel->setContainment(true);
    m_Amalthea__componentsModel->setResolveProxies(false);
    m_Amalthea__configModel->setEType(m_ConfigModelEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_Amalthea__configModel),
            "configModel", true, false, false, "", false, false, true, true, 0,
            1, false, false);
    m_Amalthea__configModel->setContainment(true);
    m_Amalthea__configModel->setResolveProxies(false);
    // CommonElements
    m_CommonElementsEClass->setName("CommonElements");
    m_CommonElementsEClass->setAbstract(false);
    m_CommonElementsEClass->setInterface(false);
    m_CommonElements__tags->setEType(m_TagEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_CommonElements__tags),
            "tags", true, false, false, "", false, false, true, true, 0, -1,
            true, false);
    m_CommonElements__tags->setContainment(true);
    m_CommonElements__tags->setResolveProxies(false);
    m_CommonElements__namespaces->setEType(m_NamespaceEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_CommonElements__namespaces),
            "namespaces", true, false, false, "", false, false, true, true, 0,
            -1, true, false);
    m_CommonElements__namespaces->setContainment(true);
    m_CommonElements__namespaces->setResolveProxies(false);
    m_CommonElements__coreClassifiers->setEType(m_CoreClassifierEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_CommonElements__coreClassifiers), "coreClassifiers",
            true, false, false, "", false, false, true, true, 0, -1, true,
            false);
    m_CommonElements__coreClassifiers->setContainment(true);
    m_CommonElements__coreClassifiers->setResolveProxies(false);
    m_CommonElements__memoryClassifiers->setEType(m_MemoryClassifierEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_CommonElements__memoryClassifiers),
            "memoryClassifiers", true, false, false, "", false, false, true,
            true, 0, -1, true, false);
    m_CommonElements__memoryClassifiers->setContainment(true);
    m_CommonElements__memoryClassifiers->setResolveProxies(false);
    // BaseObject
    m_BaseObjectEClass->setName("BaseObject");
    m_BaseObjectEClass->setAbstract(true);
    m_BaseObjectEClass->setInterface(false);
    // ReferableObject
    m_ReferableObjectEClass->setName("ReferableObject");
    m_ReferableObjectEClass->setAbstract(true);
    m_ReferableObjectEClass->setInterface(false);
    // ReferableBaseObject
    m_ReferableBaseObjectEClass->setName("ReferableBaseObject");
    m_ReferableBaseObjectEClass->setAbstract(true);
    m_ReferableBaseObjectEClass->setInterface(false);
    // IAnnotatable
    m_IAnnotatableEClass->setName("IAnnotatable");
    m_IAnnotatableEClass->setAbstract(true);
    m_IAnnotatableEClass->setInterface(true);
    m_IAnnotatable__customProperties->setEType(m_CustomPropertyEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_IAnnotatable__customProperties), "customProperties",
            true, false, false, "", false, false, true, true, 0, -1, true,
            false);
    m_IAnnotatable__customProperties->setContainment(true);
    m_IAnnotatable__customProperties->setResolveProxies(false);
    // ITaggable
    m_ITaggableEClass->setName("ITaggable");
    m_ITaggableEClass->setAbstract(true);
    m_ITaggableEClass->setInterface(true);
    m_ITaggable__tags->setEType(m_TagEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_ITaggable__tags), "tags",
            true, false, false, "", false, false, true, true, 0, -1, true,
            false);
    m_ITaggable__tags->setContainment(false);
    m_ITaggable__tags->setResolveProxies(true);
    // INamed
    m_INamedEClass->setName("INamed");
    m_INamedEClass->setAbstract(true);
    m_INamedEClass->setInterface(true);
    m_INamed__name->setEType(
            dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEString());
    initEStructuralFeature(::ecore::as < ::ecore::EAttribute > (m_INamed__name),
            "name", true, false, false, "", false, false, true, false, 0, 1,
            false, false);
    m_INamed__name->setID(false);
    m_INamed__qualifiedName->setEType(
            dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEString());
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute > (m_INamed__qualifiedName),
            "qualifiedName", false, true, true, "", false, true, true, false, 0,
            1, false, false);
    m_INamed__qualifiedName->setID(false);
    {
        ::ecore::EOperation_ptr _op = addEOperation(m_INamedEClass, nullptr,
                "getNamedContainer", 0, 1, false, true);
        _op->setEType(m_INamedEClass);
    }
    {
        ::ecore::EOperation_ptr _op = addEOperation(m_INamedEClass, nullptr,
                "getNamePrefix", 0, 1, false, true);
        _op->setEType(
                dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEString());
    }
    {
        ::ecore::EOperation_ptr _op = addEOperation(m_INamedEClass, nullptr,
                "getQualifiedNameSegments", 0, -1, false, true);
        _op->setEType(
                dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEString());
    }
    {
        ::ecore::EOperation_ptr _op = addEOperation(m_INamedEClass, nullptr,
                "getDefaultNameSeparator", 0, 1, false, true);
        _op->setEType(
                dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEString());
    }
    {
        ::ecore::EOperation_ptr _op = addEOperation(m_INamedEClass, nullptr,
                "getNamespace", 0, 1, false, true);
        _op->setEType(m_NamespaceEClass);
    }
    {
        ::ecore::EOperation_ptr _op = addEOperation(m_INamedEClass, nullptr,
                "getNamePrefixSegments", 0, -1, false, true);
        _op->setEType(
                dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEString());
    }
    // IReferable
    m_IReferableEClass->setName("IReferable");
    m_IReferableEClass->setAbstract(true);
    m_IReferableEClass->setInterface(true);
    m_IReferable__uniqueName->setEType(
            dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEString());
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute > (m_IReferable__uniqueName),
            "uniqueName", false, true, true, "", false, true, true, false, 0, 1,
            false, false);
    m_IReferable__uniqueName->setID(true);
    {
        ::ecore::EOperation_ptr _op = addEOperation(m_IReferableEClass, nullptr,
                "getEncodedQualifiedName", 0, 1, false, true);
        _op->setEType(
                dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEString());
    }
    {
        ::ecore::EOperation_ptr _op = addEOperation(m_IReferableEClass, nullptr,
                "validateInvariants", 0, 1, false, true);
        _op->setEType(
                dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEBoolean());
        {
            ::ecore::EParameter_ptr _pa = addEParameter(_op, "diagnostics", 0,
                    1, false, true);
            _pa->setEType(
                    dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEDiagnosticChain());
        }
        {
            ::ecore::EParameter_ptr _pa = addEParameter(_op, "context", 0, 1,
                    false, true);
            _pa->setEType(
                    dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEMap());
            {
                ::ecore::EGenericType_ptr _g0 = ::ecore::Ptr
                        < ::ecore::EGenericType > (new ::ecore::EGenericType);
                _g0->setEClassifier(
                        dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEMap());
                ::ecore::EGenericType_ptr _g1 = ::ecore::Ptr
                        < ::ecore::EGenericType > (new ::ecore::EGenericType);
                _g1->setEClassifier(
                        dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEJavaObject());
                _g0->getETypeArguments().push_back(_g1);
                ::ecore::EGenericType_ptr _g2 = ::ecore::Ptr
                        < ::ecore::EGenericType > (new ::ecore::EGenericType);
                _g2->setEClassifier(
                        dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEJavaObject());
                _g0->getETypeArguments().push_back(_g2);
                _pa->setEGenericType(_g0);
            }
        }
    }
    // IDisplayName
    m_IDisplayNameEClass->setName("IDisplayName");
    m_IDisplayNameEClass->setAbstract(true);
    m_IDisplayNameEClass->setInterface(true);
    m_IDisplayName__displayName->setEType(
            dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEString());
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute > (m_IDisplayName__displayName),
            "displayName", true, false, false, "", false, false, true, false, 0,
            1, false, false);
    m_IDisplayName__displayName->setID(false);
    // IDescription
    m_IDescriptionEClass->setName("IDescription");
    m_IDescriptionEClass->setAbstract(true);
    m_IDescriptionEClass->setInterface(true);
    m_IDescription__description->setEType(
            dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEString());
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute > (m_IDescription__description),
            "description", true, false, false, "", false, false, true, false, 0,
            1, false, false);
    m_IDescription__description->setID(false);
    // INamespaceMember
    m_INamespaceMemberEClass->setName("INamespaceMember");
    m_INamespaceMemberEClass->setAbstract(true);
    m_INamespaceMemberEClass->setInterface(true);
    m_INamespaceMember__namespace->setEType(m_NamespaceEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_INamespaceMember__namespace),
            "namespace", true, false, false, "", false, false, true, true, 0, 1,
            false, false);
    m_INamespaceMember__namespace->setContainment(false);
    m_INamespaceMember__namespace->setResolveProxies(true);
    // Tag
    m_TagEClass->setName("Tag");
    m_TagEClass->setAbstract(false);
    m_TagEClass->setInterface(false);
    m_Tag__tagType->setEType(
            dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEString());
    initEStructuralFeature(::ecore::as < ::ecore::EAttribute > (m_Tag__tagType),
            "tagType", true, false, false, "", false, false, true, false, 0, 1,
            false, false);
    m_Tag__tagType->setID(false);
    m_Tag__taggedObjects->setEType(m_ITaggableEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_Tag__taggedObjects),
            "taggedObjects", false, true, true, "", false, true, true, true, 0,
            -1, true, false);
    m_Tag__taggedObjects->setContainment(false);
    m_Tag__taggedObjects->setResolveProxies(true);
    // Namespace
    m_NamespaceEClass->setName("Namespace");
    m_NamespaceEClass->setAbstract(false);
    m_NamespaceEClass->setInterface(false);
    m_Namespace__nextSegments->setEType(m_NamespaceEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_Namespace__nextSegments),
            "nextSegments", true, false, false, "", false, false, true, true, 0,
            -1, true, false);
    m_Namespace__nextSegments->setContainment(true);
    m_Namespace__nextSegments->setResolveProxies(false);
    m_Namespace__nextSegments->setEOpposite(
            ::ecore::as < ::ecore::EReference
                    > (m_NamespaceEClass->getEStructuralFeatures()[1]));
    m_Namespace__previousSegment->setEType(m_NamespaceEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_Namespace__previousSegment),
            "previousSegment", false, false, false, "", false, false, true,
            true, 0, 1, false, false);
    m_Namespace__previousSegment->setContainment(false);
    m_Namespace__previousSegment->setResolveProxies(true);
    m_Namespace__previousSegment->setEOpposite(
            ::ecore::as < ::ecore::EReference
                    > (m_NamespaceEClass->getEStructuralFeatures()[0]));
    m_Namespace__memberObjects->setEType(m_INamespaceMemberEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_Namespace__memberObjects),
            "memberObjects", false, true, true, "", false, true, true, true, 0,
            -1, true, false);
    m_Namespace__memberObjects->setContainment(false);
    m_Namespace__memberObjects->setResolveProxies(true);
    {
        ::ecore::EOperation_ptr _op = addEOperation(m_NamespaceEClass, nullptr,
                "getNamePrefixSegments", 0, -1, false, true);
        _op->setEType(
                dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEString());
    }
    // Classifier
    m_ClassifierEClass->setName("Classifier");
    m_ClassifierEClass->setAbstract(true);
    m_ClassifierEClass->setInterface(false);
    // CoreClassifier
    m_CoreClassifierEClass->setName("CoreClassifier");
    m_CoreClassifierEClass->setAbstract(false);
    m_CoreClassifierEClass->setInterface(false);
    // MemoryClassifier
    m_MemoryClassifierEClass->setName("MemoryClassifier");
    m_MemoryClassifierEClass->setAbstract(false);
    m_MemoryClassifierEClass->setInterface(false);
    // TransmissionPolicy
    m_TransmissionPolicyEClass->setName("TransmissionPolicy");
    m_TransmissionPolicyEClass->setAbstract(false);
    m_TransmissionPolicyEClass->setInterface(false);
    m_TransmissionPolicy__chunkProcessingTicks->setEType(
            dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEInt());
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute
                    > (m_TransmissionPolicy__chunkProcessingTicks),
            "chunkProcessingTicks", true, false, false, "0", false, false, true,
            false, 0, 1, false, false);
    m_TransmissionPolicy__chunkProcessingTicks->setID(false);
    m_TransmissionPolicy__transmitRatio->setEType(
            dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEDouble());
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute
                    > (m_TransmissionPolicy__transmitRatio), "transmitRatio",
            true, false, false, "1.0", false, false, true, false, 0, 1, false,
            false);
    m_TransmissionPolicy__transmitRatio->setID(false);
    m_TransmissionPolicy__chunkSize->setEType(m_DataSizeEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_TransmissionPolicy__chunkSize), "chunkSize", true,
            false, false, "", false, false, true, true, 0, 1, false, false);
    m_TransmissionPolicy__chunkSize->setContainment(true);
    m_TransmissionPolicy__chunkSize->setResolveProxies(false);
    // Quantity
    m_QuantityEClass->setName("Quantity");
    m_QuantityEClass->setAbstract(true);
    m_QuantityEClass->setInterface(false);
    // TimeComparable
    m_TimeComparableEClass->setName("TimeComparable");
    m_TimeComparableEClass->setAbstract(true);
    m_TimeComparableEClass->setInterface(true);
    // Time
    m_TimeEClass->setName("Time");
    m_TimeEClass->setAbstract(false);
    m_TimeEClass->setInterface(false);
    m_Time__value->setEType(
            dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEBigInteger());
    initEStructuralFeature(::ecore::as < ::ecore::EAttribute > (m_Time__value),
            "value", true, false, false, "0", false, false, true, false, 0, 1,
            false, false);
    m_Time__value->setID(false);
    m_Time__unit->setEType(m_TimeUnitEEnum);
    initEStructuralFeature(::ecore::as < ::ecore::EAttribute > (m_Time__unit),
            "unit", true, false, false, "", false, false, true, false, 0, 1,
            false, false);
    m_Time__unit->setID(false);
    {
        ::ecore::EOperation_ptr _op = addEOperation(m_TimeEClass, nullptr,
                "toString", 0, 1, false, true);
        _op->setEType(
                dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEString());
    }
    {
        ::ecore::EOperation_ptr _op = addEOperation(m_TimeEClass, nullptr,
                "compareTo", 0, 1, false, true);
        _op->setEType(
                dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEInt());
        {
            ::ecore::EParameter_ptr _pa = addEParameter(_op, "t", 0, 1, false,
                    true);
            _pa->setEType(m_TimeEClass);
        }
    }
    {
        ::ecore::EOperation_ptr _op = addEOperation(m_TimeEClass, nullptr,
                "adjustUnit", 0, 1, false, true);
        _op->setEType(m_TimeEClass);
    }
    {
        ::ecore::EOperation_ptr _op = addEOperation(m_TimeEClass, nullptr,
                "add", 0, 1, false, true);
        _op->setEType(m_TimeEClass);
        {
            ::ecore::EParameter_ptr _pa = addEParameter(_op, "t", 0, 1, false,
                    true);
            _pa->setEType(m_TimeEClass);
        }
    }
    {
        ::ecore::EOperation_ptr _op = addEOperation(m_TimeEClass, nullptr,
                "subtract", 0, 1, false, true);
        _op->setEType(m_TimeEClass);
        {
            ::ecore::EParameter_ptr _pa = addEParameter(_op, "t", 0, 1, false,
                    true);
            _pa->setEType(m_TimeEClass);
        }
    }
    {
        ::ecore::EOperation_ptr _op = addEOperation(m_TimeEClass, nullptr,
                "multiply", 0, 1, false, true);
        _op->setEType(m_TimeEClass);
        {
            ::ecore::EParameter_ptr _pa = addEParameter(_op, "v", 0, 1, false,
                    true);
            _pa->setEType(
                    dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getELong());
        }
    }
    {
        ::ecore::EOperation_ptr _op = addEOperation(m_TimeEClass, nullptr,
                "multiply", 0, 1, false, true);
        _op->setEType(m_TimeEClass);
        {
            ::ecore::EParameter_ptr _pa = addEParameter(_op, "v", 0, 1, false,
                    true);
            _pa->setEType(
                    dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEDouble());
        }
    }
    {
        ::ecore::EOperation_ptr _op = addEOperation(m_TimeEClass, nullptr,
                "divide", 0, 1, false, true);
        _op->setEType(
                dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEDouble());
        {
            ::ecore::EParameter_ptr _pa = addEParameter(_op, "t", 0, 1, false,
                    true);
            _pa->setEType(m_TimeEClass);
        }
    }
    // Frequency
    m_FrequencyEClass->setName("Frequency");
    m_FrequencyEClass->setAbstract(false);
    m_FrequencyEClass->setInterface(false);
    m_Frequency__value->setEType(m_NonNegativeDoubleEDataType);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute > (m_Frequency__value), "value",
            true, false, false, "0.0", false, false, true, false, 0, 1, false,
            false);
    m_Frequency__value->setID(false);
    m_Frequency__unit->setEType(m_FrequencyUnitEEnum);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute > (m_Frequency__unit), "unit",
            true, false, false, "", false, false, true, false, 0, 1, false,
            false);
    m_Frequency__unit->setID(false);
    {
        ::ecore::EOperation_ptr _op = addEOperation(m_FrequencyEClass, nullptr,
                "toString", 0, 1, false, true);
        _op->setEType(
                dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEString());
    }
    // Voltage
    m_VoltageEClass->setName("Voltage");
    m_VoltageEClass->setAbstract(false);
    m_VoltageEClass->setInterface(false);
    m_Voltage__value->setEType(
            dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEDouble());
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute > (m_Voltage__value), "value",
            true, false, false, "0.0", false, false, true, false, 0, 1, false,
            false);
    m_Voltage__value->setID(false);
    m_Voltage__unit->setEType(m_VoltageUnitEEnum);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute > (m_Voltage__unit), "unit", true,
            false, false, "", false, false, true, false, 0, 1, false, false);
    m_Voltage__unit->setID(false);
    {
        ::ecore::EOperation_ptr _op = addEOperation(m_VoltageEClass, nullptr,
                "toString", 0, 1, false, true);
        _op->setEType(
                dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEString());
    }
    // DataSize
    m_DataSizeEClass->setName("DataSize");
    m_DataSizeEClass->setAbstract(false);
    m_DataSizeEClass->setInterface(false);
    m_DataSize__value->setEType(
            dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEBigInteger());
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute > (m_DataSize__value), "value",
            true, false, false, "0", false, false, true, false, 0, 1, false,
            false);
    m_DataSize__value->setID(false);
    m_DataSize__unit->setEType(m_DataSizeUnitEEnum);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute > (m_DataSize__unit), "unit",
            true, false, false, "", false, false, true, false, 0, 1, false,
            false);
    m_DataSize__unit->setID(false);
    {
        ::ecore::EOperation_ptr _op = addEOperation(m_DataSizeEClass, nullptr,
                "toString", 0, 1, false, true);
        _op->setEType(
                dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEString());
    }
    {
        ::ecore::EOperation_ptr _op = addEOperation(m_DataSizeEClass, nullptr,
                "getNumberBits", 0, 1, false, true);
        _op->setEType(
                dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getELong());
    }
    {
        ::ecore::EOperation_ptr _op = addEOperation(m_DataSizeEClass, nullptr,
                "getNumberBytes", 0, 1, false, true);
        _op->setEType(
                dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getELong());
    }
    // DataRateComparable
    m_DataRateComparableEClass->setName("DataRateComparable");
    m_DataRateComparableEClass->setAbstract(true);
    m_DataRateComparableEClass->setInterface(true);
    // DataRate
    m_DataRateEClass->setName("DataRate");
    m_DataRateEClass->setAbstract(false);
    m_DataRateEClass->setInterface(false);
    m_DataRate__value->setEType(
            dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEBigInteger());
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute > (m_DataRate__value), "value",
            true, false, false, "0", false, false, true, false, 0, 1, false,
            false);
    m_DataRate__value->setID(false);
    m_DataRate__unit->setEType(m_DataRateUnitEEnum);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute > (m_DataRate__unit), "unit",
            true, false, false, "", false, false, true, false, 0, 1, false,
            false);
    m_DataRate__unit->setID(false);
    {
        ::ecore::EOperation_ptr _op = addEOperation(m_DataRateEClass, nullptr,
                "toString", 0, 1, false, true);
        _op->setEType(
                dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEString());
    }
    {
        ::ecore::EOperation_ptr _op = addEOperation(m_DataRateEClass, nullptr,
                "compareTo", 0, 1, false, true);
        _op->setEType(
                dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEInt());
        {
            ::ecore::EParameter_ptr _pa = addEParameter(_op, "rate", 0, 1,
                    false, true);
            _pa->setEType(m_DataRateEClass);
        }
    }
    // CustomProperty
    m_CustomPropertyEClass->setName("CustomProperty");
    m_CustomPropertyEClass->setAbstract(false);
    m_CustomPropertyEClass->setInterface(false);
    m_CustomProperty__key->setEType(
            dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEString());
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute > (m_CustomProperty__key), "key",
            true, false, false, "", false, false, true, false, 1, 1, false,
            true);
    m_CustomProperty__key->setID(false);
    m_CustomProperty__value->setEType(m_ValueEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_CustomProperty__value),
            "value", true, false, false, "", false, false, true, true, 0, 1,
            false, false);
    m_CustomProperty__value->setContainment(true);
    m_CustomProperty__value->setResolveProxies(false);
    // Value
    m_ValueEClass->setName("Value");
    m_ValueEClass->setAbstract(true);
    m_ValueEClass->setInterface(false);
    // ListObject
    m_ListObjectEClass->setName("ListObject");
    m_ListObjectEClass->setAbstract(false);
    m_ListObjectEClass->setInterface(false);
    m_ListObject__values->setEType(m_ValueEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_ListObject__values),
            "values", true, false, false, "", false, false, true, true, 0, -1,
            true, false);
    m_ListObject__values->setContainment(true);
    m_ListObject__values->setResolveProxies(false);
    // StringObject
    m_StringObjectEClass->setName("StringObject");
    m_StringObjectEClass->setAbstract(false);
    m_StringObjectEClass->setInterface(false);
    m_StringObject__value->setEType(
            dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEString());
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute > (m_StringObject__value),
            "value", true, false, false, "", false, false, true, false, 1, 1,
            false, true);
    m_StringObject__value->setID(false);
    // BigIntegerObject
    m_BigIntegerObjectEClass->setName("BigIntegerObject");
    m_BigIntegerObjectEClass->setAbstract(false);
    m_BigIntegerObjectEClass->setInterface(false);
    m_BigIntegerObject__value->setEType(
            dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEBigInteger());
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute > (m_BigIntegerObject__value),
            "value", true, false, false, "0", false, false, true, false, 1, 1,
            false, true);
    m_BigIntegerObject__value->setID(false);
    // ReferenceObject
    m_ReferenceObjectEClass->setName("ReferenceObject");
    m_ReferenceObjectEClass->setAbstract(false);
    m_ReferenceObjectEClass->setInterface(false);
    m_ReferenceObject__value->setEType(m_IReferableEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_ReferenceObject__value),
            "value", true, false, false, "", false, false, true, true, 0, 1,
            false, false);
    m_ReferenceObject__value->setContainment(false);
    m_ReferenceObject__value->setResolveProxies(true);
    // IntegerObject
    m_IntegerObjectEClass->setName("IntegerObject");
    m_IntegerObjectEClass->setAbstract(false);
    m_IntegerObjectEClass->setInterface(false);
    m_IntegerObject__value->setEType(
            dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEInt());
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute > (m_IntegerObject__value),
            "value", true, false, false, "0", false, false, true, false, 1, 1,
            false, true);
    m_IntegerObject__value->setID(false);
    // LongObject
    m_LongObjectEClass->setName("LongObject");
    m_LongObjectEClass->setAbstract(false);
    m_LongObjectEClass->setInterface(false);
    m_LongObject__value->setEType(
            dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getELong());
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute > (m_LongObject__value), "value",
            true, false, false, "0", false, false, true, false, 1, 1, false,
            true);
    m_LongObject__value->setID(false);
    // FloatObject
    m_FloatObjectEClass->setName("FloatObject");
    m_FloatObjectEClass->setAbstract(false);
    m_FloatObjectEClass->setInterface(false);
    m_FloatObject__value->setEType(
            dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEFloat());
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute > (m_FloatObject__value), "value",
            true, false, false, "0.0", false, false, true, false, 1, 1, false,
            true);
    m_FloatObject__value->setID(false);
    // DoubleObject
    m_DoubleObjectEClass->setName("DoubleObject");
    m_DoubleObjectEClass->setAbstract(false);
    m_DoubleObjectEClass->setInterface(false);
    m_DoubleObject__value->setEType(
            dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEDouble());
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute > (m_DoubleObject__value),
            "value", true, false, false, "0.0", false, false, true, false, 1, 1,
            false, true);
    m_DoubleObject__value->setID(false);
    // BooleanObject
    m_BooleanObjectEClass->setName("BooleanObject");
    m_BooleanObjectEClass->setAbstract(false);
    m_BooleanObjectEClass->setInterface(false);
    m_BooleanObject__value->setEType(
            dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEBoolean());
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute > (m_BooleanObject__value),
            "value", true, false, false, "false", false, false, true, false, 1,
            1, false, true);
    m_BooleanObject__value->setID(false);
    // NumericStatistic
    m_NumericStatisticEClass->setName("NumericStatistic");
    m_NumericStatisticEClass->setAbstract(true);
    m_NumericStatisticEClass->setInterface(true);
    // MinAvgMaxStatistic
    m_MinAvgMaxStatisticEClass->setName("MinAvgMaxStatistic");
    m_MinAvgMaxStatisticEClass->setAbstract(false);
    m_MinAvgMaxStatisticEClass->setInterface(false);
    m_MinAvgMaxStatistic__min->setEType(
            dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEInt());
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute > (m_MinAvgMaxStatistic__min),
            "min", true, false, false, "0", false, false, true, false, 0, 1,
            false, false);
    m_MinAvgMaxStatistic__min->setID(false);
    m_MinAvgMaxStatistic__avg->setEType(
            dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEFloat());
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute > (m_MinAvgMaxStatistic__avg),
            "avg", true, false, false, "", false, false, true, false, 0, 1,
            false, false);
    m_MinAvgMaxStatistic__avg->setID(false);
    m_MinAvgMaxStatistic__max->setEType(
            dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEInt());
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute > (m_MinAvgMaxStatistic__max),
            "max", true, false, false, "0", false, false, true, false, 0, 1,
            false, false);
    m_MinAvgMaxStatistic__max->setID(false);
    {
        ::ecore::EOperation_ptr _op = addEOperation(m_MinAvgMaxStatisticEClass,
                nullptr, "validateInvariants", 0, 1, false, true);
        _op->setEType(
                dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEBoolean());
        {
            ::ecore::EParameter_ptr _pa = addEParameter(_op, "diagnostics", 0,
                    1, false, true);
            _pa->setEType(
                    dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEDiagnosticChain());
        }
        {
            ::ecore::EParameter_ptr _pa = addEParameter(_op, "context", 0, 1,
                    false, true);
            _pa->setEType(
                    dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEMap());
            {
                ::ecore::EGenericType_ptr _g0 = ::ecore::Ptr
                        < ::ecore::EGenericType > (new ::ecore::EGenericType);
                _g0->setEClassifier(
                        dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEMap());
                ::ecore::EGenericType_ptr _g1 = ::ecore::Ptr
                        < ::ecore::EGenericType > (new ::ecore::EGenericType);
                _g1->setEClassifier(
                        dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEJavaObject());
                _g0->getETypeArguments().push_back(_g1);
                ::ecore::EGenericType_ptr _g2 = ::ecore::Ptr
                        < ::ecore::EGenericType > (new ::ecore::EGenericType);
                _g2->setEClassifier(
                        dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEJavaObject());
                _g0->getETypeArguments().push_back(_g2);
                _pa->setEGenericType(_g0);
            }
        }
    }
    // SingleValueStatistic
    m_SingleValueStatisticEClass->setName("SingleValueStatistic");
    m_SingleValueStatisticEClass->setAbstract(false);
    m_SingleValueStatisticEClass->setInterface(false);
    m_SingleValueStatistic__value->setEType(
            dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEFloat());
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute > (m_SingleValueStatistic__value),
            "value", true, false, false, "", false, false, true, false, 0, 1,
            false, false);
    m_SingleValueStatistic__value->setID(false);
    // ITimeDeviation
    m_ITimeDeviationEClass->setName("ITimeDeviation");
    m_ITimeDeviationEClass->setAbstract(true);
    m_ITimeDeviationEClass->setInterface(true);
    {
        ::ecore::EOperation_ptr _op = addEOperation(m_ITimeDeviationEClass,
                nullptr, "getLowerBound", 0, 1, false, true);
        _op->setEType(m_TimeEClass);
    }
    {
        ::ecore::EOperation_ptr _op = addEOperation(m_ITimeDeviationEClass,
                nullptr, "getUpperBound", 0, 1, false, true);
        _op->setEType(m_TimeEClass);
    }
    {
        ::ecore::EOperation_ptr _op = addEOperation(m_ITimeDeviationEClass,
                nullptr, "getAverage", 0, 1, false, true);
        _op->setEType(m_TimeEClass);
    }
    // TimeInterval
    m_TimeIntervalEClass->setName("TimeInterval");
    m_TimeIntervalEClass->setAbstract(true);
    m_TimeIntervalEClass->setInterface(false);
    m_TimeInterval__lowerBound->setEType(m_TimeEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_TimeInterval__lowerBound),
            "lowerBound", true, false, false, "", false, false, true, true, 1,
            1, false, true);
    m_TimeInterval__lowerBound->setContainment(true);
    m_TimeInterval__lowerBound->setResolveProxies(false);
    m_TimeInterval__upperBound->setEType(m_TimeEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_TimeInterval__upperBound),
            "upperBound", true, false, false, "", false, false, true, true, 1,
            1, false, true);
    m_TimeInterval__upperBound->setContainment(true);
    m_TimeInterval__upperBound->setResolveProxies(false);
    {
        ::ecore::EOperation_ptr _op = addEOperation(m_TimeIntervalEClass,
                nullptr, "getAverage", 0, 1, false, true);
        _op->setEType(m_TimeEClass);
    }
    {
        ::ecore::EOperation_ptr _op = addEOperation(m_TimeIntervalEClass,
                nullptr, "validateInvariants", 0, 1, false, true);
        _op->setEType(
                dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEBoolean());
        {
            ::ecore::EParameter_ptr _pa = addEParameter(_op, "diagnostics", 0,
                    1, false, true);
            _pa->setEType(
                    dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEDiagnosticChain());
        }
        {
            ::ecore::EParameter_ptr _pa = addEParameter(_op, "context", 0, 1,
                    false, true);
            _pa->setEType(
                    dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEMap());
            {
                ::ecore::EGenericType_ptr _g0 = ::ecore::Ptr
                        < ::ecore::EGenericType > (new ::ecore::EGenericType);
                _g0->setEClassifier(
                        dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEMap());
                ::ecore::EGenericType_ptr _g1 = ::ecore::Ptr
                        < ::ecore::EGenericType > (new ::ecore::EGenericType);
                _g1->setEClassifier(
                        dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEJavaObject());
                _g0->getETypeArguments().push_back(_g1);
                ::ecore::EGenericType_ptr _g2 = ::ecore::Ptr
                        < ::ecore::EGenericType > (new ::ecore::EGenericType);
                _g2->setEClassifier(
                        dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEJavaObject());
                _g0->getETypeArguments().push_back(_g2);
                _pa->setEGenericType(_g0);
            }
        }
    }
    // TimeConstant
    m_TimeConstantEClass->setName("TimeConstant");
    m_TimeConstantEClass->setAbstract(false);
    m_TimeConstantEClass->setInterface(false);
    m_TimeConstant__value->setEType(m_TimeEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_TimeConstant__value),
            "value", true, false, false, "", false, false, true, true, 1, 1,
            false, true);
    m_TimeConstant__value->setContainment(true);
    m_TimeConstant__value->setResolveProxies(false);
    {
        ::ecore::EOperation_ptr _op = addEOperation(m_TimeConstantEClass,
                nullptr, "getLowerBound", 0, 1, false, true);
        _op->setEType(m_TimeEClass);
    }
    {
        ::ecore::EOperation_ptr _op = addEOperation(m_TimeConstantEClass,
                nullptr, "getUpperBound", 0, 1, false, true);
        _op->setEType(m_TimeEClass);
    }
    {
        ::ecore::EOperation_ptr _op = addEOperation(m_TimeConstantEClass,
                nullptr, "getAverage", 0, 1, false, true);
        _op->setEType(m_TimeEClass);
    }
    // TimeHistogram
    m_TimeHistogramEClass->setName("TimeHistogram");
    m_TimeHistogramEClass->setAbstract(false);
    m_TimeHistogramEClass->setInterface(false);
    m_TimeHistogram__entries->setEType(m_TimeHistogramEntryEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_TimeHistogram__entries),
            "entries", true, false, false, "", false, false, true, true, 1, -1,
            true, true);
    m_TimeHistogram__entries->setContainment(true);
    m_TimeHistogram__entries->setResolveProxies(false);
    {
        ::ecore::EOperation_ptr _op = addEOperation(m_TimeHistogramEClass,
                nullptr, "getLowerBound", 0, 1, false, true);
        _op->setEType(m_TimeEClass);
    }
    {
        ::ecore::EOperation_ptr _op = addEOperation(m_TimeHistogramEClass,
                nullptr, "getUpperBound", 0, 1, false, true);
        _op->setEType(m_TimeEClass);
    }
    {
        ::ecore::EOperation_ptr _op = addEOperation(m_TimeHistogramEClass,
                nullptr, "getAverage", 0, 1, false, true);
        _op->setEType(m_TimeEClass);
    }
    // TimeHistogramEntry
    m_TimeHistogramEntryEClass->setName("TimeHistogramEntry");
    m_TimeHistogramEntryEClass->setAbstract(false);
    m_TimeHistogramEntryEClass->setInterface(false);
    m_TimeHistogramEntry__occurrences->setEType(m_PositiveLongEDataType);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute
                    > (m_TimeHistogramEntry__occurrences), "occurrences", true,
            false, false, "1", false, false, true, false, 1, 1, false, true);
    m_TimeHistogramEntry__occurrences->setID(false);
    // BoundedTimeDistribution
    m_BoundedTimeDistributionEClass->setName("BoundedTimeDistribution");
    m_BoundedTimeDistributionEClass->setAbstract(true);
    m_BoundedTimeDistributionEClass->setInterface(false);
    // TruncatedTimeDistribution
    m_TruncatedTimeDistributionEClass->setName("TruncatedTimeDistribution");
    m_TruncatedTimeDistributionEClass->setAbstract(true);
    m_TruncatedTimeDistributionEClass->setInterface(false);
    m_TruncatedTimeDistribution__lowerBound->setEType(m_TimeEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_TruncatedTimeDistribution__lowerBound), "lowerBound",
            true, false, false, "", false, false, true, true, 0, 1, false,
            false);
    m_TruncatedTimeDistribution__lowerBound->setContainment(true);
    m_TruncatedTimeDistribution__lowerBound->setResolveProxies(false);
    m_TruncatedTimeDistribution__upperBound->setEType(m_TimeEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_TruncatedTimeDistribution__upperBound), "upperBound",
            true, false, false, "", false, false, true, true, 0, 1, false,
            false);
    m_TruncatedTimeDistribution__upperBound->setContainment(true);
    m_TruncatedTimeDistribution__upperBound->setResolveProxies(false);
    {
        ::ecore::EOperation_ptr _op = addEOperation(
                m_TruncatedTimeDistributionEClass, nullptr,
                "validateInvariants", 0, 1, false, true);
        _op->setEType(
                dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEBoolean());
        {
            ::ecore::EParameter_ptr _pa = addEParameter(_op, "diagnostics", 0,
                    1, false, true);
            _pa->setEType(
                    dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEDiagnosticChain());
        }
        {
            ::ecore::EParameter_ptr _pa = addEParameter(_op, "context", 0, 1,
                    false, true);
            _pa->setEType(
                    dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEMap());
            {
                ::ecore::EGenericType_ptr _g0 = ::ecore::Ptr
                        < ::ecore::EGenericType > (new ::ecore::EGenericType);
                _g0->setEClassifier(
                        dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEMap());
                ::ecore::EGenericType_ptr _g1 = ::ecore::Ptr
                        < ::ecore::EGenericType > (new ::ecore::EGenericType);
                _g1->setEClassifier(
                        dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEJavaObject());
                _g0->getETypeArguments().push_back(_g1);
                ::ecore::EGenericType_ptr _g2 = ::ecore::Ptr
                        < ::ecore::EGenericType > (new ::ecore::EGenericType);
                _g2->setEClassifier(
                        dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEJavaObject());
                _g0->getETypeArguments().push_back(_g2);
                _pa->setEGenericType(_g0);
            }
        }
    }
    // TimeBoundaries
    m_TimeBoundariesEClass->setName("TimeBoundaries");
    m_TimeBoundariesEClass->setAbstract(false);
    m_TimeBoundariesEClass->setInterface(false);
    m_TimeBoundaries__samplingType->setEType(m_SamplingTypeEEnum);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute
                    > (m_TimeBoundaries__samplingType), "samplingType", true,
            false, false, "", false, false, true, false, 0, 1, false, false);
    m_TimeBoundaries__samplingType->setID(false);
    // TimeStatistics
    m_TimeStatisticsEClass->setName("TimeStatistics");
    m_TimeStatisticsEClass->setAbstract(false);
    m_TimeStatisticsEClass->setInterface(false);
    m_TimeStatistics__average->setEType(m_TimeEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_TimeStatistics__average),
            "average", true, false, false, "", false, false, true, true, 1, 1,
            false, true);
    m_TimeStatistics__average->setContainment(true);
    m_TimeStatistics__average->setResolveProxies(false);
    // TimeUniformDistribution
    m_TimeUniformDistributionEClass->setName("TimeUniformDistribution");
    m_TimeUniformDistributionEClass->setAbstract(false);
    m_TimeUniformDistributionEClass->setInterface(false);
    // TimeGaussDistribution
    m_TimeGaussDistributionEClass->setName("TimeGaussDistribution");
    m_TimeGaussDistributionEClass->setAbstract(false);
    m_TimeGaussDistributionEClass->setInterface(false);
    m_TimeGaussDistribution__mean->setEType(m_TimeEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_TimeGaussDistribution__mean),
            "mean", true, false, false, "", false, false, true, true, 1, 1,
            false, true);
    m_TimeGaussDistribution__mean->setContainment(true);
    m_TimeGaussDistribution__mean->setResolveProxies(false);
    m_TimeGaussDistribution__sd->setEType(m_TimeEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_TimeGaussDistribution__sd),
            "sd", true, false, false, "", false, false, true, true, 1, 1, false,
            true);
    m_TimeGaussDistribution__sd->setContainment(true);
    m_TimeGaussDistribution__sd->setResolveProxies(false);
    {
        ::ecore::EOperation_ptr _op = addEOperation(
                m_TimeGaussDistributionEClass, nullptr, "getAverage", 0, 1,
                false, true);
        _op->setEType(m_TimeEClass);
    }
    // TimeWeibullEstimatorsDistribution
    m_TimeWeibullEstimatorsDistributionEClass->setName(
            "TimeWeibullEstimatorsDistribution");
    m_TimeWeibullEstimatorsDistributionEClass->setAbstract(false);
    m_TimeWeibullEstimatorsDistributionEClass->setInterface(false);
    m_TimeWeibullEstimatorsDistribution__pRemainPromille->setEType(
            m_PositiveDoubleEDataType);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute
                    > (m_TimeWeibullEstimatorsDistribution__pRemainPromille),
            "pRemainPromille", true, false, false, "1.0", false, false, true,
            false, 1, 1, false, true);
    m_TimeWeibullEstimatorsDistribution__pRemainPromille->setID(false);
    m_TimeWeibullEstimatorsDistribution__average->setEType(m_TimeEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_TimeWeibullEstimatorsDistribution__average), "average",
            true, false, false, "", false, false, true, true, 1, 1, false,
            true);
    m_TimeWeibullEstimatorsDistribution__average->setContainment(true);
    m_TimeWeibullEstimatorsDistribution__average->setResolveProxies(false);
    // TimeBetaDistribution
    m_TimeBetaDistributionEClass->setName("TimeBetaDistribution");
    m_TimeBetaDistributionEClass->setAbstract(false);
    m_TimeBetaDistributionEClass->setInterface(false);
    m_TimeBetaDistribution__alpha->setEType(m_PositiveDoubleEDataType);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute > (m_TimeBetaDistribution__alpha),
            "alpha", true, false, false, "1.0", false, false, true, false, 1, 1,
            false, true);
    m_TimeBetaDistribution__alpha->setID(false);
    m_TimeBetaDistribution__beta->setEType(m_PositiveDoubleEDataType);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute > (m_TimeBetaDistribution__beta),
            "beta", true, false, false, "1.0", false, false, true, false, 1, 1,
            false, true);
    m_TimeBetaDistribution__beta->setID(false);
    {
        ::ecore::EOperation_ptr _op = addEOperation(
                m_TimeBetaDistributionEClass, nullptr, "getAverage", 0, 1,
                false, true);
        _op->setEType(m_TimeEClass);
    }
    // IDiscreteValueDeviation
    m_IDiscreteValueDeviationEClass->setName("IDiscreteValueDeviation");
    m_IDiscreteValueDeviationEClass->setAbstract(true);
    m_IDiscreteValueDeviationEClass->setInterface(true);
    {
        ::ecore::EOperation_ptr _op = addEOperation(
                m_IDiscreteValueDeviationEClass, nullptr, "getLowerBound", 0, 1,
                false, true);
        _op->setEType(
                dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getELongObject());
    }
    {
        ::ecore::EOperation_ptr _op = addEOperation(
                m_IDiscreteValueDeviationEClass, nullptr, "getUpperBound", 0, 1,
                false, true);
        _op->setEType(
                dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getELongObject());
    }
    {
        ::ecore::EOperation_ptr _op = addEOperation(
                m_IDiscreteValueDeviationEClass, nullptr, "getAverage", 0, 1,
                false, true);
        _op->setEType(
                dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEDoubleObject());
    }
    // DiscreteValueInterval
    m_DiscreteValueIntervalEClass->setName("DiscreteValueInterval");
    m_DiscreteValueIntervalEClass->setAbstract(true);
    m_DiscreteValueIntervalEClass->setInterface(false);
    m_DiscreteValueInterval__lowerBound->setEType(
            dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getELongObject());
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute
                    > (m_DiscreteValueInterval__lowerBound), "lowerBound", true,
            false, false, "0", false, false, true, false, 1, 1, false, true);
    m_DiscreteValueInterval__lowerBound->setID(false);
    m_DiscreteValueInterval__upperBound->setEType(
            dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getELongObject());
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute
                    > (m_DiscreteValueInterval__upperBound), "upperBound", true,
            false, false, "0", false, false, true, false, 1, 1, false, true);
    m_DiscreteValueInterval__upperBound->setID(false);
    {
        ::ecore::EOperation_ptr _op = addEOperation(
                m_DiscreteValueIntervalEClass, nullptr, "getAverage", 0, 1,
                false, true);
        _op->setEType(
                dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEDoubleObject());
    }
    {
        ::ecore::EOperation_ptr _op = addEOperation(
                m_DiscreteValueIntervalEClass, nullptr, "validateInvariants", 0,
                1, false, true);
        _op->setEType(
                dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEBoolean());
        {
            ::ecore::EParameter_ptr _pa = addEParameter(_op, "diagnostics", 0,
                    1, false, true);
            _pa->setEType(
                    dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEDiagnosticChain());
        }
        {
            ::ecore::EParameter_ptr _pa = addEParameter(_op, "context", 0, 1,
                    false, true);
            _pa->setEType(
                    dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEMap());
            {
                ::ecore::EGenericType_ptr _g0 = ::ecore::Ptr
                        < ::ecore::EGenericType > (new ::ecore::EGenericType);
                _g0->setEClassifier(
                        dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEMap());
                ::ecore::EGenericType_ptr _g1 = ::ecore::Ptr
                        < ::ecore::EGenericType > (new ::ecore::EGenericType);
                _g1->setEClassifier(
                        dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEJavaObject());
                _g0->getETypeArguments().push_back(_g1);
                ::ecore::EGenericType_ptr _g2 = ::ecore::Ptr
                        < ::ecore::EGenericType > (new ::ecore::EGenericType);
                _g2->setEClassifier(
                        dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEJavaObject());
                _g0->getETypeArguments().push_back(_g2);
                _pa->setEGenericType(_g0);
            }
        }
    }
    // DiscreteValueConstant
    m_DiscreteValueConstantEClass->setName("DiscreteValueConstant");
    m_DiscreteValueConstantEClass->setAbstract(false);
    m_DiscreteValueConstantEClass->setInterface(false);
    m_DiscreteValueConstant__value->setEType(
            dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getELong());
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute
                    > (m_DiscreteValueConstant__value), "value", true, false,
            false, "0", false, false, true, false, 1, 1, false, true);
    m_DiscreteValueConstant__value->setID(false);
    {
        ::ecore::EOperation_ptr _op = addEOperation(
                m_DiscreteValueConstantEClass, nullptr, "getLowerBound", 0, 1,
                false, true);
        _op->setEType(
                dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getELongObject());
    }
    {
        ::ecore::EOperation_ptr _op = addEOperation(
                m_DiscreteValueConstantEClass, nullptr, "getUpperBound", 0, 1,
                false, true);
        _op->setEType(
                dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getELongObject());
    }
    {
        ::ecore::EOperation_ptr _op = addEOperation(
                m_DiscreteValueConstantEClass, nullptr, "getAverage", 0, 1,
                false, true);
        _op->setEType(
                dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEDoubleObject());
    }
    // DiscreteValueHistogram
    m_DiscreteValueHistogramEClass->setName("DiscreteValueHistogram");
    m_DiscreteValueHistogramEClass->setAbstract(false);
    m_DiscreteValueHistogramEClass->setInterface(false);
    m_DiscreteValueHistogram__entries->setEType(
            m_DiscreteValueHistogramEntryEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_DiscreteValueHistogram__entries), "entries", true,
            false, false, "", false, false, true, true, 1, -1, true, true);
    m_DiscreteValueHistogram__entries->setContainment(true);
    m_DiscreteValueHistogram__entries->setResolveProxies(false);
    {
        ::ecore::EOperation_ptr _op = addEOperation(
                m_DiscreteValueHistogramEClass, nullptr, "getLowerBound", 0, 1,
                false, true);
        _op->setEType(
                dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getELongObject());
    }
    {
        ::ecore::EOperation_ptr _op = addEOperation(
                m_DiscreteValueHistogramEClass, nullptr, "getUpperBound", 0, 1,
                false, true);
        _op->setEType(
                dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getELongObject());
    }
    {
        ::ecore::EOperation_ptr _op = addEOperation(
                m_DiscreteValueHistogramEClass, nullptr, "getAverage", 0, 1,
                false, true);
        _op->setEType(
                dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEDoubleObject());
    }
    // DiscreteValueHistogramEntry
    m_DiscreteValueHistogramEntryEClass->setName("DiscreteValueHistogramEntry");
    m_DiscreteValueHistogramEntryEClass->setAbstract(false);
    m_DiscreteValueHistogramEntryEClass->setInterface(false);
    m_DiscreteValueHistogramEntry__occurrences->setEType(
            m_PositiveLongEDataType);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute
                    > (m_DiscreteValueHistogramEntry__occurrences),
            "occurrences", true, false, false, "1", false, false, true, false,
            1, 1, false, true);
    m_DiscreteValueHistogramEntry__occurrences->setID(false);
    // BoundedDiscreteValueDistribution
    m_BoundedDiscreteValueDistributionEClass->setName(
            "BoundedDiscreteValueDistribution");
    m_BoundedDiscreteValueDistributionEClass->setAbstract(true);
    m_BoundedDiscreteValueDistributionEClass->setInterface(false);
    // TruncatedDiscreteValueDistribution
    m_TruncatedDiscreteValueDistributionEClass->setName(
            "TruncatedDiscreteValueDistribution");
    m_TruncatedDiscreteValueDistributionEClass->setAbstract(true);
    m_TruncatedDiscreteValueDistributionEClass->setInterface(false);
    m_TruncatedDiscreteValueDistribution__lowerBound->setEType(
            dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getELongObject());
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute
                    > (m_TruncatedDiscreteValueDistribution__lowerBound),
            "lowerBound", true, false, false, "", false, false, true, false, 0,
            1, false, false);
    m_TruncatedDiscreteValueDistribution__lowerBound->setID(false);
    m_TruncatedDiscreteValueDistribution__upperBound->setEType(
            dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getELongObject());
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute
                    > (m_TruncatedDiscreteValueDistribution__upperBound),
            "upperBound", true, false, false, "", false, false, true, false, 0,
            1, false, false);
    m_TruncatedDiscreteValueDistribution__upperBound->setID(false);
    {
        ::ecore::EOperation_ptr _op = addEOperation(
                m_TruncatedDiscreteValueDistributionEClass, nullptr,
                "validateInvariants", 0, 1, false, true);
        _op->setEType(
                dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEBoolean());
        {
            ::ecore::EParameter_ptr _pa = addEParameter(_op, "diagnostics", 0,
                    1, false, true);
            _pa->setEType(
                    dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEDiagnosticChain());
        }
        {
            ::ecore::EParameter_ptr _pa = addEParameter(_op, "context", 0, 1,
                    false, true);
            _pa->setEType(
                    dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEMap());
            {
                ::ecore::EGenericType_ptr _g0 = ::ecore::Ptr
                        < ::ecore::EGenericType > (new ::ecore::EGenericType);
                _g0->setEClassifier(
                        dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEMap());
                ::ecore::EGenericType_ptr _g1 = ::ecore::Ptr
                        < ::ecore::EGenericType > (new ::ecore::EGenericType);
                _g1->setEClassifier(
                        dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEJavaObject());
                _g0->getETypeArguments().push_back(_g1);
                ::ecore::EGenericType_ptr _g2 = ::ecore::Ptr
                        < ::ecore::EGenericType > (new ::ecore::EGenericType);
                _g2->setEClassifier(
                        dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEJavaObject());
                _g0->getETypeArguments().push_back(_g2);
                _pa->setEGenericType(_g0);
            }
        }
    }
    // DiscreteValueBoundaries
    m_DiscreteValueBoundariesEClass->setName("DiscreteValueBoundaries");
    m_DiscreteValueBoundariesEClass->setAbstract(false);
    m_DiscreteValueBoundariesEClass->setInterface(false);
    m_DiscreteValueBoundaries__samplingType->setEType(m_SamplingTypeEEnum);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute
                    > (m_DiscreteValueBoundaries__samplingType), "samplingType",
            true, false, false, "", false, false, true, false, 0, 1, false,
            false);
    m_DiscreteValueBoundaries__samplingType->setID(false);
    // DiscreteValueStatistics
    m_DiscreteValueStatisticsEClass->setName("DiscreteValueStatistics");
    m_DiscreteValueStatisticsEClass->setAbstract(false);
    m_DiscreteValueStatisticsEClass->setInterface(false);
    m_DiscreteValueStatistics__average->setEType(
            dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEDoubleObject());
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute
                    > (m_DiscreteValueStatistics__average), "average", true,
            false, false, "0.0", false, false, true, false, 1, 1, false, true);
    m_DiscreteValueStatistics__average->setID(false);
    // DiscreteValueUniformDistribution
    m_DiscreteValueUniformDistributionEClass->setName(
            "DiscreteValueUniformDistribution");
    m_DiscreteValueUniformDistributionEClass->setAbstract(false);
    m_DiscreteValueUniformDistributionEClass->setInterface(false);
    // DiscreteValueGaussDistribution
    m_DiscreteValueGaussDistributionEClass->setName(
            "DiscreteValueGaussDistribution");
    m_DiscreteValueGaussDistributionEClass->setAbstract(false);
    m_DiscreteValueGaussDistributionEClass->setInterface(false);
    m_DiscreteValueGaussDistribution__mean->setEType(
            dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEDouble());
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute
                    > (m_DiscreteValueGaussDistribution__mean), "mean", true,
            false, false, "0.0", false, false, true, false, 1, 1, false, true);
    m_DiscreteValueGaussDistribution__mean->setID(false);
    m_DiscreteValueGaussDistribution__sd->setEType(m_PositiveDoubleEDataType);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute
                    > (m_DiscreteValueGaussDistribution__sd), "sd", true, false,
            false, "1.0", false, false, true, false, 1, 1, false, true);
    m_DiscreteValueGaussDistribution__sd->setID(false);
    {
        ::ecore::EOperation_ptr _op = addEOperation(
                m_DiscreteValueGaussDistributionEClass, nullptr, "getAverage",
                0, 1, false, true);
        _op->setEType(
                dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEDoubleObject());
    }
    // DiscreteValueWeibullEstimatorsDistribution
    m_DiscreteValueWeibullEstimatorsDistributionEClass->setName(
            "DiscreteValueWeibullEstimatorsDistribution");
    m_DiscreteValueWeibullEstimatorsDistributionEClass->setAbstract(false);
    m_DiscreteValueWeibullEstimatorsDistributionEClass->setInterface(false);
    m_DiscreteValueWeibullEstimatorsDistribution__average->setEType(
            dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEDoubleObject());
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute
                    > (m_DiscreteValueWeibullEstimatorsDistribution__average),
            "average", true, false, false, "0.0", false, false, true, false, 1,
            1, false, true);
    m_DiscreteValueWeibullEstimatorsDistribution__average->setID(false);
    m_DiscreteValueWeibullEstimatorsDistribution__pRemainPromille->setEType(
            m_PositiveDoubleEDataType);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute
                    > (m_DiscreteValueWeibullEstimatorsDistribution__pRemainPromille),
            "pRemainPromille", true, false, false, "1.0", false, false, true,
            false, 1, 1, false, true);
    m_DiscreteValueWeibullEstimatorsDistribution__pRemainPromille->setID(false);
    // DiscreteValueBetaDistribution
    m_DiscreteValueBetaDistributionEClass->setName(
            "DiscreteValueBetaDistribution");
    m_DiscreteValueBetaDistributionEClass->setAbstract(false);
    m_DiscreteValueBetaDistributionEClass->setInterface(false);
    m_DiscreteValueBetaDistribution__alpha->setEType(m_PositiveDoubleEDataType);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute
                    > (m_DiscreteValueBetaDistribution__alpha), "alpha", true,
            false, false, "1.0", false, false, true, false, 1, 1, false, true);
    m_DiscreteValueBetaDistribution__alpha->setID(false);
    m_DiscreteValueBetaDistribution__beta->setEType(m_PositiveDoubleEDataType);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute
                    > (m_DiscreteValueBetaDistribution__beta), "beta", true,
            false, false, "1.0", false, false, true, false, 1, 1, false, true);
    m_DiscreteValueBetaDistribution__beta->setID(false);
    {
        ::ecore::EOperation_ptr _op = addEOperation(
                m_DiscreteValueBetaDistributionEClass, nullptr, "getAverage", 0,
                1, false, true);
        _op->setEType(
                dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEDoubleObject());
    }
    // IContinuousValueDeviation
    m_IContinuousValueDeviationEClass->setName("IContinuousValueDeviation");
    m_IContinuousValueDeviationEClass->setAbstract(true);
    m_IContinuousValueDeviationEClass->setInterface(true);
    {
        ::ecore::EOperation_ptr _op = addEOperation(
                m_IContinuousValueDeviationEClass, nullptr, "getLowerBound", 0,
                1, false, true);
        _op->setEType(
                dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEDoubleObject());
    }
    {
        ::ecore::EOperation_ptr _op = addEOperation(
                m_IContinuousValueDeviationEClass, nullptr, "getUpperBound", 0,
                1, false, true);
        _op->setEType(
                dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEDoubleObject());
    }
    {
        ::ecore::EOperation_ptr _op = addEOperation(
                m_IContinuousValueDeviationEClass, nullptr, "getAverage", 0, 1,
                false, true);
        _op->setEType(
                dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEDoubleObject());
    }
    // ContinuousValueInterval
    m_ContinuousValueIntervalEClass->setName("ContinuousValueInterval");
    m_ContinuousValueIntervalEClass->setAbstract(true);
    m_ContinuousValueIntervalEClass->setInterface(false);
    m_ContinuousValueInterval__lowerBound->setEType(
            dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEDoubleObject());
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute
                    > (m_ContinuousValueInterval__lowerBound), "lowerBound",
            true, false, false, "0.0", false, false, true, false, 1, 1, false,
            true);
    m_ContinuousValueInterval__lowerBound->setID(false);
    m_ContinuousValueInterval__upperBound->setEType(
            dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEDoubleObject());
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute
                    > (m_ContinuousValueInterval__upperBound), "upperBound",
            true, false, false, "0.0", false, false, true, false, 1, 1, false,
            true);
    m_ContinuousValueInterval__upperBound->setID(false);
    {
        ::ecore::EOperation_ptr _op = addEOperation(
                m_ContinuousValueIntervalEClass, nullptr, "getAverage", 0, 1,
                false, true);
        _op->setEType(
                dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEDoubleObject());
    }
    {
        ::ecore::EOperation_ptr _op = addEOperation(
                m_ContinuousValueIntervalEClass, nullptr, "validateInvariants",
                0, 1, false, true);
        _op->setEType(
                dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEBoolean());
        {
            ::ecore::EParameter_ptr _pa = addEParameter(_op, "diagnostics", 0,
                    1, false, true);
            _pa->setEType(
                    dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEDiagnosticChain());
        }
        {
            ::ecore::EParameter_ptr _pa = addEParameter(_op, "context", 0, 1,
                    false, true);
            _pa->setEType(
                    dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEMap());
            {
                ::ecore::EGenericType_ptr _g0 = ::ecore::Ptr
                        < ::ecore::EGenericType > (new ::ecore::EGenericType);
                _g0->setEClassifier(
                        dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEMap());
                ::ecore::EGenericType_ptr _g1 = ::ecore::Ptr
                        < ::ecore::EGenericType > (new ::ecore::EGenericType);
                _g1->setEClassifier(
                        dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEJavaObject());
                _g0->getETypeArguments().push_back(_g1);
                ::ecore::EGenericType_ptr _g2 = ::ecore::Ptr
                        < ::ecore::EGenericType > (new ::ecore::EGenericType);
                _g2->setEClassifier(
                        dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEJavaObject());
                _g0->getETypeArguments().push_back(_g2);
                _pa->setEGenericType(_g0);
            }
        }
    }
    // ContinuousValueConstant
    m_ContinuousValueConstantEClass->setName("ContinuousValueConstant");
    m_ContinuousValueConstantEClass->setAbstract(false);
    m_ContinuousValueConstantEClass->setInterface(false);
    m_ContinuousValueConstant__value->setEType(
            dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEDouble());
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute
                    > (m_ContinuousValueConstant__value), "value", true, false,
            false, "0.0", false, false, true, false, 1, 1, false, true);
    m_ContinuousValueConstant__value->setID(false);
    {
        ::ecore::EOperation_ptr _op = addEOperation(
                m_ContinuousValueConstantEClass, nullptr, "getLowerBound", 0, 1,
                false, true);
        _op->setEType(
                dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEDoubleObject());
    }
    {
        ::ecore::EOperation_ptr _op = addEOperation(
                m_ContinuousValueConstantEClass, nullptr, "getUpperBound", 0, 1,
                false, true);
        _op->setEType(
                dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEDoubleObject());
    }
    {
        ::ecore::EOperation_ptr _op = addEOperation(
                m_ContinuousValueConstantEClass, nullptr, "getAverage", 0, 1,
                false, true);
        _op->setEType(
                dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEDoubleObject());
    }
    // ContinuousValueHistogram
    m_ContinuousValueHistogramEClass->setName("ContinuousValueHistogram");
    m_ContinuousValueHistogramEClass->setAbstract(false);
    m_ContinuousValueHistogramEClass->setInterface(false);
    m_ContinuousValueHistogram__entries->setEType(
            m_ContinuousValueHistogramEntryEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_ContinuousValueHistogram__entries), "entries", true,
            false, false, "", false, false, true, true, 1, -1, true, true);
    m_ContinuousValueHistogram__entries->setContainment(true);
    m_ContinuousValueHistogram__entries->setResolveProxies(false);
    {
        ::ecore::EOperation_ptr _op = addEOperation(
                m_ContinuousValueHistogramEClass, nullptr, "getLowerBound", 0,
                1, false, true);
        _op->setEType(
                dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEDoubleObject());
    }
    {
        ::ecore::EOperation_ptr _op = addEOperation(
                m_ContinuousValueHistogramEClass, nullptr, "getUpperBound", 0,
                1, false, true);
        _op->setEType(
                dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEDoubleObject());
    }
    {
        ::ecore::EOperation_ptr _op = addEOperation(
                m_ContinuousValueHistogramEClass, nullptr, "getAverage", 0, 1,
                false, true);
        _op->setEType(
                dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEDoubleObject());
    }
    // ContinuousValueHistogramEntry
    m_ContinuousValueHistogramEntryEClass->setName(
            "ContinuousValueHistogramEntry");
    m_ContinuousValueHistogramEntryEClass->setAbstract(false);
    m_ContinuousValueHistogramEntryEClass->setInterface(false);
    m_ContinuousValueHistogramEntry__occurrences->setEType(
            m_PositiveLongEDataType);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute
                    > (m_ContinuousValueHistogramEntry__occurrences),
            "occurrences", true, false, false, "1", false, false, true, false,
            1, 1, false, true);
    m_ContinuousValueHistogramEntry__occurrences->setID(false);
    // BoundedContinuousValueDistribution
    m_BoundedContinuousValueDistributionEClass->setName(
            "BoundedContinuousValueDistribution");
    m_BoundedContinuousValueDistributionEClass->setAbstract(true);
    m_BoundedContinuousValueDistributionEClass->setInterface(false);
    // TruncatedContinuousValueDistribution
    m_TruncatedContinuousValueDistributionEClass->setName(
            "TruncatedContinuousValueDistribution");
    m_TruncatedContinuousValueDistributionEClass->setAbstract(true);
    m_TruncatedContinuousValueDistributionEClass->setInterface(false);
    m_TruncatedContinuousValueDistribution__lowerBound->setEType(
            dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEDoubleObject());
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute
                    > (m_TruncatedContinuousValueDistribution__lowerBound),
            "lowerBound", true, false, false, "", false, false, true, false, 0,
            1, false, false);
    m_TruncatedContinuousValueDistribution__lowerBound->setID(false);
    m_TruncatedContinuousValueDistribution__upperBound->setEType(
            dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEDoubleObject());
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute
                    > (m_TruncatedContinuousValueDistribution__upperBound),
            "upperBound", true, false, false, "", false, false, true, false, 0,
            1, false, false);
    m_TruncatedContinuousValueDistribution__upperBound->setID(false);
    {
        ::ecore::EOperation_ptr _op = addEOperation(
                m_TruncatedContinuousValueDistributionEClass, nullptr,
                "validateInvariants", 0, 1, false, true);
        _op->setEType(
                dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEBoolean());
        {
            ::ecore::EParameter_ptr _pa = addEParameter(_op, "diagnostics", 0,
                    1, false, true);
            _pa->setEType(
                    dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEDiagnosticChain());
        }
        {
            ::ecore::EParameter_ptr _pa = addEParameter(_op, "context", 0, 1,
                    false, true);
            _pa->setEType(
                    dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEMap());
            {
                ::ecore::EGenericType_ptr _g0 = ::ecore::Ptr
                        < ::ecore::EGenericType > (new ::ecore::EGenericType);
                _g0->setEClassifier(
                        dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEMap());
                ::ecore::EGenericType_ptr _g1 = ::ecore::Ptr
                        < ::ecore::EGenericType > (new ::ecore::EGenericType);
                _g1->setEClassifier(
                        dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEJavaObject());
                _g0->getETypeArguments().push_back(_g1);
                ::ecore::EGenericType_ptr _g2 = ::ecore::Ptr
                        < ::ecore::EGenericType > (new ::ecore::EGenericType);
                _g2->setEClassifier(
                        dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEJavaObject());
                _g0->getETypeArguments().push_back(_g2);
                _pa->setEGenericType(_g0);
            }
        }
    }
    // ContinuousValueBoundaries
    m_ContinuousValueBoundariesEClass->setName("ContinuousValueBoundaries");
    m_ContinuousValueBoundariesEClass->setAbstract(false);
    m_ContinuousValueBoundariesEClass->setInterface(false);
    m_ContinuousValueBoundaries__samplingType->setEType(m_SamplingTypeEEnum);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute
                    > (m_ContinuousValueBoundaries__samplingType),
            "samplingType", true, false, false, "", false, false, true, false,
            0, 1, false, false);
    m_ContinuousValueBoundaries__samplingType->setID(false);
    // ContinuousValueStatistics
    m_ContinuousValueStatisticsEClass->setName("ContinuousValueStatistics");
    m_ContinuousValueStatisticsEClass->setAbstract(false);
    m_ContinuousValueStatisticsEClass->setInterface(false);
    m_ContinuousValueStatistics__average->setEType(
            dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEDoubleObject());
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute
                    > (m_ContinuousValueStatistics__average), "average", true,
            false, false, "0.0", false, false, true, false, 1, 1, false, true);
    m_ContinuousValueStatistics__average->setID(false);
    // ContinuousValueUniformDistribution
    m_ContinuousValueUniformDistributionEClass->setName(
            "ContinuousValueUniformDistribution");
    m_ContinuousValueUniformDistributionEClass->setAbstract(false);
    m_ContinuousValueUniformDistributionEClass->setInterface(false);
    // ContinuousValueGaussDistribution
    m_ContinuousValueGaussDistributionEClass->setName(
            "ContinuousValueGaussDistribution");
    m_ContinuousValueGaussDistributionEClass->setAbstract(false);
    m_ContinuousValueGaussDistributionEClass->setInterface(false);
    m_ContinuousValueGaussDistribution__mean->setEType(
            dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEDouble());
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute
                    > (m_ContinuousValueGaussDistribution__mean), "mean", true,
            false, false, "0.0", false, false, true, false, 1, 1, false, true);
    m_ContinuousValueGaussDistribution__mean->setID(false);
    m_ContinuousValueGaussDistribution__sd->setEType(m_PositiveDoubleEDataType);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute
                    > (m_ContinuousValueGaussDistribution__sd), "sd", true,
            false, false, "1.0", false, false, true, false, 1, 1, false, true);
    m_ContinuousValueGaussDistribution__sd->setID(false);
    {
        ::ecore::EOperation_ptr _op = addEOperation(
                m_ContinuousValueGaussDistributionEClass, nullptr, "getAverage",
                0, 1, false, true);
        _op->setEType(
                dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEDoubleObject());
    }
    // ContinuousValueWeibullEstimatorsDistribution
    m_ContinuousValueWeibullEstimatorsDistributionEClass->setName(
            "ContinuousValueWeibullEstimatorsDistribution");
    m_ContinuousValueWeibullEstimatorsDistributionEClass->setAbstract(false);
    m_ContinuousValueWeibullEstimatorsDistributionEClass->setInterface(false);
    m_ContinuousValueWeibullEstimatorsDistribution__average->setEType(
            dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEDoubleObject());
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute
                    > (m_ContinuousValueWeibullEstimatorsDistribution__average),
            "average", true, false, false, "0.0", false, false, true, false, 1,
            1, false, true);
    m_ContinuousValueWeibullEstimatorsDistribution__average->setID(false);
    m_ContinuousValueWeibullEstimatorsDistribution__pRemainPromille->setEType(
            m_PositiveDoubleEDataType);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute
                    > (m_ContinuousValueWeibullEstimatorsDistribution__pRemainPromille),
            "pRemainPromille", true, false, false, "1.0", false, false, true,
            false, 1, 1, false, true);
    m_ContinuousValueWeibullEstimatorsDistribution__pRemainPromille->setID(
            false);
    // ContinuousValueBetaDistribution
    m_ContinuousValueBetaDistributionEClass->setName(
            "ContinuousValueBetaDistribution");
    m_ContinuousValueBetaDistributionEClass->setAbstract(false);
    m_ContinuousValueBetaDistributionEClass->setInterface(false);
    m_ContinuousValueBetaDistribution__alpha->setEType(
            m_PositiveDoubleEDataType);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute
                    > (m_ContinuousValueBetaDistribution__alpha), "alpha", true,
            false, false, "1.0", false, false, true, false, 1, 1, false, true);
    m_ContinuousValueBetaDistribution__alpha->setID(false);
    m_ContinuousValueBetaDistribution__beta->setEType(
            m_PositiveDoubleEDataType);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute
                    > (m_ContinuousValueBetaDistribution__beta), "beta", true,
            false, false, "1.0", false, false, true, false, 1, 1, false, true);
    m_ContinuousValueBetaDistribution__beta->setID(false);
    {
        ::ecore::EOperation_ptr _op = addEOperation(
                m_ContinuousValueBetaDistributionEClass, nullptr, "getAverage",
                0, 1, false, true);
        _op->setEType(
                dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEDoubleObject());
    }
    // Mode
    m_ModeEClass->setName("Mode");
    m_ModeEClass->setAbstract(true);
    m_ModeEClass->setInterface(false);
    // NumericMode
    m_NumericModeEClass->setName("NumericMode");
    m_NumericModeEClass->setAbstract(false);
    m_NumericModeEClass->setInterface(false);
    // EnumMode
    m_EnumModeEClass->setName("EnumMode");
    m_EnumModeEClass->setAbstract(false);
    m_EnumModeEClass->setInterface(false);
    m_EnumMode__literals->setEType(m_ModeLiteralEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_EnumMode__literals),
            "literals", true, false, false, "", false, false, true, true, 0, -1,
            true, false);
    m_EnumMode__literals->setContainment(true);
    m_EnumMode__literals->setResolveProxies(false);
    m_EnumMode__literals->setEOpposite(
            ::ecore::as < ::ecore::EReference
                    > (m_ModeLiteralEClass->getEStructuralFeatures()[0]));
    {
        ::ecore::EOperation_ptr _op = addEOperation(m_EnumModeEClass, nullptr,
                "getLiteral", 0, 1, false, true);
        _op->setEType(m_ModeLiteralEClass);
        {
            ::ecore::EParameter_ptr _pa = addEParameter(_op, "literal", 0, 1,
                    false, true);
            _pa->setEType(
                    dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEString());
        }
    }
    // ModeLiteral
    m_ModeLiteralEClass->setName("ModeLiteral");
    m_ModeLiteralEClass->setAbstract(false);
    m_ModeLiteralEClass->setInterface(false);
    m_ModeLiteral__containingMode->setEType(m_EnumModeEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_ModeLiteral__containingMode),
            "containingMode", false, false, false, "", false, false, true, true,
            0, 1, false, false);
    m_ModeLiteral__containingMode->setContainment(false);
    m_ModeLiteral__containingMode->setResolveProxies(true);
    m_ModeLiteral__containingMode->setEOpposite(
            ::ecore::as < ::ecore::EReference
                    > (m_EnumModeEClass->getEStructuralFeatures()[0]));
    {
        ::ecore::EOperation_ptr _op = addEOperation(m_ModeLiteralEClass,
                nullptr, "getNamePrefixSegments", 0, -1, false, true);
        _op->setEType(
                dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEString());
    }
    {
        ::ecore::EOperation_ptr _op = addEOperation(m_ModeLiteralEClass,
                nullptr, "toString", 0, 1, false, true);
        _op->setEType(
                dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEString());
    }
    // ComponentsModel
    m_ComponentsModelEClass->setName("ComponentsModel");
    m_ComponentsModelEClass->setAbstract(false);
    m_ComponentsModelEClass->setInterface(false);
    m_ComponentsModel__structures->setEType(m_ComponentStructureEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_ComponentsModel__structures),
            "structures", true, false, false, "", false, false, true, true, 0,
            -1, true, false);
    m_ComponentsModel__structures->setContainment(true);
    m_ComponentsModel__structures->setResolveProxies(false);
    m_ComponentsModel__systems->setEType(m_SystemEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_ComponentsModel__systems),
            "systems", true, false, false, "", false, false, true, true, 0, -1,
            true, false);
    m_ComponentsModel__systems->setContainment(true);
    m_ComponentsModel__systems->setResolveProxies(false);
    // IComponentContainer
    m_IComponentContainerEClass->setName("IComponentContainer");
    m_IComponentContainerEClass->setAbstract(true);
    m_IComponentContainerEClass->setInterface(true);
    m_IComponentContainer__components->setEType(m_ComponentEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_IComponentContainer__components), "components", true,
            false, false, "", false, false, true, true, 0, -1, true, false);
    m_IComponentContainer__components->setContainment(true);
    m_IComponentContainer__components->setResolveProxies(false);
    // IInterfaceContainer
    m_IInterfaceContainerEClass->setName("IInterfaceContainer");
    m_IInterfaceContainerEClass->setAbstract(true);
    m_IInterfaceContainerEClass->setInterface(true);
    m_IInterfaceContainer__interfaces->setEType(m_MainInterfaceEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_IInterfaceContainer__interfaces), "interfaces", true,
            false, false, "", false, false, true, true, 0, -1, true, false);
    m_IInterfaceContainer__interfaces->setContainment(true);
    m_IInterfaceContainer__interfaces->setResolveProxies(false);
    // ISystem
    m_ISystemEClass->setName("ISystem");
    m_ISystemEClass->setAbstract(true);
    m_ISystemEClass->setInterface(true);
    m_ISystem__componentInstances->setEType(m_ComponentInstanceEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_ISystem__componentInstances),
            "componentInstances", true, false, false, "", false, false, true,
            true, 0, -1, true, false);
    m_ISystem__componentInstances->setContainment(true);
    m_ISystem__componentInstances->setResolveProxies(false);
    m_ISystem__componentInstances->setEOpposite(
            ::ecore::as < ::ecore::EReference
                    > (m_ComponentInstanceEClass->getEStructuralFeatures()[0]));
    m_ISystem__connectors->setEType(m_ConnectorEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_ISystem__connectors),
            "connectors", true, false, false, "", false, false, true, true, 0,
            -1, true, false);
    m_ISystem__connectors->setContainment(true);
    m_ISystem__connectors->setResolveProxies(false);
    m_ISystem__connectors->setEOpposite(
            ::ecore::as < ::ecore::EReference
                    > (m_ConnectorEClass->getEStructuralFeatures()[0]));
    m_ISystem__groundedPorts->setEType(m_QualifiedPortEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_ISystem__groundedPorts),
            "groundedPorts", true, false, false, "", false, false, true, true,
            0, -1, true, false);
    m_ISystem__groundedPorts->setContainment(true);
    m_ISystem__groundedPorts->setResolveProxies(false);
    m_ISystem__innerPorts->setEType(m_QualifiedPortEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_ISystem__innerPorts),
            "innerPorts", false, true, true, "", false, true, true, true, 0, -1,
            true, false);
    m_ISystem__innerPorts->setContainment(false);
    m_ISystem__innerPorts->setResolveProxies(true);
    // ComponentInterface
    m_ComponentInterfaceEClass->setName("ComponentInterface");
    m_ComponentInterfaceEClass->setAbstract(true);
    m_ComponentInterfaceEClass->setInterface(false);
    m_ComponentInterface__datatype->setEType(m_TypeDefinitionEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_ComponentInterface__datatype), "datatype", true, false,
            false, "", false, false, true, true, 0, 1, false, false);
    m_ComponentInterface__datatype->setContainment(false);
    m_ComponentInterface__datatype->setResolveProxies(true);
    m_ComponentInterface__subInterfaces->setEType(m_SubInterfaceEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_ComponentInterface__subInterfaces), "subInterfaces",
            true, false, false, "", false, false, true, true, 0, -1, true,
            false);
    m_ComponentInterface__subInterfaces->setContainment(true);
    m_ComponentInterface__subInterfaces->setResolveProxies(false);
    m_ComponentInterface__subInterfaces->setEOpposite(
            ::ecore::as < ::ecore::EReference
                    > (m_SubInterfaceEClass->getEStructuralFeatures()[0]));
    // MainInterface
    m_MainInterfaceEClass->setName("MainInterface");
    m_MainInterfaceEClass->setAbstract(false);
    m_MainInterfaceEClass->setInterface(false);
    m_MainInterface__version->setEType(
            dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEString());
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute > (m_MainInterface__version),
            "version", true, false, false, "1.0", false, false, true, false, 0,
            1, false, false);
    m_MainInterface__version->setID(false);
    // SubInterface
    m_SubInterfaceEClass->setName("SubInterface");
    m_SubInterfaceEClass->setAbstract(false);
    m_SubInterfaceEClass->setInterface(false);
    m_SubInterface__containingInterface->setEType(m_ComponentInterfaceEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_SubInterface__containingInterface),
            "containingInterface", false, false, false, "", false, false, true,
            true, 0, 1, false, false);
    m_SubInterface__containingInterface->setContainment(false);
    m_SubInterface__containingInterface->setResolveProxies(true);
    m_SubInterface__containingInterface->setEOpposite(
            ::ecore::as < ::ecore::EReference
                    > (m_ComponentInterfaceEClass->getEStructuralFeatures()[1]));
    {
        ::ecore::EOperation_ptr _op = addEOperation(m_SubInterfaceEClass,
                nullptr, "getNamePrefixSegments", 0, -1, false, true);
        _op->setEType(
                dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEString());
    }
    // ComponentPort
    m_ComponentPortEClass->setName("ComponentPort");
    m_ComponentPortEClass->setAbstract(false);
    m_ComponentPortEClass->setInterface(false);
    m_ComponentPort__kind->setEType(m_InterfaceKindEEnum);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute > (m_ComponentPort__kind), "kind",
            true, false, false, "", false, false, true, false, 0, 1, false,
            false);
    m_ComponentPort__kind->setID(false);
    m_ComponentPort__containingComponent->setEType(m_ComponentEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_ComponentPort__containingComponent),
            "containingComponent", false, false, false, "", false, false, true,
            true, 0, 1, false, false);
    m_ComponentPort__containingComponent->setContainment(false);
    m_ComponentPort__containingComponent->setResolveProxies(true);
    m_ComponentPort__containingComponent->setEOpposite(
            ::ecore::as < ::ecore::EReference
                    > (m_ComponentEClass->getEStructuralFeatures()[0]));
    m_ComponentPort__interface->setEType(m_ComponentInterfaceEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_ComponentPort__interface),
            "interface", true, false, false, "", false, false, true, true, 0, 1,
            false, false);
    m_ComponentPort__interface->setContainment(false);
    m_ComponentPort__interface->setResolveProxies(true);
    {
        ::ecore::EOperation_ptr _op = addEOperation(m_ComponentPortEClass,
                nullptr, "getNamePrefixSegments", 0, -1, false, true);
        _op->setEType(
                dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEString());
    }
    // ComponentStructure
    m_ComponentStructureEClass->setName("ComponentStructure");
    m_ComponentStructureEClass->setAbstract(false);
    m_ComponentStructureEClass->setInterface(false);
    m_ComponentStructure__structureType->setEType(
            dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEString());
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute
                    > (m_ComponentStructure__structureType), "structureType",
            true, false, false, "", false, false, true, false, 0, 1, false,
            false);
    m_ComponentStructure__structureType->setID(false);
    m_ComponentStructure__subStructures->setEType(m_ComponentStructureEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_ComponentStructure__subStructures), "subStructures",
            true, false, false, "", false, false, true, true, 0, -1, true,
            false);
    m_ComponentStructure__subStructures->setContainment(true);
    m_ComponentStructure__subStructures->setResolveProxies(false);
    m_ComponentStructure__memberObjects->setEType(
            m_IComponentStructureMemberEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_ComponentStructure__memberObjects), "memberObjects",
            false, true, true, "", false, true, true, true, 0, -1, true, false);
    m_ComponentStructure__memberObjects->setContainment(false);
    m_ComponentStructure__memberObjects->setResolveProxies(true);
    {
        ::ecore::EOperation_ptr _op = addEOperation(m_ComponentStructureEClass,
                nullptr, "getContainingStructure", 0, 1, false, true);
        _op->setEType(m_ComponentStructureEClass);
    }
    {
        ::ecore::EOperation_ptr _op = addEOperation(m_ComponentStructureEClass,
                nullptr, "getDefaultNameSeparator", 0, 1, false, true);
        _op->setEType(
                dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEString());
    }
    {
        ::ecore::EOperation_ptr _op = addEOperation(m_ComponentStructureEClass,
                nullptr, "getNamePrefixSegments", 0, -1, false, true);
        _op->setEType(
                dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEString());
    }
    // IComponentStructureMember
    m_IComponentStructureMemberEClass->setName("IComponentStructureMember");
    m_IComponentStructureMemberEClass->setAbstract(true);
    m_IComponentStructureMemberEClass->setInterface(true);
    m_IComponentStructureMember__structure->setEType(
            m_ComponentStructureEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_IComponentStructureMember__structure), "structure",
            true, false, false, "", false, false, true, true, 0, 1, false,
            false);
    m_IComponentStructureMember__structure->setContainment(false);
    m_IComponentStructureMember__structure->setResolveProxies(true);
    // Component
    m_ComponentEClass->setName("Component");
    m_ComponentEClass->setAbstract(false);
    m_ComponentEClass->setInterface(false);
    m_Component__ports->setEType(m_ComponentPortEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_Component__ports), "ports",
            true, false, false, "", false, false, true, true, 0, -1, true,
            false);
    m_Component__ports->setContainment(true);
    m_Component__ports->setResolveProxies(false);
    m_Component__ports->setEOpposite(
            ::ecore::as < ::ecore::EReference
                    > (m_ComponentPortEClass->getEStructuralFeatures()[1]));
    m_Component__processes->setEType(m_AbstractProcessEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_Component__processes),
            "processes", true, false, false, "", false, false, true, true, 0,
            -1, true, false);
    m_Component__processes->setContainment(false);
    m_Component__processes->setResolveProxies(true);
    m_Component__runnables->setEType(m_RunnableEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_Component__runnables),
            "runnables", true, false, false, "", false, false, true, true, 0,
            -1, true, false);
    m_Component__runnables->setContainment(false);
    m_Component__runnables->setResolveProxies(true);
    m_Component__labels->setEType(m_LabelEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_Component__labels), "labels",
            true, false, false, "", false, false, true, true, 0, -1, true,
            false);
    m_Component__labels->setContainment(false);
    m_Component__labels->setResolveProxies(true);
    m_Component__semaphores->setEType(m_SemaphoreEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_Component__semaphores),
            "semaphores", true, false, false, "", false, false, true, true, 0,
            -1, true, false);
    m_Component__semaphores->setContainment(false);
    m_Component__semaphores->setResolveProxies(true);
    m_Component__osEvents->setEType(m_OsEventEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_Component__osEvents),
            "osEvents", true, false, false, "", false, false, true, true, 0, -1,
            true, false);
    m_Component__osEvents->setContainment(false);
    m_Component__osEvents->setResolveProxies(true);
    // Composite
    m_CompositeEClass->setName("Composite");
    m_CompositeEClass->setAbstract(false);
    m_CompositeEClass->setInterface(false);
    // System
    m_SystemEClass->setName("System");
    m_SystemEClass->setAbstract(false);
    m_SystemEClass->setInterface(false);
    // ComponentInstance
    m_ComponentInstanceEClass->setName("ComponentInstance");
    m_ComponentInstanceEClass->setAbstract(false);
    m_ComponentInstanceEClass->setInterface(false);
    m_ComponentInstance__containingSystem->setEType(m_ISystemEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_ComponentInstance__containingSystem),
            "containingSystem", true, false, false, "", false, false, true,
            true, 0, 1, false, false);
    m_ComponentInstance__containingSystem->setContainment(false);
    m_ComponentInstance__containingSystem->setResolveProxies(true);
    m_ComponentInstance__containingSystem->setEOpposite(
            ::ecore::as < ::ecore::EReference
                    > (m_ISystemEClass->getEStructuralFeatures()[0]));
    m_ComponentInstance__type->setEType(m_ComponentEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_ComponentInstance__type),
            "type", true, false, false, "", false, false, true, true, 0, 1,
            false, false);
    m_ComponentInstance__type->setContainment(false);
    m_ComponentInstance__type->setResolveProxies(true);
    {
        ::ecore::EOperation_ptr _op = addEOperation(m_ComponentInstanceEClass,
                nullptr, "getNamePrefixSegments", 0, -1, false, true);
        _op->setEType(
                dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEString());
    }
    // Connector
    m_ConnectorEClass->setName("Connector");
    m_ConnectorEClass->setAbstract(false);
    m_ConnectorEClass->setInterface(false);
    m_Connector__containingSystem->setEType(m_ISystemEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_Connector__containingSystem),
            "containingSystem", true, false, false, "", false, false, true,
            true, 0, 1, false, false);
    m_Connector__containingSystem->setContainment(false);
    m_Connector__containingSystem->setResolveProxies(true);
    m_Connector__containingSystem->setEOpposite(
            ::ecore::as < ::ecore::EReference
                    > (m_ISystemEClass->getEStructuralFeatures()[1]));
    m_Connector__sourcePort->setEType(m_QualifiedPortEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_Connector__sourcePort),
            "sourcePort", true, false, false, "", false, false, true, true, 0,
            1, false, false);
    m_Connector__sourcePort->setContainment(true);
    m_Connector__sourcePort->setResolveProxies(false);
    m_Connector__targetPort->setEType(m_QualifiedPortEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_Connector__targetPort),
            "targetPort", true, false, false, "", false, false, true, true, 0,
            1, false, false);
    m_Connector__targetPort->setContainment(true);
    m_Connector__targetPort->setResolveProxies(false);
    m_Connector__implementedInterfaces->setEType(m_InterfaceChannelEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_Connector__implementedInterfaces),
            "implementedInterfaces", true, false, false, "", false, false, true,
            true, 0, -1, true, false);
    m_Connector__implementedInterfaces->setContainment(true);
    m_Connector__implementedInterfaces->setResolveProxies(false);
    // InterfaceChannel
    m_InterfaceChannelEClass->setName("InterfaceChannel");
    m_InterfaceChannelEClass->setAbstract(false);
    m_InterfaceChannelEClass->setInterface(false);
    m_InterfaceChannel__key->setEType(m_ComponentInterfaceEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_InterfaceChannel__key),
            "key", true, false, false, "", false, false, true, true, 1, 1,
            false, true);
    m_InterfaceChannel__key->setContainment(false);
    m_InterfaceChannel__key->setResolveProxies(true);
    m_InterfaceChannel__value->setEType(m_ChannelEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_InterfaceChannel__value),
            "value", true, false, false, "", false, false, true, true, 0, 1,
            false, false);
    m_InterfaceChannel__value->setContainment(false);
    m_InterfaceChannel__value->setResolveProxies(true);
    // QualifiedPort
    m_QualifiedPortEClass->setName("QualifiedPort");
    m_QualifiedPortEClass->setAbstract(false);
    m_QualifiedPortEClass->setInterface(false);
    m_QualifiedPort__instance->setEType(m_ComponentInstanceEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_QualifiedPort__instance),
            "instance", true, false, false, "", false, false, true, true, 0, 1,
            false, false);
    m_QualifiedPort__instance->setContainment(false);
    m_QualifiedPort__instance->setResolveProxies(true);
    m_QualifiedPort__port->setEType(m_ComponentPortEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_QualifiedPort__port), "port",
            true, false, false, "", false, false, true, true, 1, 1, false,
            true);
    m_QualifiedPort__port->setContainment(false);
    m_QualifiedPort__port->setResolveProxies(true);
    // ConfigModel
    m_ConfigModelEClass->setName("ConfigModel");
    m_ConfigModelEClass->setAbstract(false);
    m_ConfigModelEClass->setInterface(false);
    m_ConfigModel__eventsToTrace->setEType(m_EventConfigEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_ConfigModel__eventsToTrace),
            "eventsToTrace", true, false, false, "", false, false, true, true,
            0, -1, true, false);
    m_ConfigModel__eventsToTrace->setContainment(true);
    m_ConfigModel__eventsToTrace->setResolveProxies(false);
    // EventConfig
    m_EventConfigEClass->setName("EventConfig");
    m_EventConfigEClass->setAbstract(false);
    m_EventConfigEClass->setInterface(false);
    m_EventConfig__event->setEType(m_EntityEventEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_EventConfig__event), "event",
            true, false, false, "", false, false, true, true, 1, 1, false,
            true);
    m_EventConfig__event->setContainment(false);
    m_EventConfig__event->setResolveProxies(true);
    // ConstraintsModel
    m_ConstraintsModelEClass->setName("ConstraintsModel");
    m_ConstraintsModelEClass->setAbstract(false);
    m_ConstraintsModelEClass->setInterface(false);
    m_ConstraintsModel__eventChains->setEType(m_EventChainEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_ConstraintsModel__eventChains), "eventChains", true,
            false, false, "", false, false, true, true, 0, -1, true, false);
    m_ConstraintsModel__eventChains->setContainment(true);
    m_ConstraintsModel__eventChains->setResolveProxies(false);
    m_ConstraintsModel__timingConstraints->setEType(m_TimingConstraintEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_ConstraintsModel__timingConstraints),
            "timingConstraints", true, false, false, "", false, false, true,
            true, 0, -1, true, false);
    m_ConstraintsModel__timingConstraints->setContainment(true);
    m_ConstraintsModel__timingConstraints->setResolveProxies(false);
    m_ConstraintsModel__affinityConstraints->setEType(
            m_AffinityConstraintEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_ConstraintsModel__affinityConstraints),
            "affinityConstraints", true, false, false, "", false, false, true,
            true, 0, -1, true, false);
    m_ConstraintsModel__affinityConstraints->setContainment(true);
    m_ConstraintsModel__affinityConstraints->setResolveProxies(false);
    m_ConstraintsModel__runnableSequencingConstraints->setEType(
            m_RunnableSequencingConstraintEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_ConstraintsModel__runnableSequencingConstraints),
            "runnableSequencingConstraints", true, false, false, "", false,
            false, true, true, 0, -1, true, false);
    m_ConstraintsModel__runnableSequencingConstraints->setContainment(true);
    m_ConstraintsModel__runnableSequencingConstraints->setResolveProxies(false);
    m_ConstraintsModel__dataAgeConstraints->setEType(m_DataAgeConstraintEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_ConstraintsModel__dataAgeConstraints),
            "dataAgeConstraints", true, false, false, "", false, false, true,
            true, 0, -1, true, false);
    m_ConstraintsModel__dataAgeConstraints->setContainment(true);
    m_ConstraintsModel__dataAgeConstraints->setResolveProxies(false);
    m_ConstraintsModel__requirements->setEType(m_RequirementEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_ConstraintsModel__requirements), "requirements", true,
            false, false, "", false, false, true, true, 0, -1, true, false);
    m_ConstraintsModel__requirements->setContainment(true);
    m_ConstraintsModel__requirements->setResolveProxies(false);
    m_ConstraintsModel__dataCoherencyGroups->setEType(
            m_DataCoherencyGroupEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_ConstraintsModel__dataCoherencyGroups),
            "dataCoherencyGroups", true, false, false, "", false, false, true,
            true, 0, -1, true, false);
    m_ConstraintsModel__dataCoherencyGroups->setContainment(true);
    m_ConstraintsModel__dataCoherencyGroups->setResolveProxies(false);
    m_ConstraintsModel__dataStabilityGroups->setEType(
            m_DataStabilityGroupEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_ConstraintsModel__dataStabilityGroups),
            "dataStabilityGroups", true, false, false, "", false, false, true,
            true, 0, -1, true, false);
    m_ConstraintsModel__dataStabilityGroups->setContainment(true);
    m_ConstraintsModel__dataStabilityGroups->setResolveProxies(false);
    m_ConstraintsModel__physicalSectionConstraints->setEType(
            m_PhysicalSectionConstraintEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_ConstraintsModel__physicalSectionConstraints),
            "physicalSectionConstraints", true, false, false, "", false, false,
            true, true, 0, -1, true, false);
    m_ConstraintsModel__physicalSectionConstraints->setContainment(true);
    m_ConstraintsModel__physicalSectionConstraints->setResolveProxies(false);
    // RunnableSequencingConstraint
    m_RunnableSequencingConstraintEClass->setName(
            "RunnableSequencingConstraint");
    m_RunnableSequencingConstraintEClass->setAbstract(false);
    m_RunnableSequencingConstraintEClass->setInterface(false);
    m_RunnableSequencingConstraint__orderType->setEType(
            m_RunnableOrderTypeEEnum);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute
                    > (m_RunnableSequencingConstraint__orderType), "orderType",
            true, false, false, "", false, false, true, false, 0, 1, false,
            false);
    m_RunnableSequencingConstraint__orderType->setID(false);
    m_RunnableSequencingConstraint__runnableGroups->setEType(
            m_RunnableEntityGroupEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_RunnableSequencingConstraint__runnableGroups),
            "runnableGroups", true, false, false, "", false, false, true, true,
            2, -1, true, true);
    m_RunnableSequencingConstraint__runnableGroups->setContainment(true);
    m_RunnableSequencingConstraint__runnableGroups->setResolveProxies(false);
    m_RunnableSequencingConstraint__processScope->setEType(
            m_AbstractProcessEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_RunnableSequencingConstraint__processScope),
            "processScope", true, false, false, "", false, false, true, true, 0,
            -1, true, false);
    m_RunnableSequencingConstraint__processScope->setContainment(false);
    m_RunnableSequencingConstraint__processScope->setResolveProxies(true);
    // AffinityConstraint
    m_AffinityConstraintEClass->setName("AffinityConstraint");
    m_AffinityConstraintEClass->setAbstract(true);
    m_AffinityConstraintEClass->setInterface(false);
    // SeparationConstraint
    m_SeparationConstraintEClass->setName("SeparationConstraint");
    m_SeparationConstraintEClass->setAbstract(true);
    m_SeparationConstraintEClass->setInterface(false);
    // PairingConstraint
    m_PairingConstraintEClass->setName("PairingConstraint");
    m_PairingConstraintEClass->setAbstract(true);
    m_PairingConstraintEClass->setInterface(false);
    // ProcessConstraint
    m_ProcessConstraintEClass->setName("ProcessConstraint");
    m_ProcessConstraintEClass->setAbstract(true);
    m_ProcessConstraintEClass->setInterface(false);
    m_ProcessConstraint__target->setEType(m_ProcessConstraintTargetEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_ProcessConstraint__target),
            "target", true, false, false, "", false, false, true, true, 0, 1,
            false, false);
    m_ProcessConstraint__target->setContainment(true);
    m_ProcessConstraint__target->setResolveProxies(false);
    // RunnableConstraint
    m_RunnableConstraintEClass->setName("RunnableConstraint");
    m_RunnableConstraintEClass->setAbstract(true);
    m_RunnableConstraintEClass->setInterface(false);
    m_RunnableConstraint__target->setEType(m_RunnableConstraintTargetEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_RunnableConstraint__target),
            "target", true, false, false, "", false, false, true, true, 0, 1,
            false, false);
    m_RunnableConstraint__target->setContainment(true);
    m_RunnableConstraint__target->setResolveProxies(false);
    // DataConstraint
    m_DataConstraintEClass->setName("DataConstraint");
    m_DataConstraintEClass->setAbstract(true);
    m_DataConstraintEClass->setInterface(false);
    m_DataConstraint__target->setEType(m_DataConstraintTargetEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_DataConstraint__target),
            "target", true, false, false, "", false, false, true, true, 0, 1,
            false, false);
    m_DataConstraint__target->setContainment(true);
    m_DataConstraint__target->setResolveProxies(false);
    // RunnableSeparationConstraint
    m_RunnableSeparationConstraintEClass->setName(
            "RunnableSeparationConstraint");
    m_RunnableSeparationConstraintEClass->setAbstract(false);
    m_RunnableSeparationConstraintEClass->setInterface(false);
    m_RunnableSeparationConstraint__groups->setEType(m_RunnableGroupEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_RunnableSeparationConstraint__groups), "groups", true,
            false, false, "", false, false, true, true, 1, 2, true, true);
    m_RunnableSeparationConstraint__groups->setContainment(true);
    m_RunnableSeparationConstraint__groups->setResolveProxies(false);
    // ProcessSeparationConstraint
    m_ProcessSeparationConstraintEClass->setName("ProcessSeparationConstraint");
    m_ProcessSeparationConstraintEClass->setAbstract(false);
    m_ProcessSeparationConstraintEClass->setInterface(false);
    m_ProcessSeparationConstraint__groups->setEType(m_ProcessGroupEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_ProcessSeparationConstraint__groups), "groups", true,
            false, false, "", false, false, true, true, 1, 2, true, true);
    m_ProcessSeparationConstraint__groups->setContainment(true);
    m_ProcessSeparationConstraint__groups->setResolveProxies(false);
    // DataSeparationConstraint
    m_DataSeparationConstraintEClass->setName("DataSeparationConstraint");
    m_DataSeparationConstraintEClass->setAbstract(false);
    m_DataSeparationConstraintEClass->setInterface(false);
    m_DataSeparationConstraint__groups->setEType(m_LabelEntityGroupEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_DataSeparationConstraint__groups), "groups", true,
            false, false, "", false, false, true, true, 1, 2, true, true);
    m_DataSeparationConstraint__groups->setContainment(true);
    m_DataSeparationConstraint__groups->setResolveProxies(false);
    // RunnablePairingConstraint
    m_RunnablePairingConstraintEClass->setName("RunnablePairingConstraint");
    m_RunnablePairingConstraintEClass->setAbstract(false);
    m_RunnablePairingConstraintEClass->setInterface(false);
    m_RunnablePairingConstraint__group->setEType(m_RunnableGroupEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_RunnablePairingConstraint__group), "group", true,
            false, false, "", false, false, true, true, 1, 1, false, true);
    m_RunnablePairingConstraint__group->setContainment(true);
    m_RunnablePairingConstraint__group->setResolveProxies(false);
    // ProcessPairingConstraint
    m_ProcessPairingConstraintEClass->setName("ProcessPairingConstraint");
    m_ProcessPairingConstraintEClass->setAbstract(false);
    m_ProcessPairingConstraintEClass->setInterface(false);
    m_ProcessPairingConstraint__group->setEType(m_ProcessGroupEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_ProcessPairingConstraint__group), "group", true, false,
            false, "", false, false, true, true, 1, 1, false, true);
    m_ProcessPairingConstraint__group->setContainment(true);
    m_ProcessPairingConstraint__group->setResolveProxies(false);
    // DataPairingConstraint
    m_DataPairingConstraintEClass->setName("DataPairingConstraint");
    m_DataPairingConstraintEClass->setAbstract(false);
    m_DataPairingConstraintEClass->setInterface(false);
    m_DataPairingConstraint__group->setEType(m_LabelGroupEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_DataPairingConstraint__group), "group", true, false,
            false, "", false, false, true, true, 1, 1, false, true);
    m_DataPairingConstraint__group->setContainment(true);
    m_DataPairingConstraint__group->setResolveProxies(false);
    // RunnableConstraintTarget
    m_RunnableConstraintTargetEClass->setName("RunnableConstraintTarget");
    m_RunnableConstraintTargetEClass->setAbstract(true);
    m_RunnableConstraintTargetEClass->setInterface(false);
    // ProcessConstraintTarget
    m_ProcessConstraintTargetEClass->setName("ProcessConstraintTarget");
    m_ProcessConstraintTargetEClass->setAbstract(true);
    m_ProcessConstraintTargetEClass->setInterface(false);
    // DataConstraintTarget
    m_DataConstraintTargetEClass->setName("DataConstraintTarget");
    m_DataConstraintTargetEClass->setAbstract(true);
    m_DataConstraintTargetEClass->setInterface(false);
    // TargetMemory
    m_TargetMemoryEClass->setName("TargetMemory");
    m_TargetMemoryEClass->setAbstract(false);
    m_TargetMemoryEClass->setInterface(false);
    m_TargetMemory__memories->setEType(m_MemoryEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_TargetMemory__memories),
            "memories", true, false, false, "", false, false, true, true, 0, -1,
            true, false);
    m_TargetMemory__memories->setContainment(false);
    m_TargetMemory__memories->setResolveProxies(true);
    // TargetCore
    m_TargetCoreEClass->setName("TargetCore");
    m_TargetCoreEClass->setAbstract(false);
    m_TargetCoreEClass->setInterface(false);
    m_TargetCore__cores->setEType(m_ProcessingUnitEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_TargetCore__cores), "cores",
            true, false, false, "", false, false, true, true, 0, -1, true,
            false);
    m_TargetCore__cores->setContainment(false);
    m_TargetCore__cores->setResolveProxies(true);
    // TargetScheduler
    m_TargetSchedulerEClass->setName("TargetScheduler");
    m_TargetSchedulerEClass->setAbstract(false);
    m_TargetSchedulerEClass->setInterface(false);
    m_TargetScheduler__schedulers->setEType(m_SchedulerEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_TargetScheduler__schedulers),
            "schedulers", true, false, false, "", false, false, true, true, 0,
            -1, true, false);
    m_TargetScheduler__schedulers->setContainment(false);
    m_TargetScheduler__schedulers->setResolveProxies(true);
    // LabelGroup
    m_LabelGroupEClass->setName("LabelGroup");
    m_LabelGroupEClass->setAbstract(true);
    m_LabelGroupEClass->setInterface(false);
    // RunnableGroup
    m_RunnableGroupEClass->setName("RunnableGroup");
    m_RunnableGroupEClass->setAbstract(true);
    m_RunnableGroupEClass->setInterface(false);
    // ProcessGroup
    m_ProcessGroupEClass->setName("ProcessGroup");
    m_ProcessGroupEClass->setAbstract(true);
    m_ProcessGroupEClass->setInterface(false);
    // LabelEntityGroup
    m_LabelEntityGroupEClass->setName("LabelEntityGroup");
    m_LabelEntityGroupEClass->setAbstract(false);
    m_LabelEntityGroupEClass->setInterface(false);
    m_LabelEntityGroup__labels->setEType(m_LabelEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_LabelEntityGroup__labels),
            "labels", true, false, false, "", false, false, true, true, 1, -1,
            true, true);
    m_LabelEntityGroup__labels->setContainment(false);
    m_LabelEntityGroup__labels->setResolveProxies(true);
    // RunnableEntityGroup
    m_RunnableEntityGroupEClass->setName("RunnableEntityGroup");
    m_RunnableEntityGroupEClass->setAbstract(false);
    m_RunnableEntityGroupEClass->setInterface(false);
    m_RunnableEntityGroup__runnables->setEType(m_RunnableEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_RunnableEntityGroup__runnables), "runnables", true,
            false, false, "", false, false, true, true, 1, -1, true, true);
    m_RunnableEntityGroup__runnables->setContainment(false);
    m_RunnableEntityGroup__runnables->setResolveProxies(true);
    // ProcessEntityGroup
    m_ProcessEntityGroupEClass->setName("ProcessEntityGroup");
    m_ProcessEntityGroupEClass->setAbstract(false);
    m_ProcessEntityGroupEClass->setInterface(false);
    m_ProcessEntityGroup__processes->setEType(m_ProcessEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_ProcessEntityGroup__processes), "processes", true,
            false, false, "", false, false, true, true, 1, -1, true, true);
    m_ProcessEntityGroup__processes->setContainment(false);
    m_ProcessEntityGroup__processes->setResolveProxies(true);
    // TagGroup
    m_TagGroupEClass->setName("TagGroup");
    m_TagGroupEClass->setAbstract(false);
    m_TagGroupEClass->setInterface(false);
    m_TagGroup__tag->setEType(m_TagEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_TagGroup__tag), "tag", true,
            false, false, "", false, false, true, true, 1, 1, false, true);
    m_TagGroup__tag->setContainment(false);
    m_TagGroup__tag->setResolveProxies(true);
    // AbstractEventChain
    m_AbstractEventChainEClass->setName("AbstractEventChain");
    m_AbstractEventChainEClass->setAbstract(true);
    m_AbstractEventChainEClass->setInterface(false);
    m_AbstractEventChain__itemType->setEType(m_EventChainItemTypeEEnum);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute
                    > (m_AbstractEventChain__itemType), "itemType", true, false,
            false, "", false, false, true, false, 0, 1, false, false);
    m_AbstractEventChain__itemType->setID(false);
    m_AbstractEventChain__minItemsCompleted->setEType(m_PositiveIntEDataType);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute
                    > (m_AbstractEventChain__minItemsCompleted),
            "minItemsCompleted", true, false, false, "1", false, false, true,
            false, 0, 1, false, false);
    m_AbstractEventChain__minItemsCompleted->setID(false);
    m_AbstractEventChain__stimulus->setEType(m_EventEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_AbstractEventChain__stimulus), "stimulus", true, false,
            false, "", false, false, true, true, 1, 1, false, true);
    m_AbstractEventChain__stimulus->setContainment(false);
    m_AbstractEventChain__stimulus->setResolveProxies(true);
    m_AbstractEventChain__response->setEType(m_EventEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_AbstractEventChain__response), "response", true, false,
            false, "", false, false, true, true, 1, 1, false, true);
    m_AbstractEventChain__response->setContainment(false);
    m_AbstractEventChain__response->setResolveProxies(true);
    m_AbstractEventChain__items->setEType(m_EventChainItemEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_AbstractEventChain__items),
            "items", true, false, false, "", false, false, true, true, 0, -1,
            true, false);
    m_AbstractEventChain__items->setContainment(true);
    m_AbstractEventChain__items->setResolveProxies(false);
    // EventChain
    m_EventChainEClass->setName("EventChain");
    m_EventChainEClass->setAbstract(false);
    m_EventChainEClass->setInterface(false);
    // SubEventChain
    m_SubEventChainEClass->setName("SubEventChain");
    m_SubEventChainEClass->setAbstract(false);
    m_SubEventChainEClass->setInterface(false);
    // EventChainItem
    m_EventChainItemEClass->setName("EventChainItem");
    m_EventChainItemEClass->setAbstract(true);
    m_EventChainItemEClass->setInterface(true);
    {
        ::ecore::EOperation_ptr _op = addEOperation(m_EventChainItemEClass,
                nullptr, "getEventChain", 0, 1, false, true);
        _op->setEType(m_AbstractEventChainEClass);
    }
    // EventChainReference
    m_EventChainReferenceEClass->setName("EventChainReference");
    m_EventChainReferenceEClass->setAbstract(false);
    m_EventChainReferenceEClass->setInterface(false);
    m_EventChainReference__eventChain->setEType(m_EventChainEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_EventChainReference__eventChain), "eventChain", true,
            false, false, "", false, false, true, true, 1, 1, false, true);
    m_EventChainReference__eventChain->setContainment(false);
    m_EventChainReference__eventChain->setResolveProxies(true);
    // EventChainContainer
    m_EventChainContainerEClass->setName("EventChainContainer");
    m_EventChainContainerEClass->setAbstract(false);
    m_EventChainContainerEClass->setInterface(false);
    m_EventChainContainer__eventChain->setEType(m_SubEventChainEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_EventChainContainer__eventChain), "eventChain", true,
            false, false, "", false, false, true, true, 1, 1, false, true);
    m_EventChainContainer__eventChain->setContainment(true);
    m_EventChainContainer__eventChain->setResolveProxies(false);
    // TimingConstraint
    m_TimingConstraintEClass->setName("TimingConstraint");
    m_TimingConstraintEClass->setAbstract(true);
    m_TimingConstraintEClass->setInterface(false);
    // PhysicalSectionConstraint
    m_PhysicalSectionConstraintEClass->setName("PhysicalSectionConstraint");
    m_PhysicalSectionConstraintEClass->setAbstract(false);
    m_PhysicalSectionConstraintEClass->setInterface(false);
    m_PhysicalSectionConstraint__section->setEType(m_SectionEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_PhysicalSectionConstraint__section), "section", true,
            false, false, "", false, false, true, true, 1, 1, false, true);
    m_PhysicalSectionConstraint__section->setContainment(false);
    m_PhysicalSectionConstraint__section->setResolveProxies(true);
    m_PhysicalSectionConstraint__memories->setEType(m_MemoryEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_PhysicalSectionConstraint__memories), "memories", true,
            false, false, "", false, false, true, true, 1, -1, true, true);
    m_PhysicalSectionConstraint__memories->setContainment(false);
    m_PhysicalSectionConstraint__memories->setResolveProxies(true);
    // SynchronizationConstraint
    m_SynchronizationConstraintEClass->setName("SynchronizationConstraint");
    m_SynchronizationConstraintEClass->setAbstract(true);
    m_SynchronizationConstraintEClass->setInterface(false);
    m_SynchronizationConstraint__multipleOccurrencesAllowed->setEType(
            dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEBoolean());
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute
                    > (m_SynchronizationConstraint__multipleOccurrencesAllowed),
            "multipleOccurrencesAllowed", true, false, false, "false", false,
            false, true, false, 0, 1, false, false);
    m_SynchronizationConstraint__multipleOccurrencesAllowed->setID(false);
    m_SynchronizationConstraint__tolerance->setEType(m_TimeEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_SynchronizationConstraint__tolerance), "tolerance",
            true, false, false, "", false, false, true, true, 1, 1, false,
            true);
    m_SynchronizationConstraint__tolerance->setContainment(true);
    m_SynchronizationConstraint__tolerance->setResolveProxies(false);
    // EventSynchronizationConstraint
    m_EventSynchronizationConstraintEClass->setName(
            "EventSynchronizationConstraint");
    m_EventSynchronizationConstraintEClass->setAbstract(false);
    m_EventSynchronizationConstraintEClass->setInterface(false);
    m_EventSynchronizationConstraint__events->setEType(m_EntityEventEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_EventSynchronizationConstraint__events), "events",
            true, false, false, "", false, false, true, true, 1, -1, true,
            true);
    m_EventSynchronizationConstraint__events->setContainment(false);
    m_EventSynchronizationConstraint__events->setResolveProxies(true);
    // EventChainSynchronizationConstraint
    m_EventChainSynchronizationConstraintEClass->setName(
            "EventChainSynchronizationConstraint");
    m_EventChainSynchronizationConstraintEClass->setAbstract(false);
    m_EventChainSynchronizationConstraintEClass->setInterface(false);
    m_EventChainSynchronizationConstraint__type->setEType(
            m_SynchronizationTypeEEnum);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute
                    > (m_EventChainSynchronizationConstraint__type), "type",
            true, false, false, "", false, false, true, false, 0, 1, false,
            false);
    m_EventChainSynchronizationConstraint__type->setID(false);
    m_EventChainSynchronizationConstraint__scope->setEType(m_EventChainEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_EventChainSynchronizationConstraint__scope), "scope",
            true, false, false, "", false, false, true, true, 2, 2, true, true);
    m_EventChainSynchronizationConstraint__scope->setContainment(false);
    m_EventChainSynchronizationConstraint__scope->setResolveProxies(true);
    // DelayConstraint
    m_DelayConstraintEClass->setName("DelayConstraint");
    m_DelayConstraintEClass->setAbstract(false);
    m_DelayConstraintEClass->setInterface(false);
    m_DelayConstraint__mappingType->setEType(m_MappingTypeEEnum);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute
                    > (m_DelayConstraint__mappingType), "mappingType", true,
            false, false, "", false, false, true, false, 0, 1, false, false);
    m_DelayConstraint__mappingType->setID(false);
    m_DelayConstraint__source->setEType(m_EntityEventEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_DelayConstraint__source),
            "source", true, false, false, "", false, false, true, true, 1, 1,
            false, true);
    m_DelayConstraint__source->setContainment(false);
    m_DelayConstraint__source->setResolveProxies(true);
    m_DelayConstraint__target->setEType(m_EntityEventEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_DelayConstraint__target),
            "target", true, false, false, "", false, false, true, true, 1, 1,
            false, true);
    m_DelayConstraint__target->setContainment(false);
    m_DelayConstraint__target->setResolveProxies(true);
    m_DelayConstraint__upper->setEType(m_TimeEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_DelayConstraint__upper),
            "upper", true, false, false, "", false, false, true, true, 0, 1,
            false, false);
    m_DelayConstraint__upper->setContainment(true);
    m_DelayConstraint__upper->setResolveProxies(false);
    m_DelayConstraint__lower->setEType(m_TimeEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_DelayConstraint__lower),
            "lower", true, false, false, "", false, false, true, true, 0, 1,
            false, false);
    m_DelayConstraint__lower->setContainment(true);
    m_DelayConstraint__lower->setResolveProxies(false);
    // EventChainLatencyConstraint
    m_EventChainLatencyConstraintEClass->setName("EventChainLatencyConstraint");
    m_EventChainLatencyConstraintEClass->setAbstract(false);
    m_EventChainLatencyConstraintEClass->setInterface(false);
    m_EventChainLatencyConstraint__type->setEType(m_LatencyTypeEEnum);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute
                    > (m_EventChainLatencyConstraint__type), "type", true,
            false, false, "", false, false, true, false, 0, 1, false, false);
    m_EventChainLatencyConstraint__type->setID(false);
    m_EventChainLatencyConstraint__scope->setEType(m_EventChainEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_EventChainLatencyConstraint__scope), "scope", true,
            false, false, "", false, false, true, true, 1, 1, false, true);
    m_EventChainLatencyConstraint__scope->setContainment(false);
    m_EventChainLatencyConstraint__scope->setResolveProxies(true);
    m_EventChainLatencyConstraint__minimum->setEType(m_TimeEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_EventChainLatencyConstraint__minimum), "minimum", true,
            false, false, "", false, false, true, true, 0, 1, false, false);
    m_EventChainLatencyConstraint__minimum->setContainment(true);
    m_EventChainLatencyConstraint__minimum->setResolveProxies(false);
    m_EventChainLatencyConstraint__maximum->setEType(m_TimeEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_EventChainLatencyConstraint__maximum), "maximum", true,
            false, false, "", false, false, true, true, 0, 1, false, false);
    m_EventChainLatencyConstraint__maximum->setContainment(true);
    m_EventChainLatencyConstraint__maximum->setResolveProxies(false);
    // RepetitionConstraint
    m_RepetitionConstraintEClass->setName("RepetitionConstraint");
    m_RepetitionConstraintEClass->setAbstract(false);
    m_RepetitionConstraintEClass->setInterface(false);
    m_RepetitionConstraint__span->setEType(
            dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEInt());
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute > (m_RepetitionConstraint__span),
            "span", true, false, false, "0", false, false, true, false, 0, 1,
            false, false);
    m_RepetitionConstraint__span->setID(false);
    m_RepetitionConstraint__event->setEType(m_EntityEventEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_RepetitionConstraint__event),
            "event", true, false, false, "", false, false, true, true, 1, 1,
            false, true);
    m_RepetitionConstraint__event->setContainment(false);
    m_RepetitionConstraint__event->setResolveProxies(true);
    m_RepetitionConstraint__lower->setEType(m_TimeEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_RepetitionConstraint__lower),
            "lower", true, false, false, "", false, false, true, true, 0, 1,
            false, false);
    m_RepetitionConstraint__lower->setContainment(true);
    m_RepetitionConstraint__lower->setResolveProxies(false);
    m_RepetitionConstraint__upper->setEType(m_TimeEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_RepetitionConstraint__upper),
            "upper", true, false, false, "", false, false, true, true, 0, 1,
            false, false);
    m_RepetitionConstraint__upper->setContainment(true);
    m_RepetitionConstraint__upper->setResolveProxies(false);
    m_RepetitionConstraint__jitter->setEType(m_TimeEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_RepetitionConstraint__jitter), "jitter", true, false,
            false, "", false, false, true, true, 0, 1, false, false);
    m_RepetitionConstraint__jitter->setContainment(true);
    m_RepetitionConstraint__jitter->setResolveProxies(false);
    m_RepetitionConstraint__period->setEType(m_TimeEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_RepetitionConstraint__period), "period", true, false,
            false, "", false, false, true, true, 0, 1, false, false);
    m_RepetitionConstraint__period->setContainment(true);
    m_RepetitionConstraint__period->setResolveProxies(false);
    // DataAgeConstraint
    m_DataAgeConstraintEClass->setName("DataAgeConstraint");
    m_DataAgeConstraintEClass->setAbstract(false);
    m_DataAgeConstraintEClass->setInterface(false);
    m_DataAgeConstraint__runnable->setEType(m_RunnableEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_DataAgeConstraint__runnable),
            "runnable", true, false, false, "", false, false, true, true, 1, 1,
            false, true);
    m_DataAgeConstraint__runnable->setContainment(false);
    m_DataAgeConstraint__runnable->setResolveProxies(true);
    m_DataAgeConstraint__label->setEType(m_LabelEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_DataAgeConstraint__label),
            "label", true, false, false, "", false, false, true, true, 1, 1,
            false, true);
    m_DataAgeConstraint__label->setContainment(false);
    m_DataAgeConstraint__label->setResolveProxies(true);
    m_DataAgeConstraint__dataAge->setEType(m_DataAgeEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_DataAgeConstraint__dataAge),
            "dataAge", true, false, false, "", false, false, true, true, 1, 1,
            false, true);
    m_DataAgeConstraint__dataAge->setContainment(true);
    m_DataAgeConstraint__dataAge->setResolveProxies(false);
    // DataAge
    m_DataAgeEClass->setName("DataAge");
    m_DataAgeEClass->setAbstract(true);
    m_DataAgeEClass->setInterface(false);
    // DataAgeCycle
    m_DataAgeCycleEClass->setName("DataAgeCycle");
    m_DataAgeCycleEClass->setAbstract(false);
    m_DataAgeCycleEClass->setInterface(false);
    m_DataAgeCycle__minimumCycle->setEType(
            dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEInt());
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute > (m_DataAgeCycle__minimumCycle),
            "minimumCycle", true, false, false, "0", false, false, true, false,
            0, 1, false, false);
    m_DataAgeCycle__minimumCycle->setID(false);
    m_DataAgeCycle__maximumCycle->setEType(
            dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEInt());
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute > (m_DataAgeCycle__maximumCycle),
            "maximumCycle", true, false, false, "0", false, false, true, false,
            0, 1, false, false);
    m_DataAgeCycle__maximumCycle->setID(false);
    // DataAgeTime
    m_DataAgeTimeEClass->setName("DataAgeTime");
    m_DataAgeTimeEClass->setAbstract(false);
    m_DataAgeTimeEClass->setInterface(false);
    m_DataAgeTime__minimumTime->setEType(m_TimeEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_DataAgeTime__minimumTime),
            "minimumTime", true, false, false, "", false, false, true, true, 0,
            1, false, false);
    m_DataAgeTime__minimumTime->setContainment(true);
    m_DataAgeTime__minimumTime->setResolveProxies(false);
    m_DataAgeTime__maximumTime->setEType(m_TimeEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_DataAgeTime__maximumTime),
            "maximumTime", true, false, false, "", false, false, true, true, 0,
            1, false, false);
    m_DataAgeTime__maximumTime->setContainment(true);
    m_DataAgeTime__maximumTime->setResolveProxies(false);
    // Requirement
    m_RequirementEClass->setName("Requirement");
    m_RequirementEClass->setAbstract(true);
    m_RequirementEClass->setInterface(false);
    m_Requirement__severity->setEType(m_SeverityEEnum);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute > (m_Requirement__severity),
            "severity", true, false, false, "", false, false, true, false, 0, 1,
            false, false);
    m_Requirement__severity->setID(false);
    m_Requirement__limit->setEType(m_RequirementLimitEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_Requirement__limit), "limit",
            true, false, false, "", false, false, true, true, 1, 1, false,
            true);
    m_Requirement__limit->setContainment(true);
    m_Requirement__limit->setResolveProxies(false);
    // ProcessRequirement
    m_ProcessRequirementEClass->setName("ProcessRequirement");
    m_ProcessRequirementEClass->setAbstract(false);
    m_ProcessRequirementEClass->setInterface(false);
    m_ProcessRequirement__process->setEType(m_AbstractProcessEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_ProcessRequirement__process),
            "process", true, false, false, "", false, false, true, true, 1, 1,
            false, true);
    m_ProcessRequirement__process->setContainment(false);
    m_ProcessRequirement__process->setResolveProxies(true);
    // RunnableRequirement
    m_RunnableRequirementEClass->setName("RunnableRequirement");
    m_RunnableRequirementEClass->setAbstract(false);
    m_RunnableRequirementEClass->setInterface(false);
    m_RunnableRequirement__runnable->setEType(m_RunnableEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_RunnableRequirement__runnable), "runnable", true,
            false, false, "", false, false, true, true, 1, 1, false, true);
    m_RunnableRequirement__runnable->setContainment(false);
    m_RunnableRequirement__runnable->setResolveProxies(true);
    // ArchitectureRequirement
    m_ArchitectureRequirementEClass->setName("ArchitectureRequirement");
    m_ArchitectureRequirementEClass->setAbstract(false);
    m_ArchitectureRequirementEClass->setInterface(false);
    m_ArchitectureRequirement__component->setEType(m_ComponentEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_ArchitectureRequirement__component), "component", true,
            false, false, "", false, false, true, true, 1, 1, false, true);
    m_ArchitectureRequirement__component->setContainment(false);
    m_ArchitectureRequirement__component->setResolveProxies(true);
    // ProcessChainRequirement
    m_ProcessChainRequirementEClass->setName("ProcessChainRequirement");
    m_ProcessChainRequirementEClass->setAbstract(false);
    m_ProcessChainRequirementEClass->setInterface(false);
    m_ProcessChainRequirement__processChain->setEType(m_ProcessChainEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_ProcessChainRequirement__processChain), "processChain",
            true, false, false, "", false, false, true, true, 1, 1, false,
            true);
    m_ProcessChainRequirement__processChain->setContainment(false);
    m_ProcessChainRequirement__processChain->setResolveProxies(true);
    // RequirementLimit
    m_RequirementLimitEClass->setName("RequirementLimit");
    m_RequirementLimitEClass->setAbstract(true);
    m_RequirementLimitEClass->setInterface(false);
    m_RequirementLimit__limitType->setEType(m_LimitTypeEEnum);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute > (m_RequirementLimit__limitType),
            "limitType", true, false, false, "", false, false, true, false, 0,
            1, false, false);
    m_RequirementLimit__limitType->setID(false);
    // CPUPercentageRequirementLimit
    m_CPUPercentageRequirementLimitEClass->setName(
            "CPUPercentageRequirementLimit");
    m_CPUPercentageRequirementLimitEClass->setAbstract(false);
    m_CPUPercentageRequirementLimitEClass->setInterface(false);
    m_CPUPercentageRequirementLimit__metric->setEType(
            m_CPUPercentageMetricEEnum);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute
                    > (m_CPUPercentageRequirementLimit__metric), "metric", true,
            false, false, "", false, false, true, false, 0, 1, false, false);
    m_CPUPercentageRequirementLimit__metric->setID(false);
    m_CPUPercentageRequirementLimit__limitValue->setEType(
            dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEDouble());
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute
                    > (m_CPUPercentageRequirementLimit__limitValue),
            "limitValue", true, false, false, "0.0", false, false, true, false,
            0, 1, false, false);
    m_CPUPercentageRequirementLimit__limitValue->setID(false);
    m_CPUPercentageRequirementLimit__hardwareContext->setEType(
            m_ProcessingUnitEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_CPUPercentageRequirementLimit__hardwareContext),
            "hardwareContext", true, false, false, "", false, false, true, true,
            0, 1, false, false);
    m_CPUPercentageRequirementLimit__hardwareContext->setContainment(false);
    m_CPUPercentageRequirementLimit__hardwareContext->setResolveProxies(true);
    // FrequencyRequirementLimit
    m_FrequencyRequirementLimitEClass->setName("FrequencyRequirementLimit");
    m_FrequencyRequirementLimitEClass->setAbstract(false);
    m_FrequencyRequirementLimitEClass->setInterface(false);
    m_FrequencyRequirementLimit__metric->setEType(m_FrequencyMetricEEnum);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute
                    > (m_FrequencyRequirementLimit__metric), "metric", true,
            false, false, "", false, false, true, false, 0, 1, false, false);
    m_FrequencyRequirementLimit__metric->setID(false);
    m_FrequencyRequirementLimit__limitValue->setEType(m_FrequencyEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_FrequencyRequirementLimit__limitValue), "limitValue",
            true, false, false, "", false, false, true, true, 1, 1, false,
            true);
    m_FrequencyRequirementLimit__limitValue->setContainment(true);
    m_FrequencyRequirementLimit__limitValue->setResolveProxies(false);
    // PercentageRequirementLimit
    m_PercentageRequirementLimitEClass->setName("PercentageRequirementLimit");
    m_PercentageRequirementLimitEClass->setAbstract(false);
    m_PercentageRequirementLimitEClass->setInterface(false);
    m_PercentageRequirementLimit__metric->setEType(m_PercentageMetricEEnum);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute
                    > (m_PercentageRequirementLimit__metric), "metric", true,
            false, false, "", false, false, true, false, 0, 1, false, false);
    m_PercentageRequirementLimit__metric->setID(false);
    m_PercentageRequirementLimit__limitValue->setEType(
            dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEDouble());
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute
                    > (m_PercentageRequirementLimit__limitValue), "limitValue",
            true, false, false, "0.0", false, false, true, false, 0, 1, false,
            false);
    m_PercentageRequirementLimit__limitValue->setID(false);
    // CountRequirementLimit
    m_CountRequirementLimitEClass->setName("CountRequirementLimit");
    m_CountRequirementLimitEClass->setAbstract(false);
    m_CountRequirementLimitEClass->setInterface(false);
    m_CountRequirementLimit__metric->setEType(m_CountMetricEEnum);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute
                    > (m_CountRequirementLimit__metric), "metric", true, false,
            false, "", false, false, true, false, 0, 1, false, false);
    m_CountRequirementLimit__metric->setID(false);
    m_CountRequirementLimit__limitValue->setEType(
            dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEInt());
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute
                    > (m_CountRequirementLimit__limitValue), "limitValue", true,
            false, false, "0", false, false, true, false, 0, 1, false, false);
    m_CountRequirementLimit__limitValue->setID(false);
    // TimeRequirementLimit
    m_TimeRequirementLimitEClass->setName("TimeRequirementLimit");
    m_TimeRequirementLimitEClass->setAbstract(false);
    m_TimeRequirementLimitEClass->setInterface(false);
    m_TimeRequirementLimit__metric->setEType(m_TimeMetricEEnum);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute
                    > (m_TimeRequirementLimit__metric), "metric", true, false,
            false, "", false, false, true, false, 0, 1, false, false);
    m_TimeRequirementLimit__metric->setID(false);
    m_TimeRequirementLimit__limitValue->setEType(m_TimeEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_TimeRequirementLimit__limitValue), "limitValue", true,
            false, false, "", false, false, true, true, 1, 1, false, true);
    m_TimeRequirementLimit__limitValue->setContainment(true);
    m_TimeRequirementLimit__limitValue->setResolveProxies(false);
    // DataCoherencyGroup
    m_DataCoherencyGroupEClass->setName("DataCoherencyGroup");
    m_DataCoherencyGroupEClass->setAbstract(false);
    m_DataCoherencyGroupEClass->setInterface(false);
    m_DataCoherencyGroup__direction->setEType(m_CoherencyDirectionEEnum);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute
                    > (m_DataCoherencyGroup__direction), "direction", true,
            false, false, "", false, false, true, false, 0, 1, false, false);
    m_DataCoherencyGroup__direction->setID(false);
    m_DataCoherencyGroup__labels->setEType(m_LabelEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_DataCoherencyGroup__labels),
            "labels", true, false, false, "", false, false, true, true, 1, -1,
            true, true);
    m_DataCoherencyGroup__labels->setContainment(false);
    m_DataCoherencyGroup__labels->setResolveProxies(true);
    m_DataCoherencyGroup__scope->setEType(m_DataGroupScopeEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_DataCoherencyGroup__scope),
            "scope", true, false, false, "", false, false, true, true, 0, 1,
            false, false);
    m_DataCoherencyGroup__scope->setContainment(true);
    m_DataCoherencyGroup__scope->setResolveProxies(false);
    // DataStabilityGroup
    m_DataStabilityGroupEClass->setName("DataStabilityGroup");
    m_DataStabilityGroupEClass->setAbstract(false);
    m_DataStabilityGroupEClass->setInterface(false);
    m_DataStabilityGroup__labels->setEType(m_LabelEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_DataStabilityGroup__labels),
            "labels", true, false, false, "", false, false, true, true, 1, -1,
            true, true);
    m_DataStabilityGroup__labels->setContainment(false);
    m_DataStabilityGroup__labels->setResolveProxies(true);
    m_DataStabilityGroup__scope->setEType(m_DataGroupScopeEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_DataStabilityGroup__scope),
            "scope", true, false, false, "", false, false, true, true, 0, 1,
            false, false);
    m_DataStabilityGroup__scope->setContainment(true);
    m_DataStabilityGroup__scope->setResolveProxies(false);
    // DataGroupScope
    m_DataGroupScopeEClass->setName("DataGroupScope");
    m_DataGroupScopeEClass->setAbstract(true);
    m_DataGroupScopeEClass->setInterface(false);
    // ProcessScope
    m_ProcessScopeEClass->setName("ProcessScope");
    m_ProcessScopeEClass->setAbstract(false);
    m_ProcessScopeEClass->setInterface(false);
    m_ProcessScope__process->setEType(m_AbstractProcessEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_ProcessScope__process),
            "process", true, false, false, "", false, false, true, true, 0, 1,
            false, false);
    m_ProcessScope__process->setContainment(false);
    m_ProcessScope__process->setResolveProxies(true);
    // RunnableScope
    m_RunnableScopeEClass->setName("RunnableScope");
    m_RunnableScopeEClass->setAbstract(false);
    m_RunnableScopeEClass->setInterface(false);
    m_RunnableScope__runnable->setEType(m_RunnableEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_RunnableScope__runnable),
            "runnable", true, false, false, "", false, false, true, true, 0, 1,
            false, false);
    m_RunnableScope__runnable->setContainment(false);
    m_RunnableScope__runnable->setResolveProxies(true);
    // ComponentScope
    m_ComponentScopeEClass->setName("ComponentScope");
    m_ComponentScopeEClass->setAbstract(false);
    m_ComponentScopeEClass->setInterface(false);
    m_ComponentScope__component->setEType(m_ComponentEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_ComponentScope__component),
            "component", true, false, false, "", false, false, true, true, 0, 1,
            false, false);
    m_ComponentScope__component->setContainment(false);
    m_ComponentScope__component->setResolveProxies(true);
    // EventModel
    m_EventModelEClass->setName("EventModel");
    m_EventModelEClass->setAbstract(false);
    m_EventModelEClass->setInterface(false);
    m_EventModel__events->setEType(m_EventEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_EventModel__events),
            "events", true, false, false, "", false, false, true, true, 0, -1,
            true, false);
    m_EventModel__events->setContainment(true);
    m_EventModel__events->setResolveProxies(false);
    // Event
    m_EventEClass->setName("Event");
    m_EventEClass->setAbstract(true);
    m_EventEClass->setInterface(false);
    // EventSet
    m_EventSetEClass->setName("EventSet");
    m_EventSetEClass->setAbstract(false);
    m_EventSetEClass->setInterface(false);
    m_EventSet__events->setEType(m_EntityEventEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_EventSet__events), "events",
            true, false, false, "", false, false, true, true, 1, -1, true,
            true);
    m_EventSet__events->setContainment(false);
    m_EventSet__events->setResolveProxies(true);
    // EntityEvent
    m_EntityEventEClass->setName("EntityEvent");
    m_EntityEventEClass->setAbstract(true);
    m_EntityEventEClass->setInterface(false);
    // TriggerEvent
    m_TriggerEventEClass->setName("TriggerEvent");
    m_TriggerEventEClass->setAbstract(true);
    m_TriggerEventEClass->setInterface(false);
    // CustomEvent
    m_CustomEventEClass->setName("CustomEvent");
    m_CustomEventEClass->setAbstract(false);
    m_CustomEventEClass->setInterface(false);
    m_CustomEvent__eventType->setEType(
            dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEString());
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute > (m_CustomEvent__eventType),
            "eventType", true, false, false, "", false, false, true, false, 0,
            1, false, false);
    m_CustomEvent__eventType->setID(false);
    m_CustomEvent__explicitTriggers->setEType(m_CustomEventTriggerEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_CustomEvent__explicitTriggers), "explicitTriggers",
            false, true, true, "", false, true, true, true, 0, -1, true, false);
    m_CustomEvent__explicitTriggers->setContainment(false);
    m_CustomEvent__explicitTriggers->setResolveProxies(true);
    // StimulusEvent
    m_StimulusEventEClass->setName("StimulusEvent");
    m_StimulusEventEClass->setAbstract(false);
    m_StimulusEventEClass->setInterface(false);
    m_StimulusEvent__entity->setEType(m_StimulusEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_StimulusEvent__entity),
            "entity", true, false, false, "", false, false, true, true, 0, 1,
            false, false);
    m_StimulusEvent__entity->setContainment(false);
    m_StimulusEvent__entity->setResolveProxies(true);
    // ProcessEvent
    m_ProcessEventEClass->setName("ProcessEvent");
    m_ProcessEventEClass->setAbstract(false);
    m_ProcessEventEClass->setInterface(false);
    m_ProcessEvent__eventType->setEType(m_ProcessEventTypeEEnum);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute > (m_ProcessEvent__eventType),
            "eventType", true, false, false, "", false, false, true, false, 0,
            1, false, false);
    m_ProcessEvent__eventType->setID(false);
    m_ProcessEvent__entity->setEType(m_ProcessEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_ProcessEvent__entity),
            "entity", true, false, false, "", false, false, true, true, 0, 1,
            false, false);
    m_ProcessEvent__entity->setContainment(false);
    m_ProcessEvent__entity->setResolveProxies(true);
    m_ProcessEvent__processingUnit->setEType(m_ProcessingUnitEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_ProcessEvent__processingUnit), "processingUnit", true,
            false, false, "", false, false, true, true, 0, 1, false, false);
    m_ProcessEvent__processingUnit->setContainment(false);
    m_ProcessEvent__processingUnit->setResolveProxies(true);
    // ProcessChainEvent
    m_ProcessChainEventEClass->setName("ProcessChainEvent");
    m_ProcessChainEventEClass->setAbstract(false);
    m_ProcessChainEventEClass->setInterface(false);
    m_ProcessChainEvent__eventType->setEType(m_ProcessEventTypeEEnum);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute
                    > (m_ProcessChainEvent__eventType), "eventType", true,
            false, false, "", false, false, true, false, 0, 1, false, false);
    m_ProcessChainEvent__eventType->setID(false);
    m_ProcessChainEvent__entity->setEType(m_ProcessChainEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_ProcessChainEvent__entity),
            "entity", true, false, false, "", false, false, true, true, 0, 1,
            false, false);
    m_ProcessChainEvent__entity->setContainment(false);
    m_ProcessChainEvent__entity->setResolveProxies(true);
    m_ProcessChainEvent__processingUnit->setEType(m_ProcessingUnitEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_ProcessChainEvent__processingUnit), "processingUnit",
            true, false, false, "", false, false, true, true, 0, 1, false,
            false);
    m_ProcessChainEvent__processingUnit->setContainment(false);
    m_ProcessChainEvent__processingUnit->setResolveProxies(true);
    // RunnableEvent
    m_RunnableEventEClass->setName("RunnableEvent");
    m_RunnableEventEClass->setAbstract(false);
    m_RunnableEventEClass->setInterface(false);
    m_RunnableEvent__eventType->setEType(m_RunnableEventTypeEEnum);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute > (m_RunnableEvent__eventType),
            "eventType", true, false, false, "", false, false, true, false, 0,
            1, false, false);
    m_RunnableEvent__eventType->setID(false);
    m_RunnableEvent__entity->setEType(m_RunnableEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_RunnableEvent__entity),
            "entity", true, false, false, "", false, false, true, true, 0, 1,
            false, false);
    m_RunnableEvent__entity->setContainment(false);
    m_RunnableEvent__entity->setResolveProxies(true);
    m_RunnableEvent__process->setEType(m_ProcessEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_RunnableEvent__process),
            "process", true, false, false, "", false, false, true, true, 0, 1,
            false, false);
    m_RunnableEvent__process->setContainment(false);
    m_RunnableEvent__process->setResolveProxies(true);
    m_RunnableEvent__processingUnit->setEType(m_ProcessingUnitEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_RunnableEvent__processingUnit), "processingUnit", true,
            false, false, "", false, false, true, true, 0, 1, false, false);
    m_RunnableEvent__processingUnit->setContainment(false);
    m_RunnableEvent__processingUnit->setResolveProxies(true);
    // LabelEvent
    m_LabelEventEClass->setName("LabelEvent");
    m_LabelEventEClass->setAbstract(false);
    m_LabelEventEClass->setInterface(false);
    m_LabelEvent__eventType->setEType(m_LabelEventTypeEEnum);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute > (m_LabelEvent__eventType),
            "eventType", true, false, false, "", false, false, true, false, 0,
            1, false, false);
    m_LabelEvent__eventType->setID(false);
    m_LabelEvent__entity->setEType(m_LabelEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_LabelEvent__entity),
            "entity", true, false, false, "", false, false, true, true, 0, 1,
            false, false);
    m_LabelEvent__entity->setContainment(false);
    m_LabelEvent__entity->setResolveProxies(true);
    m_LabelEvent__runnable->setEType(m_RunnableEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_LabelEvent__runnable),
            "runnable", true, false, false, "", false, false, true, true, 0, 1,
            false, false);
    m_LabelEvent__runnable->setContainment(false);
    m_LabelEvent__runnable->setResolveProxies(true);
    m_LabelEvent__process->setEType(m_ProcessEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_LabelEvent__process),
            "process", true, false, false, "", false, false, true, true, 0, 1,
            false, false);
    m_LabelEvent__process->setContainment(false);
    m_LabelEvent__process->setResolveProxies(true);
    // ChannelEvent
    m_ChannelEventEClass->setName("ChannelEvent");
    m_ChannelEventEClass->setAbstract(false);
    m_ChannelEventEClass->setInterface(false);
    m_ChannelEvent__eventType->setEType(m_ChannelEventTypeEEnum);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute > (m_ChannelEvent__eventType),
            "eventType", true, false, false, "", false, false, true, false, 0,
            1, false, false);
    m_ChannelEvent__eventType->setID(false);
    m_ChannelEvent__entity->setEType(m_ChannelEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_ChannelEvent__entity),
            "entity", true, false, false, "", false, false, true, true, 0, 1,
            false, false);
    m_ChannelEvent__entity->setContainment(false);
    m_ChannelEvent__entity->setResolveProxies(true);
    m_ChannelEvent__runnable->setEType(m_RunnableEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_ChannelEvent__runnable),
            "runnable", true, false, false, "", false, false, true, true, 0, 1,
            false, false);
    m_ChannelEvent__runnable->setContainment(false);
    m_ChannelEvent__runnable->setResolveProxies(true);
    m_ChannelEvent__process->setEType(m_ProcessEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_ChannelEvent__process),
            "process", true, false, false, "", false, false, true, true, 0, 1,
            false, false);
    m_ChannelEvent__process->setContainment(false);
    m_ChannelEvent__process->setResolveProxies(true);
    // SemaphoreEvent
    m_SemaphoreEventEClass->setName("SemaphoreEvent");
    m_SemaphoreEventEClass->setAbstract(false);
    m_SemaphoreEventEClass->setInterface(false);
    m_SemaphoreEvent__eventType->setEType(m_SemaphoreEventTypeEEnum);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute > (m_SemaphoreEvent__eventType),
            "eventType", true, false, false, "", false, false, true, false, 0,
            1, false, false);
    m_SemaphoreEvent__eventType->setID(false);
    m_SemaphoreEvent__entity->setEType(m_SemaphoreEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_SemaphoreEvent__entity),
            "entity", true, false, false, "", false, false, true, true, 0, 1,
            false, false);
    m_SemaphoreEvent__entity->setContainment(false);
    m_SemaphoreEvent__entity->setResolveProxies(true);
    m_SemaphoreEvent__runnable->setEType(m_RunnableEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_SemaphoreEvent__runnable),
            "runnable", true, false, false, "", false, false, true, true, 0, 1,
            false, false);
    m_SemaphoreEvent__runnable->setContainment(false);
    m_SemaphoreEvent__runnable->setResolveProxies(true);
    m_SemaphoreEvent__process->setEType(m_ProcessEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_SemaphoreEvent__process),
            "process", true, false, false, "", false, false, true, true, 0, 1,
            false, false);
    m_SemaphoreEvent__process->setContainment(false);
    m_SemaphoreEvent__process->setResolveProxies(true);
    m_SemaphoreEvent__processingUnit->setEType(m_ProcessingUnitEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_SemaphoreEvent__processingUnit), "processingUnit",
            true, false, false, "", false, false, true, true, 0, 1, false,
            false);
    m_SemaphoreEvent__processingUnit->setContainment(false);
    m_SemaphoreEvent__processingUnit->setResolveProxies(true);
    // ComponentEvent
    m_ComponentEventEClass->setName("ComponentEvent");
    m_ComponentEventEClass->setAbstract(false);
    m_ComponentEventEClass->setInterface(false);
    m_ComponentEvent__eventType->setEType(m_ComponentEventTypeEEnum);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute > (m_ComponentEvent__eventType),
            "eventType", true, false, false, "", false, false, true, false, 0,
            1, false, false);
    m_ComponentEvent__eventType->setID(false);
    m_ComponentEvent__entity->setEType(m_ComponentEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_ComponentEvent__entity),
            "entity", true, false, false, "", false, false, true, true, 0, 1,
            false, false);
    m_ComponentEvent__entity->setContainment(false);
    m_ComponentEvent__entity->setResolveProxies(true);
    // HWModel
    m_HWModelEClass->setName("HWModel");
    m_HWModelEClass->setAbstract(false);
    m_HWModelEClass->setInterface(false);
    m_HWModel__definitions->setEType(m_HwDefinitionEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_HWModel__definitions),
            "definitions", true, false, false, "", false, false, true, true, 0,
            -1, true, false);
    m_HWModel__definitions->setContainment(true);
    m_HWModel__definitions->setResolveProxies(false);
    m_HWModel__featureCategories->setEType(m_HwFeatureCategoryEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_HWModel__featureCategories),
            "featureCategories", true, false, false, "", false, false, true,
            true, 0, -1, true, false);
    m_HWModel__featureCategories->setContainment(true);
    m_HWModel__featureCategories->setResolveProxies(false);
    m_HWModel__structures->setEType(m_HwStructureEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_HWModel__structures),
            "structures", true, false, false, "", false, false, true, true, 0,
            -1, true, false);
    m_HWModel__structures->setContainment(true);
    m_HWModel__structures->setResolveProxies(false);
    m_HWModel__domains->setEType(m_HwDomainEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_HWModel__domains), "domains",
            true, false, false, "", false, false, true, true, 0, -1, true,
            false);
    m_HWModel__domains->setContainment(true);
    m_HWModel__domains->setResolveProxies(false);
    // HwStructure
    m_HwStructureEClass->setName("HwStructure");
    m_HwStructureEClass->setAbstract(false);
    m_HwStructureEClass->setInterface(false);
    m_HwStructure__structureType->setEType(m_StructureTypeEEnum);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute > (m_HwStructure__structureType),
            "structureType", true, false, false, "", false, false, true, false,
            0, 1, false, false);
    m_HwStructure__structureType->setID(false);
    m_HwStructure__ports->setEType(m_HwPortEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_HwStructure__ports), "ports",
            true, false, false, "", false, false, true, true, 0, -1, true,
            false);
    m_HwStructure__ports->setContainment(true);
    m_HwStructure__ports->setResolveProxies(false);
    m_HwStructure__structures->setEType(m_HwStructureEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_HwStructure__structures),
            "structures", true, false, false, "", false, false, true, true, 0,
            -1, true, false);
    m_HwStructure__structures->setContainment(true);
    m_HwStructure__structures->setResolveProxies(false);
    m_HwStructure__modules->setEType(m_HwModuleEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_HwStructure__modules),
            "modules", true, false, false, "", false, false, true, true, 0, -1,
            true, false);
    m_HwStructure__modules->setContainment(true);
    m_HwStructure__modules->setResolveProxies(false);
    m_HwStructure__connections->setEType(m_HwConnectionEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_HwStructure__connections),
            "connections", true, false, false, "", false, false, true, true, 0,
            -1, true, false);
    m_HwStructure__connections->setContainment(true);
    m_HwStructure__connections->setResolveProxies(false);
    m_HwStructure__innerPorts->setEType(m_HwPortEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_HwStructure__innerPorts),
            "innerPorts", false, true, true, "", false, true, true, true, 0, -1,
            true, false);
    m_HwStructure__innerPorts->setContainment(false);
    m_HwStructure__innerPorts->setResolveProxies(true);
    // HwModule
    m_HwModuleEClass->setName("HwModule");
    m_HwModuleEClass->setAbstract(true);
    m_HwModuleEClass->setInterface(false);
    m_HwModule__ports->setEType(m_HwPortEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_HwModule__ports), "ports",
            true, false, false, "", false, false, true, true, 0, -1, true,
            false);
    m_HwModule__ports->setContainment(true);
    m_HwModule__ports->setResolveProxies(false);
    m_HwModule__powerDomain->setEType(m_PowerDomainEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_HwModule__powerDomain),
            "powerDomain", true, false, false, "", false, false, true, true, 0,
            1, false, false);
    m_HwModule__powerDomain->setContainment(false);
    m_HwModule__powerDomain->setResolveProxies(true);
    m_HwModule__frequencyDomain->setEType(m_FrequencyDomainEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_HwModule__frequencyDomain),
            "frequencyDomain", true, false, false, "", false, false, true, true,
            0, 1, false, false);
    m_HwModule__frequencyDomain->setContainment(false);
    m_HwModule__frequencyDomain->setResolveProxies(true);
    // HwDomain
    m_HwDomainEClass->setName("HwDomain");
    m_HwDomainEClass->setAbstract(true);
    m_HwDomainEClass->setInterface(false);
    // FrequencyDomain
    m_FrequencyDomainEClass->setName("FrequencyDomain");
    m_FrequencyDomainEClass->setAbstract(false);
    m_FrequencyDomainEClass->setInterface(false);
    m_FrequencyDomain__clockGating->setEType(
            dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEBoolean());
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute
                    > (m_FrequencyDomain__clockGating), "clockGating", true,
            false, false, "false", false, false, true, false, 0, 1, false,
            false);
    m_FrequencyDomain__clockGating->setID(false);
    m_FrequencyDomain__defaultValue->setEType(m_FrequencyEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_FrequencyDomain__defaultValue), "defaultValue", true,
            false, false, "", false, false, true, true, 0, 1, false, false);
    m_FrequencyDomain__defaultValue->setContainment(true);
    m_FrequencyDomain__defaultValue->setResolveProxies(false);
    // PowerDomain
    m_PowerDomainEClass->setName("PowerDomain");
    m_PowerDomainEClass->setAbstract(false);
    m_PowerDomainEClass->setInterface(false);
    m_PowerDomain__powerGating->setEType(
            dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEBoolean());
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute > (m_PowerDomain__powerGating),
            "powerGating", true, false, false, "false", false, false, true,
            false, 0, 1, false, false);
    m_PowerDomain__powerGating->setID(false);
    m_PowerDomain__defaultValue->setEType(m_VoltageEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_PowerDomain__defaultValue),
            "defaultValue", true, false, false, "", false, false, true, true, 0,
            1, false, false);
    m_PowerDomain__defaultValue->setContainment(true);
    m_PowerDomain__defaultValue->setResolveProxies(false);
    // ProcessingUnit
    m_ProcessingUnitEClass->setName("ProcessingUnit");
    m_ProcessingUnitEClass->setAbstract(false);
    m_ProcessingUnitEClass->setInterface(false);
    m_ProcessingUnit__definition->setEType(m_ProcessingUnitDefinitionEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_ProcessingUnit__definition),
            "definition", true, false, false, "", false, false, true, true, 0,
            1, false, false);
    m_ProcessingUnit__definition->setContainment(false);
    m_ProcessingUnit__definition->setResolveProxies(true);
    m_ProcessingUnit__accessElements->setEType(m_HwAccessElementEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_ProcessingUnit__accessElements), "accessElements",
            true, false, false, "", false, false, true, true, 0, -1, true,
            false);
    m_ProcessingUnit__accessElements->setContainment(true);
    m_ProcessingUnit__accessElements->setResolveProxies(false);
    m_ProcessingUnit__accessElements->setEOpposite(
            ::ecore::as < ::ecore::EReference
                    > (m_HwAccessElementEClass->getEStructuralFeatures()[0]));
    m_ProcessingUnit__caches->setEType(m_CacheEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_ProcessingUnit__caches),
            "caches", true, false, false, "", false, false, true, true, 0, -1,
            true, false);
    m_ProcessingUnit__caches->setContainment(true);
    m_ProcessingUnit__caches->setResolveProxies(false);
    // Memory
    m_MemoryEClass->setName("Memory");
    m_MemoryEClass->setAbstract(false);
    m_MemoryEClass->setInterface(false);
    m_Memory__definition->setEType(m_MemoryDefinitionEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_Memory__definition),
            "definition", true, false, false, "", false, false, true, true, 0,
            1, false, false);
    m_Memory__definition->setContainment(false);
    m_Memory__definition->setResolveProxies(true);
    m_Memory__mappings->setEType(m_MemoryMappingEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_Memory__mappings),
            "mappings", false, true, true, "", false, true, true, true, 0, -1,
            true, false);
    m_Memory__mappings->setContainment(false);
    m_Memory__mappings->setResolveProxies(true);
    // Cache
    m_CacheEClass->setName("Cache");
    m_CacheEClass->setAbstract(false);
    m_CacheEClass->setInterface(false);
    m_Cache__definition->setEType(m_CacheDefinitionEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_Cache__definition),
            "definition", true, false, false, "", false, false, true, true, 0,
            1, false, false);
    m_Cache__definition->setContainment(false);
    m_Cache__definition->setResolveProxies(true);
    // HwFeatureCategory
    m_HwFeatureCategoryEClass->setName("HwFeatureCategory");
    m_HwFeatureCategoryEClass->setAbstract(false);
    m_HwFeatureCategoryEClass->setInterface(false);
    m_HwFeatureCategory__featureType->setEType(m_HwFeatureTypeEEnum);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute
                    > (m_HwFeatureCategory__featureType), "featureType", true,
            false, false, "", false, false, true, false, 0, 1, false, false);
    m_HwFeatureCategory__featureType->setID(false);
    m_HwFeatureCategory__features->setEType(m_HwFeatureEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_HwFeatureCategory__features),
            "features", true, false, false, "", false, false, true, true, 0, -1,
            true, false);
    m_HwFeatureCategory__features->setContainment(true);
    m_HwFeatureCategory__features->setResolveProxies(false);
    m_HwFeatureCategory__features->setEOpposite(
            ::ecore::as < ::ecore::EReference
                    > (m_HwFeatureEClass->getEStructuralFeatures()[1]));
    // HwFeature
    m_HwFeatureEClass->setName("HwFeature");
    m_HwFeatureEClass->setAbstract(false);
    m_HwFeatureEClass->setInterface(false);
    m_HwFeature__value->setEType(
            dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEDouble());
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute > (m_HwFeature__value), "value",
            true, false, false, "0.0", false, false, true, false, 0, 1, false,
            false);
    m_HwFeature__value->setID(false);
    m_HwFeature__containingCategory->setEType(m_HwFeatureCategoryEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_HwFeature__containingCategory), "containingCategory",
            false, false, false, "", false, false, true, true, 0, 1, false,
            false);
    m_HwFeature__containingCategory->setContainment(false);
    m_HwFeature__containingCategory->setResolveProxies(true);
    m_HwFeature__containingCategory->setEOpposite(
            ::ecore::as < ::ecore::EReference
                    > (m_HwFeatureCategoryEClass->getEStructuralFeatures()[1]));
    {
        ::ecore::EOperation_ptr _op = addEOperation(m_HwFeatureEClass, nullptr,
                "getNamePrefixSegments", 0, -1, false, true);
        _op->setEType(
                dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEString());
    }
    {
        ::ecore::EOperation_ptr _op = addEOperation(m_HwFeatureEClass, nullptr,
                "toString", 0, 1, false, true);
        _op->setEType(
                dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEString());
    }
    // HwPort
    m_HwPortEClass->setName("HwPort");
    m_HwPortEClass->setAbstract(false);
    m_HwPortEClass->setInterface(false);
    m_HwPort__bitWidth->setEType(
            dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEInt());
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute > (m_HwPort__bitWidth),
            "bitWidth", true, false, false, "0", false, false, true, false, 0,
            1, false, false);
    m_HwPort__bitWidth->setID(false);
    m_HwPort__priority->setEType(
            dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEInt());
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute > (m_HwPort__priority),
            "priority", true, false, false, "0", false, false, true, false, 0,
            1, false, false);
    m_HwPort__priority->setID(false);
    m_HwPort__portType->setEType(m_PortTypeEEnum);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute > (m_HwPort__portType),
            "portType", true, false, false, "", false, false, true, false, 0, 1,
            false, false);
    m_HwPort__portType->setID(false);
    m_HwPort__portInterface->setEType(m_PortInterfaceEEnum);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute > (m_HwPort__portInterface),
            "portInterface", true, false, false, "", false, false, true, false,
            0, 1, false, false);
    m_HwPort__portInterface->setID(false);
    m_HwPort__delegated->setEType(
            dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEBoolean());
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute > (m_HwPort__delegated),
            "delegated", false, true, true, "", false, true, true, false, 0, 1,
            false, false);
    m_HwPort__delegated->setID(false);
    m_HwPort__connections->setEType(m_HwConnectionEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_HwPort__connections),
            "connections", false, true, true, "", false, true, true, true, 0,
            -1, true, false);
    m_HwPort__connections->setContainment(false);
    m_HwPort__connections->setResolveProxies(true);
    {
        ::ecore::EOperation_ptr _op = addEOperation(m_HwPortEClass, nullptr,
                "getNamePrefixSegments", 0, -1, false, true);
        _op->setEType(
                dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEString());
    }
    // ConnectionHandler
    m_ConnectionHandlerEClass->setName("ConnectionHandler");
    m_ConnectionHandlerEClass->setAbstract(false);
    m_ConnectionHandlerEClass->setInterface(false);
    m_ConnectionHandler__definition->setEType(
            m_ConnectionHandlerDefinitionEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_ConnectionHandler__definition), "definition", true,
            false, false, "", false, false, true, true, 0, 1, false, false);
    m_ConnectionHandler__definition->setContainment(false);
    m_ConnectionHandler__definition->setResolveProxies(true);
    m_ConnectionHandler__internalConnections->setEType(m_HwConnectionEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_ConnectionHandler__internalConnections),
            "internalConnections", true, false, false, "", false, false, true,
            true, 0, -1, true, false);
    m_ConnectionHandler__internalConnections->setContainment(true);
    m_ConnectionHandler__internalConnections->setResolveProxies(false);
    // HwConnection
    m_HwConnectionEClass->setName("HwConnection");
    m_HwConnectionEClass->setAbstract(false);
    m_HwConnectionEClass->setInterface(false);
    m_HwConnection__internal->setEType(
            dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEBoolean());
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute > (m_HwConnection__internal),
            "internal", false, true, true, "", false, true, true, false, 0, 1,
            false, false);
    m_HwConnection__internal->setID(false);
    m_HwConnection__readLatency->setEType(m_IDiscreteValueDeviationEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_HwConnection__readLatency),
            "readLatency", true, false, false, "", false, false, true, true, 0,
            1, false, false);
    m_HwConnection__readLatency->setContainment(true);
    m_HwConnection__readLatency->setResolveProxies(false);
    m_HwConnection__writeLatency->setEType(m_IDiscreteValueDeviationEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_HwConnection__writeLatency),
            "writeLatency", true, false, false, "", false, false, true, true, 0,
            1, false, false);
    m_HwConnection__writeLatency->setContainment(true);
    m_HwConnection__writeLatency->setResolveProxies(false);
    m_HwConnection__dataRate->setEType(m_DataRateEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_HwConnection__dataRate),
            "dataRate", true, false, false, "", false, false, true, true, 0, 1,
            false, false);
    m_HwConnection__dataRate->setContainment(true);
    m_HwConnection__dataRate->setResolveProxies(false);
    m_HwConnection__port1->setEType(m_HwPortEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_HwConnection__port1),
            "port1", true, false, false, "", false, false, true, true, 0, 1,
            false, false);
    m_HwConnection__port1->setContainment(false);
    m_HwConnection__port1->setResolveProxies(true);
    m_HwConnection__port2->setEType(m_HwPortEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_HwConnection__port2),
            "port2", true, false, false, "", false, false, true, true, 0, 1,
            false, false);
    m_HwConnection__port2->setContainment(false);
    m_HwConnection__port2->setResolveProxies(true);
    {
        ::ecore::EOperation_ptr _op = addEOperation(m_HwConnectionEClass,
                nullptr, "getNamePrefixSegments", 0, -1, false, true);
        _op->setEType(
                dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEString());
    }
    {
        ::ecore::EOperation_ptr _op = addEOperation(m_HwConnectionEClass,
                nullptr, "getPorts", 0, -1, false, true);
        _op->setEType(m_HwPortEClass);
    }
    // HwAccessElement
    m_HwAccessElementEClass->setName("HwAccessElement");
    m_HwAccessElementEClass->setAbstract(false);
    m_HwAccessElementEClass->setInterface(false);
    m_HwAccessElement__source->setEType(m_ProcessingUnitEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_HwAccessElement__source),
            "source", false, false, false, "", false, false, true, true, 0, 1,
            false, false);
    m_HwAccessElement__source->setContainment(false);
    m_HwAccessElement__source->setResolveProxies(true);
    m_HwAccessElement__source->setEOpposite(
            ::ecore::as < ::ecore::EReference
                    > (m_ProcessingUnitEClass->getEStructuralFeatures()[1]));
    m_HwAccessElement__destination->setEType(m_HwDestinationEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_HwAccessElement__destination), "destination", true,
            false, false, "", false, false, true, true, 1, 1, false, true);
    m_HwAccessElement__destination->setContainment(false);
    m_HwAccessElement__destination->setResolveProxies(true);
    m_HwAccessElement__accessPath->setEType(m_HwAccessPathEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_HwAccessElement__accessPath),
            "accessPath", true, false, false, "", false, false, true, true, 0,
            1, false, false);
    m_HwAccessElement__accessPath->setContainment(true);
    m_HwAccessElement__accessPath->setResolveProxies(false);
    m_HwAccessElement__accessPath->setEOpposite(
            ::ecore::as < ::ecore::EReference
                    > (m_HwAccessPathEClass->getEStructuralFeatures()[3]));
    m_HwAccessElement__readLatency->setEType(m_IDiscreteValueDeviationEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_HwAccessElement__readLatency), "readLatency", true,
            false, false, "", false, false, true, true, 0, 1, false, false);
    m_HwAccessElement__readLatency->setContainment(true);
    m_HwAccessElement__readLatency->setResolveProxies(false);
    m_HwAccessElement__writeLatency->setEType(m_IDiscreteValueDeviationEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_HwAccessElement__writeLatency), "writeLatency", true,
            false, false, "", false, false, true, true, 0, 1, false, false);
    m_HwAccessElement__writeLatency->setContainment(true);
    m_HwAccessElement__writeLatency->setResolveProxies(false);
    m_HwAccessElement__dataRate->setEType(m_DataRateEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_HwAccessElement__dataRate),
            "dataRate", true, false, false, "", false, false, true, true, 0, 1,
            false, false);
    m_HwAccessElement__dataRate->setContainment(true);
    m_HwAccessElement__dataRate->setResolveProxies(false);
    // HwDefinition
    m_HwDefinitionEClass->setName("HwDefinition");
    m_HwDefinitionEClass->setAbstract(true);
    m_HwDefinitionEClass->setInterface(false);
    // ProcessingUnitDefinition
    m_ProcessingUnitDefinitionEClass->setName("ProcessingUnitDefinition");
    m_ProcessingUnitDefinitionEClass->setAbstract(false);
    m_ProcessingUnitDefinitionEClass->setInterface(false);
    m_ProcessingUnitDefinition__puType->setEType(m_PuTypeEEnum);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute
                    > (m_ProcessingUnitDefinition__puType), "puType", true,
            false, false, "", false, false, true, false, 0, 1, false, false);
    m_ProcessingUnitDefinition__puType->setID(false);
    m_ProcessingUnitDefinition__features->setEType(m_HwFeatureEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_ProcessingUnitDefinition__features), "features", true,
            false, false, "", false, false, true, true, 0, -1, true, false);
    m_ProcessingUnitDefinition__features->setContainment(false);
    m_ProcessingUnitDefinition__features->setResolveProxies(true);
    m_ProcessingUnitDefinition__classifiers->setEType(m_CoreClassifierEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_ProcessingUnitDefinition__classifiers), "classifiers",
            true, false, false, "", false, false, true, true, 0, -1, true,
            false);
    m_ProcessingUnitDefinition__classifiers->setContainment(false);
    m_ProcessingUnitDefinition__classifiers->setResolveProxies(true);
    // ConnectionHandlerDefinition
    m_ConnectionHandlerDefinitionEClass->setName("ConnectionHandlerDefinition");
    m_ConnectionHandlerDefinitionEClass->setAbstract(false);
    m_ConnectionHandlerDefinitionEClass->setInterface(false);
    m_ConnectionHandlerDefinition__policy->setEType(m_SchedPolicyEEnum);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute
                    > (m_ConnectionHandlerDefinition__policy), "policy", true,
            false, false, "", false, false, true, false, 0, 1, false, false);
    m_ConnectionHandlerDefinition__policy->setID(false);
    m_ConnectionHandlerDefinition__maxBurstSize->setEType(
            m_PositiveIntEDataType);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute
                    > (m_ConnectionHandlerDefinition__maxBurstSize),
            "maxBurstSize", true, false, false, "1", false, false, true, false,
            0, 1, false, false);
    m_ConnectionHandlerDefinition__maxBurstSize->setID(false);
    m_ConnectionHandlerDefinition__maxConcurrentTransfers->setEType(
            m_PositiveIntEDataType);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute
                    > (m_ConnectionHandlerDefinition__maxConcurrentTransfers),
            "maxConcurrentTransfers", true, false, false, "1", false, false,
            true, false, 0, 1, false, false);
    m_ConnectionHandlerDefinition__maxConcurrentTransfers->setID(false);
    m_ConnectionHandlerDefinition__readLatency->setEType(
            m_IDiscreteValueDeviationEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_ConnectionHandlerDefinition__readLatency),
            "readLatency", true, false, false, "", false, false, true, true, 0,
            1, false, false);
    m_ConnectionHandlerDefinition__readLatency->setContainment(true);
    m_ConnectionHandlerDefinition__readLatency->setResolveProxies(false);
    m_ConnectionHandlerDefinition__writeLatency->setEType(
            m_IDiscreteValueDeviationEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_ConnectionHandlerDefinition__writeLatency),
            "writeLatency", true, false, false, "", false, false, true, true, 0,
            1, false, false);
    m_ConnectionHandlerDefinition__writeLatency->setContainment(true);
    m_ConnectionHandlerDefinition__writeLatency->setResolveProxies(false);
    m_ConnectionHandlerDefinition__dataRate->setEType(m_DataRateEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_ConnectionHandlerDefinition__dataRate), "dataRate",
            true, false, false, "", false, false, true, true, 0, 1, false,
            false);
    m_ConnectionHandlerDefinition__dataRate->setContainment(true);
    m_ConnectionHandlerDefinition__dataRate->setResolveProxies(false);
    // MemoryDefinition
    m_MemoryDefinitionEClass->setName("MemoryDefinition");
    m_MemoryDefinitionEClass->setAbstract(false);
    m_MemoryDefinitionEClass->setInterface(false);
    m_MemoryDefinition__memoryType->setEType(m_MemoryTypeEEnum);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute
                    > (m_MemoryDefinition__memoryType), "memoryType", true,
            false, false, "", false, false, true, false, 0, 1, false, false);
    m_MemoryDefinition__memoryType->setID(false);
    m_MemoryDefinition__size->setEType(m_DataSizeEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_MemoryDefinition__size),
            "size", true, false, false, "", false, false, true, true, 0, 1,
            false, false);
    m_MemoryDefinition__size->setContainment(true);
    m_MemoryDefinition__size->setResolveProxies(false);
    m_MemoryDefinition__accessLatency->setEType(
            m_IDiscreteValueDeviationEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_MemoryDefinition__accessLatency), "accessLatency",
            true, false, false, "", false, false, true, true, 0, 1, false,
            false);
    m_MemoryDefinition__accessLatency->setContainment(true);
    m_MemoryDefinition__accessLatency->setResolveProxies(false);
    m_MemoryDefinition__dataRate->setEType(m_DataRateEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_MemoryDefinition__dataRate),
            "dataRate", true, false, false, "", false, false, true, true, 0, 1,
            false, false);
    m_MemoryDefinition__dataRate->setContainment(true);
    m_MemoryDefinition__dataRate->setResolveProxies(false);
    m_MemoryDefinition__classifiers->setEType(m_MemoryClassifierEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_MemoryDefinition__classifiers), "classifiers", true,
            false, false, "", false, false, true, true, 0, -1, true, false);
    m_MemoryDefinition__classifiers->setContainment(false);
    m_MemoryDefinition__classifiers->setResolveProxies(true);
    // CacheDefinition
    m_CacheDefinitionEClass->setName("CacheDefinition");
    m_CacheDefinitionEClass->setAbstract(false);
    m_CacheDefinitionEClass->setInterface(false);
    m_CacheDefinition__cacheType->setEType(m_CacheTypeEEnum);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute > (m_CacheDefinition__cacheType),
            "cacheType", true, false, false, "", false, false, true, false, 0,
            1, false, false);
    m_CacheDefinition__cacheType->setID(false);
    m_CacheDefinition__writeStrategy->setEType(m_WriteStrategyEEnum);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute
                    > (m_CacheDefinition__writeStrategy), "writeStrategy", true,
            false, false, "", false, false, true, false, 0, 1, false, false);
    m_CacheDefinition__writeStrategy->setID(false);
    m_CacheDefinition__nWays->setEType(
            dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEInt());
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute > (m_CacheDefinition__nWays),
            "nWays", true, false, false, "0", false, false, true, false, 0, 1,
            false, false);
    m_CacheDefinition__nWays->setID(false);
    m_CacheDefinition__coherency->setEType(
            dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEBoolean());
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute > (m_CacheDefinition__coherency),
            "coherency", true, false, false, "false", false, false, true, false,
            0, 1, false, false);
    m_CacheDefinition__coherency->setID(false);
    m_CacheDefinition__exclusive->setEType(
            dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEBoolean());
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute > (m_CacheDefinition__exclusive),
            "exclusive", true, false, false, "false", false, false, true, false,
            0, 1, false, false);
    m_CacheDefinition__exclusive->setID(false);
    m_CacheDefinition__hitRate->setEType(
            dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEDouble());
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute > (m_CacheDefinition__hitRate),
            "hitRate", true, false, false, "0.0", false, false, true, false, 0,
            1, false, false);
    m_CacheDefinition__hitRate->setID(false);
    m_CacheDefinition__size->setEType(m_DataSizeEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_CacheDefinition__size),
            "size", true, false, false, "", false, false, true, true, 0, 1,
            false, false);
    m_CacheDefinition__size->setContainment(true);
    m_CacheDefinition__size->setResolveProxies(false);
    m_CacheDefinition__lineSize->setEType(m_DataSizeEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_CacheDefinition__lineSize),
            "lineSize", true, false, false, "", false, false, true, true, 0, 1,
            false, false);
    m_CacheDefinition__lineSize->setContainment(true);
    m_CacheDefinition__lineSize->setResolveProxies(false);
    m_CacheDefinition__accessLatency->setEType(m_IDiscreteValueDeviationEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_CacheDefinition__accessLatency), "accessLatency", true,
            false, false, "", false, false, true, true, 0, 1, false, false);
    m_CacheDefinition__accessLatency->setContainment(true);
    m_CacheDefinition__accessLatency->setResolveProxies(false);
    // HwPath
    m_HwPathEClass->setName("HwPath");
    m_HwPathEClass->setAbstract(true);
    m_HwPathEClass->setInterface(false);
    m_HwPath__source->setEType(m_ProcessingUnitEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_HwPath__source), "source",
            false, true, true, "", false, true, true, true, 0, 1, false, false);
    m_HwPath__source->setContainment(false);
    m_HwPath__source->setResolveProxies(true);
    m_HwPath__destination->setEType(m_HwDestinationEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_HwPath__destination),
            "destination", false, true, true, "", false, true, true, true, 0, 1,
            false, false);
    m_HwPath__destination->setContainment(false);
    m_HwPath__destination->setResolveProxies(true);
    {
        ::ecore::EOperation_ptr _op = addEOperation(m_HwPathEClass, nullptr,
                "getContainingAccessElement", 0, 1, false, true);
        _op->setEType(m_HwAccessElementEClass);
    }
    // HwAccessPath
    m_HwAccessPathEClass->setName("HwAccessPath");
    m_HwAccessPathEClass->setAbstract(false);
    m_HwAccessPathEClass->setInterface(false);
    m_HwAccessPath__startAddress->setEType(m_AddressEDataType);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute > (m_HwAccessPath__startAddress),
            "startAddress", true, false, false, "0", false, false, true, false,
            0, 1, false, false);
    m_HwAccessPath__startAddress->setID(false);
    m_HwAccessPath__endAddress->setEType(m_AddressEDataType);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute > (m_HwAccessPath__endAddress),
            "endAddress", true, false, false, "0", false, false, true, false, 0,
            1, false, false);
    m_HwAccessPath__endAddress->setID(false);
    m_HwAccessPath__memOffset->setEType(m_AddressEDataType);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute > (m_HwAccessPath__memOffset),
            "memOffset", true, false, false, "0", false, false, true, false, 0,
            1, false, false);
    m_HwAccessPath__memOffset->setID(false);
    m_HwAccessPath__containingAccessElement->setEType(m_HwAccessElementEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_HwAccessPath__containingAccessElement),
            "containingAccessElement", false, false, false, "", false, false,
            true, true, 0, 1, false, false);
    m_HwAccessPath__containingAccessElement->setContainment(false);
    m_HwAccessPath__containingAccessElement->setResolveProxies(true);
    m_HwAccessPath__containingAccessElement->setEOpposite(
            ::ecore::as < ::ecore::EReference
                    > (m_HwAccessElementEClass->getEStructuralFeatures()[2]));
    m_HwAccessPath__pathElements->setEType(m_HwPathElementEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_HwAccessPath__pathElements),
            "pathElements", true, false, false, "", false, false, true, true, 1,
            -1, true, true);
    m_HwAccessPath__pathElements->setContainment(false);
    m_HwAccessPath__pathElements->setResolveProxies(true);
    // HwPathElement
    m_HwPathElementEClass->setName("HwPathElement");
    m_HwPathElementEClass->setAbstract(true);
    m_HwPathElementEClass->setInterface(true);
    {
        ::ecore::EOperation_ptr _op = addEOperation(m_HwPathElementEClass,
                nullptr, "getPorts", 0, -1, false, true);
        _op->setEType(m_HwPortEClass);
    }
    // HwDestination
    m_HwDestinationEClass->setName("HwDestination");
    m_HwDestinationEClass->setAbstract(true);
    m_HwDestinationEClass->setInterface(true);
    {
        ::ecore::EOperation_ptr _op = addEOperation(m_HwDestinationEClass,
                nullptr, "getPorts", 0, -1, false, true);
        _op->setEType(m_HwPortEClass);
    }
    // MappingModel
    m_MappingModelEClass->setName("MappingModel");
    m_MappingModelEClass->setAbstract(false);
    m_MappingModelEClass->setInterface(false);
    m_MappingModel__addressMappingType->setEType(
            m_MemoryAddressMappingTypeEEnum);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute
                    > (m_MappingModel__addressMappingType),
            "addressMappingType", true, false, false, "", false, false, true,
            false, 0, 1, false, false);
    m_MappingModel__addressMappingType->setID(false);
    m_MappingModel__schedulerAllocation->setEType(m_SchedulerAllocationEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_MappingModel__schedulerAllocation),
            "schedulerAllocation", true, false, false, "", false, false, true,
            true, 0, -1, true, false);
    m_MappingModel__schedulerAllocation->setContainment(true);
    m_MappingModel__schedulerAllocation->setResolveProxies(false);
    m_MappingModel__runnableAllocation->setEType(m_RunnableAllocationEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_MappingModel__runnableAllocation),
            "runnableAllocation", true, false, false, "", false, false, true,
            true, 0, -1, true, false);
    m_MappingModel__runnableAllocation->setContainment(true);
    m_MappingModel__runnableAllocation->setResolveProxies(false);
    m_MappingModel__taskAllocation->setEType(m_TaskAllocationEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_MappingModel__taskAllocation), "taskAllocation", true,
            false, false, "", false, false, true, true, 0, -1, true, false);
    m_MappingModel__taskAllocation->setContainment(true);
    m_MappingModel__taskAllocation->setResolveProxies(false);
    m_MappingModel__isrAllocation->setEType(m_ISRAllocationEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_MappingModel__isrAllocation),
            "isrAllocation", true, false, false, "", false, false, true, true,
            0, -1, true, false);
    m_MappingModel__isrAllocation->setContainment(true);
    m_MappingModel__isrAllocation->setResolveProxies(false);
    m_MappingModel__memoryMapping->setEType(m_MemoryMappingEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_MappingModel__memoryMapping),
            "memoryMapping", true, false, false, "", false, false, true, true,
            0, -1, true, false);
    m_MappingModel__memoryMapping->setContainment(true);
    m_MappingModel__memoryMapping->setResolveProxies(false);
    m_MappingModel__physicalSectionMapping->setEType(
            m_PhysicalSectionMappingEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_MappingModel__physicalSectionMapping),
            "physicalSectionMapping", true, false, false, "", false, false,
            true, true, 0, -1, true, false);
    m_MappingModel__physicalSectionMapping->setContainment(true);
    m_MappingModel__physicalSectionMapping->setResolveProxies(false);
    // SchedulerAllocation
    m_SchedulerAllocationEClass->setName("SchedulerAllocation");
    m_SchedulerAllocationEClass->setAbstract(false);
    m_SchedulerAllocationEClass->setInterface(false);
    m_SchedulerAllocation__scheduler->setEType(m_SchedulerEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_SchedulerAllocation__scheduler), "scheduler", true,
            false, false, "", false, false, true, true, 1, 1, false, true);
    m_SchedulerAllocation__scheduler->setContainment(false);
    m_SchedulerAllocation__scheduler->setResolveProxies(true);
    m_SchedulerAllocation__responsibility->setEType(m_ProcessingUnitEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_SchedulerAllocation__responsibility), "responsibility",
            true, false, false, "", false, false, true, true, 1, -1, true,
            true);
    m_SchedulerAllocation__responsibility->setContainment(false);
    m_SchedulerAllocation__responsibility->setResolveProxies(true);
    m_SchedulerAllocation__executingPU->setEType(m_ProcessingUnitEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_SchedulerAllocation__executingPU), "executingPU", true,
            false, false, "", false, false, true, true, 0, 1, false, false);
    m_SchedulerAllocation__executingPU->setContainment(false);
    m_SchedulerAllocation__executingPU->setResolveProxies(true);
    // TaskAllocation
    m_TaskAllocationEClass->setName("TaskAllocation");
    m_TaskAllocationEClass->setAbstract(false);
    m_TaskAllocationEClass->setInterface(false);
    m_TaskAllocation__task->setEType(m_TaskEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_TaskAllocation__task),
            "task", true, false, false, "", false, false, true, true, 1, 1,
            false, true);
    m_TaskAllocation__task->setContainment(false);
    m_TaskAllocation__task->setResolveProxies(true);
    m_TaskAllocation__scheduler->setEType(m_TaskSchedulerEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_TaskAllocation__scheduler),
            "scheduler", true, false, false, "", false, false, true, true, 1, 1,
            false, true);
    m_TaskAllocation__scheduler->setContainment(false);
    m_TaskAllocation__scheduler->setResolveProxies(true);
    m_TaskAllocation__affinity->setEType(m_ProcessingUnitEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_TaskAllocation__affinity),
            "affinity", true, false, false, "", false, false, true, true, 0, -1,
            true, false);
    m_TaskAllocation__affinity->setContainment(false);
    m_TaskAllocation__affinity->setResolveProxies(true);
    m_TaskAllocation__schedulingParameters->setEType(
            m_SchedulingParametersEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_TaskAllocation__schedulingParameters),
            "schedulingParameters", true, false, false, "", false, false, true,
            true, 0, 1, false, false);
    m_TaskAllocation__schedulingParameters->setContainment(true);
    m_TaskAllocation__schedulingParameters->setResolveProxies(false);
    m_TaskAllocation__parameterExtensions->setEType(m_ParameterExtensionEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_TaskAllocation__parameterExtensions),
            "parameterExtensions", true, false, false, "", false, false, true,
            true, 0, -1, true, false);
    m_TaskAllocation__parameterExtensions->setContainment(true);
    m_TaskAllocation__parameterExtensions->setResolveProxies(false);
    // ISRAllocation
    m_ISRAllocationEClass->setName("ISRAllocation");
    m_ISRAllocationEClass->setAbstract(false);
    m_ISRAllocationEClass->setInterface(false);
    m_ISRAllocation__priority->setEType(
            dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEIntegerObject());
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute > (m_ISRAllocation__priority),
            "priority", true, false, false, "", false, false, true, false, 0, 1,
            false, false);
    m_ISRAllocation__priority->setID(false);
    m_ISRAllocation__isr->setEType(m_ISREClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_ISRAllocation__isr), "isr",
            true, false, false, "", false, false, true, true, 1, 1, false,
            true);
    m_ISRAllocation__isr->setContainment(false);
    m_ISRAllocation__isr->setResolveProxies(true);
    m_ISRAllocation__controller->setEType(m_InterruptControllerEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_ISRAllocation__controller),
            "controller", true, false, false, "", false, false, true, true, 1,
            1, false, true);
    m_ISRAllocation__controller->setContainment(false);
    m_ISRAllocation__controller->setResolveProxies(true);
    // RunnableAllocation
    m_RunnableAllocationEClass->setName("RunnableAllocation");
    m_RunnableAllocationEClass->setAbstract(false);
    m_RunnableAllocationEClass->setInterface(false);
    m_RunnableAllocation__scheduler->setEType(m_SchedulerEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_RunnableAllocation__scheduler), "scheduler", true,
            false, false, "", false, false, true, true, 1, 1, false, true);
    m_RunnableAllocation__scheduler->setContainment(false);
    m_RunnableAllocation__scheduler->setResolveProxies(true);
    m_RunnableAllocation__entity->setEType(m_RunnableEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_RunnableAllocation__entity),
            "entity", true, false, false, "", false, false, true, true, 1, 1,
            false, true);
    m_RunnableAllocation__entity->setContainment(false);
    m_RunnableAllocation__entity->setResolveProxies(true);
    // MemoryMapping
    m_MemoryMappingEClass->setName("MemoryMapping");
    m_MemoryMappingEClass->setAbstract(false);
    m_MemoryMappingEClass->setInterface(false);
    m_MemoryMapping__memoryPositionAddress->setEType(m_AddressEDataType);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute
                    > (m_MemoryMapping__memoryPositionAddress),
            "memoryPositionAddress", true, false, false, "0", false, false,
            true, false, 0, 1, false, false);
    m_MemoryMapping__memoryPositionAddress->setID(false);
    m_MemoryMapping__abstractElement->setEType(m_AbstractMemoryElementEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_MemoryMapping__abstractElement), "abstractElement",
            true, false, false, "", false, false, true, true, 1, 1, false,
            true);
    m_MemoryMapping__abstractElement->setContainment(false);
    m_MemoryMapping__abstractElement->setResolveProxies(true);
    m_MemoryMapping__memory->setEType(m_MemoryEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_MemoryMapping__memory),
            "memory", true, false, false, "", false, false, true, true, 0, 1,
            false, false);
    m_MemoryMapping__memory->setContainment(false);
    m_MemoryMapping__memory->setResolveProxies(true);
    // PhysicalSectionMapping
    m_PhysicalSectionMappingEClass->setName("PhysicalSectionMapping");
    m_PhysicalSectionMappingEClass->setAbstract(false);
    m_PhysicalSectionMappingEClass->setInterface(false);
    m_PhysicalSectionMapping__startAddress->setEType(m_AddressEDataType);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute
                    > (m_PhysicalSectionMapping__startAddress), "startAddress",
            true, false, false, "0", false, false, true, false, 0, 1, false,
            false);
    m_PhysicalSectionMapping__startAddress->setID(false);
    m_PhysicalSectionMapping__endAddress->setEType(m_AddressEDataType);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute
                    > (m_PhysicalSectionMapping__endAddress), "endAddress",
            true, false, false, "0", false, false, true, false, 0, 1, false,
            false);
    m_PhysicalSectionMapping__endAddress->setID(false);
    m_PhysicalSectionMapping__origin->setEType(m_SectionEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_PhysicalSectionMapping__origin), "origin", true, false,
            false, "", false, false, true, true, 1, -1, true, true);
    m_PhysicalSectionMapping__origin->setContainment(false);
    m_PhysicalSectionMapping__origin->setResolveProxies(true);
    m_PhysicalSectionMapping__memory->setEType(m_MemoryEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_PhysicalSectionMapping__memory), "memory", true, false,
            false, "", false, false, true, true, 1, 1, false, true);
    m_PhysicalSectionMapping__memory->setContainment(false);
    m_PhysicalSectionMapping__memory->setResolveProxies(true);
    m_PhysicalSectionMapping__labels->setEType(m_LabelEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_PhysicalSectionMapping__labels), "labels", true, false,
            false, "", false, false, true, true, 0, -1, true, false);
    m_PhysicalSectionMapping__labels->setContainment(false);
    m_PhysicalSectionMapping__labels->setResolveProxies(true);
    m_PhysicalSectionMapping__runEntities->setEType(m_RunnableEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_PhysicalSectionMapping__runEntities), "runEntities",
            true, false, false, "", false, false, true, true, 0, -1, true,
            false);
    m_PhysicalSectionMapping__runEntities->setContainment(false);
    m_PhysicalSectionMapping__runEntities->setResolveProxies(true);
    // OSModel
    m_OSModelEClass->setName("OSModel");
    m_OSModelEClass->setAbstract(false);
    m_OSModelEClass->setInterface(false);
    m_OSModel__semaphores->setEType(m_SemaphoreEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_OSModel__semaphores),
            "semaphores", true, false, false, "", false, false, true, true, 0,
            -1, true, false);
    m_OSModel__semaphores->setContainment(true);
    m_OSModel__semaphores->setResolveProxies(false);
    m_OSModel__operatingSystems->setEType(m_OperatingSystemEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_OSModel__operatingSystems),
            "operatingSystems", true, false, false, "", false, false, true,
            true, 0, -1, true, false);
    m_OSModel__operatingSystems->setContainment(true);
    m_OSModel__operatingSystems->setResolveProxies(false);
    m_OSModel__osOverheads->setEType(m_OsOverheadEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_OSModel__osOverheads),
            "osOverheads", true, false, false, "", false, false, true, true, 0,
            -1, true, false);
    m_OSModel__osOverheads->setContainment(true);
    m_OSModel__osOverheads->setResolveProxies(false);
    // OsDataConsistency
    m_OsDataConsistencyEClass->setName("OsDataConsistency");
    m_OsDataConsistencyEClass->setAbstract(false);
    m_OsDataConsistencyEClass->setInterface(false);
    m_OsDataConsistency__mode->setEType(m_OsDataConsistencyModeEEnum);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute > (m_OsDataConsistency__mode),
            "mode", true, false, false, "", false, false, true, false, 0, 1,
            false, false);
    m_OsDataConsistency__mode->setID(false);
    m_OsDataConsistency__dataStability->setEType(m_DataStabilityEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_OsDataConsistency__dataStability), "dataStability",
            true, false, false, "", false, false, true, true, 0, 1, false,
            false);
    m_OsDataConsistency__dataStability->setContainment(true);
    m_OsDataConsistency__dataStability->setResolveProxies(false);
    m_OsDataConsistency__nonAtomicDataCoherency->setEType(
            m_NonAtomicDataCoherencyEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_OsDataConsistency__nonAtomicDataCoherency),
            "nonAtomicDataCoherency", true, false, false, "", false, false,
            true, true, 0, 1, false, false);
    m_OsDataConsistency__nonAtomicDataCoherency->setContainment(true);
    m_OsDataConsistency__nonAtomicDataCoherency->setResolveProxies(false);
    // DataStability
    m_DataStabilityEClass->setName("DataStability");
    m_DataStabilityEClass->setAbstract(false);
    m_DataStabilityEClass->setInterface(false);
    m_DataStability__enabled->setEType(
            dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEBoolean());
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute > (m_DataStability__enabled),
            "enabled", true, false, false, "false", false, false, true, false,
            0, 1, false, false);
    m_DataStability__enabled->setID(false);
    m_DataStability__algorithm->setEType(
            dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEString());
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute > (m_DataStability__algorithm),
            "algorithm", true, false, false, "", false, false, true, false, 0,
            1, false, false);
    m_DataStability__algorithm->setID(false);
    m_DataStability__accessMultiplicity->setEType(m_AccessMultiplicityEEnum);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute
                    > (m_DataStability__accessMultiplicity),
            "accessMultiplicity", true, false, false, "", false, false, true,
            false, 0, 1, false, false);
    m_DataStability__accessMultiplicity->setID(false);
    m_DataStability__level->setEType(m_DataStabilityLevelEEnum);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute > (m_DataStability__level),
            "level", true, false, false, "", false, false, true, false, 0, 1,
            false, false);
    m_DataStability__level->setID(false);
    // NonAtomicDataCoherency
    m_NonAtomicDataCoherencyEClass->setName("NonAtomicDataCoherency");
    m_NonAtomicDataCoherencyEClass->setAbstract(false);
    m_NonAtomicDataCoherencyEClass->setInterface(false);
    m_NonAtomicDataCoherency__enabled->setEType(
            dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEBoolean());
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute
                    > (m_NonAtomicDataCoherency__enabled), "enabled", true,
            false, false, "false", false, false, true, false, 0, 1, false,
            false);
    m_NonAtomicDataCoherency__enabled->setID(false);
    m_NonAtomicDataCoherency__algorithm->setEType(
            dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEString());
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute
                    > (m_NonAtomicDataCoherency__algorithm), "algorithm", true,
            false, false, "", false, false, true, false, 0, 1, false, false);
    m_NonAtomicDataCoherency__algorithm->setID(false);
    m_NonAtomicDataCoherency__accessMultiplicity->setEType(
            m_AccessMultiplicityEEnum);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute
                    > (m_NonAtomicDataCoherency__accessMultiplicity),
            "accessMultiplicity", true, false, false, "", false, false, true,
            false, 0, 1, false, false);
    m_NonAtomicDataCoherency__accessMultiplicity->setID(false);
    // Semaphore
    m_SemaphoreEClass->setName("Semaphore");
    m_SemaphoreEClass->setAbstract(false);
    m_SemaphoreEClass->setInterface(false);
    m_Semaphore__semaphoreType->setEType(m_SemaphoreTypeEEnum);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute > (m_Semaphore__semaphoreType),
            "semaphoreType", true, false, false, "", false, false, true, false,
            0, 1, false, false);
    m_Semaphore__semaphoreType->setID(false);
    m_Semaphore__initialValue->setEType(
            dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEInt());
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute > (m_Semaphore__initialValue),
            "initialValue", true, false, false, "0", false, false, true, false,
            0, 1, false, false);
    m_Semaphore__initialValue->setID(false);
    m_Semaphore__maxValue->setEType(
            dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEInt());
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute > (m_Semaphore__maxValue),
            "maxValue", true, false, false, "0", false, false, true, false, 0,
            1, false, false);
    m_Semaphore__maxValue->setID(false);
    m_Semaphore__priorityCeilingProtocol->setEType(
            dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEBoolean());
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute
                    > (m_Semaphore__priorityCeilingProtocol),
            "priorityCeilingProtocol", true, false, false, "false", false,
            false, true, false, 0, 1, false, false);
    m_Semaphore__priorityCeilingProtocol->setID(false);
    m_Semaphore__semaphoreAccesses->setEType(m_SemaphoreAccessEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_Semaphore__semaphoreAccesses), "semaphoreAccesses",
            false, true, true, "", false, true, true, true, 0, -1, true, false);
    m_Semaphore__semaphoreAccesses->setContainment(false);
    m_Semaphore__semaphoreAccesses->setResolveProxies(true);
    m_Semaphore__referringComponents->setEType(m_ComponentEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_Semaphore__referringComponents), "referringComponents",
            false, true, true, "", false, true, true, true, 0, -1, true, false);
    m_Semaphore__referringComponents->setContainment(false);
    m_Semaphore__referringComponents->setResolveProxies(true);
    // Scheduler
    m_SchedulerEClass->setName("Scheduler");
    m_SchedulerEClass->setAbstract(true);
    m_SchedulerEClass->setInterface(false);
    m_Scheduler__computationItems->setEType(m_ComputationItemEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_Scheduler__computationItems),
            "computationItems", true, false, false, "", false, false, true,
            true, 0, -1, true, false);
    m_Scheduler__computationItems->setContainment(true);
    m_Scheduler__computationItems->setResolveProxies(false);
    m_Scheduler__schedulerAllocations->setEType(m_SchedulerAllocationEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_Scheduler__schedulerAllocations),
            "schedulerAllocations", false, true, true, "", false, true, true,
            true, 0, -1, true, false);
    m_Scheduler__schedulerAllocations->setContainment(false);
    m_Scheduler__schedulerAllocations->setResolveProxies(true);
    m_Scheduler__runnableAllocations->setEType(m_RunnableAllocationEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_Scheduler__runnableAllocations), "runnableAllocations",
            false, true, true, "", false, true, true, true, 0, -1, true, false);
    m_Scheduler__runnableAllocations->setContainment(false);
    m_Scheduler__runnableAllocations->setResolveProxies(true);
    {
        ::ecore::EOperation_ptr _op = addEOperation(m_SchedulerEClass, nullptr,
                "getSchedulingAlgorithm", 0, 1, false, true);
        _op->setEType(m_AlgorithmEClass);
    }
    // TaskScheduler
    m_TaskSchedulerEClass->setName("TaskScheduler");
    m_TaskSchedulerEClass->setAbstract(false);
    m_TaskSchedulerEClass->setInterface(false);
    m_TaskScheduler__schedulingAlgorithm->setEType(
            m_TaskSchedulingAlgorithmEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_TaskScheduler__schedulingAlgorithm),
            "schedulingAlgorithm", true, false, false, "", false, false, true,
            true, 0, 1, false, false);
    m_TaskScheduler__schedulingAlgorithm->setContainment(true);
    m_TaskScheduler__schedulingAlgorithm->setResolveProxies(false);
    m_TaskScheduler__parentAssociation->setEType(m_SchedulerAssociationEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_TaskScheduler__parentAssociation), "parentAssociation",
            true, false, false, "", false, false, true, true, 0, 1, false,
            false);
    m_TaskScheduler__parentAssociation->setContainment(true);
    m_TaskScheduler__parentAssociation->setResolveProxies(false);
    m_TaskScheduler__parentAssociation->setEOpposite(
            ::ecore::as < ::ecore::EReference
                    > (m_SchedulerAssociationEClass->getEStructuralFeatures()[0]));
    m_TaskScheduler__childAssociations->setEType(m_SchedulerAssociationEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_TaskScheduler__childAssociations), "childAssociations",
            false, true, true, "", false, true, true, true, 0, -1, true, false);
    m_TaskScheduler__childAssociations->setContainment(false);
    m_TaskScheduler__childAssociations->setResolveProxies(true);
    m_TaskScheduler__taskAllocations->setEType(m_TaskAllocationEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_TaskScheduler__taskAllocations), "taskAllocations",
            false, true, true, "", false, true, true, true, 0, -1, true, false);
    m_TaskScheduler__taskAllocations->setContainment(false);
    m_TaskScheduler__taskAllocations->setResolveProxies(true);
    m_TaskScheduler__parentScheduler->setEType(m_TaskSchedulerEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_TaskScheduler__parentScheduler), "parentScheduler",
            false, true, true, "", false, true, true, true, 0, 1, false, false);
    m_TaskScheduler__parentScheduler->setContainment(false);
    m_TaskScheduler__parentScheduler->setResolveProxies(true);
    m_TaskScheduler__childSchedulers->setEType(m_TaskSchedulerEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_TaskScheduler__childSchedulers), "childSchedulers",
            false, true, true, "", false, true, true, true, 0, -1, true, false);
    m_TaskScheduler__childSchedulers->setContainment(false);
    m_TaskScheduler__childSchedulers->setResolveProxies(true);
    // SchedulerAssociation
    m_SchedulerAssociationEClass->setName("SchedulerAssociation");
    m_SchedulerAssociationEClass->setAbstract(false);
    m_SchedulerAssociationEClass->setInterface(false);
    m_SchedulerAssociation__child->setEType(m_TaskSchedulerEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_SchedulerAssociation__child),
            "child", false, false, false, "", false, false, true, true, 0, 1,
            false, false);
    m_SchedulerAssociation__child->setContainment(false);
    m_SchedulerAssociation__child->setResolveProxies(true);
    m_SchedulerAssociation__child->setEOpposite(
            ::ecore::as < ::ecore::EReference
                    > (m_TaskSchedulerEClass->getEStructuralFeatures()[1]));
    m_SchedulerAssociation__parent->setEType(m_TaskSchedulerEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_SchedulerAssociation__parent), "parent", true, false,
            false, "", false, false, true, true, 0, 1, false, false);
    m_SchedulerAssociation__parent->setContainment(false);
    m_SchedulerAssociation__parent->setResolveProxies(true);
    m_SchedulerAssociation__schedulingParameters->setEType(
            m_SchedulingParametersEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_SchedulerAssociation__schedulingParameters),
            "schedulingParameters", true, false, false, "", false, false, true,
            true, 0, 1, false, false);
    m_SchedulerAssociation__schedulingParameters->setContainment(true);
    m_SchedulerAssociation__schedulingParameters->setResolveProxies(false);
    m_SchedulerAssociation__parameterExtensions->setEType(
            m_ParameterExtensionEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_SchedulerAssociation__parameterExtensions),
            "parameterExtensions", true, false, false, "", false, false, true,
            true, 0, -1, true, false);
    m_SchedulerAssociation__parameterExtensions->setContainment(true);
    m_SchedulerAssociation__parameterExtensions->setResolveProxies(false);
    // InterruptController
    m_InterruptControllerEClass->setName("InterruptController");
    m_InterruptControllerEClass->setAbstract(false);
    m_InterruptControllerEClass->setInterface(false);
    m_InterruptController__schedulingAlgorithm->setEType(
            m_InterruptSchedulingAlgorithmEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_InterruptController__schedulingAlgorithm),
            "schedulingAlgorithm", true, false, false, "", false, false, true,
            true, 0, 1, false, false);
    m_InterruptController__schedulingAlgorithm->setContainment(true);
    m_InterruptController__schedulingAlgorithm->setResolveProxies(false);
    m_InterruptController__isrAllocations->setEType(m_ISRAllocationEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_InterruptController__isrAllocations), "isrAllocations",
            false, true, true, "", false, true, true, true, 0, -1, true, false);
    m_InterruptController__isrAllocations->setContainment(false);
    m_InterruptController__isrAllocations->setResolveProxies(true);
    // SchedulingParameters
    m_SchedulingParametersEClass->setName("SchedulingParameters");
    m_SchedulingParametersEClass->setAbstract(false);
    m_SchedulingParametersEClass->setInterface(false);
    m_SchedulingParameters__priority->setEType(
            dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEIntegerObject());
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute
                    > (m_SchedulingParameters__priority), "priority", true,
            false, false, "", false, false, true, false, 0, 1, false, false);
    m_SchedulingParameters__priority->setID(false);
    m_SchedulingParameters__minBudget->setEType(m_TimeEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_SchedulingParameters__minBudget), "minBudget", true,
            false, false, "", false, false, true, true, 0, 1, false, false);
    m_SchedulingParameters__minBudget->setContainment(true);
    m_SchedulingParameters__minBudget->setResolveProxies(false);
    m_SchedulingParameters__maxBudget->setEType(m_TimeEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_SchedulingParameters__maxBudget), "maxBudget", true,
            false, false, "", false, false, true, true, 0, 1, false, false);
    m_SchedulingParameters__maxBudget->setContainment(true);
    m_SchedulingParameters__maxBudget->setResolveProxies(false);
    m_SchedulingParameters__replenishment->setEType(m_TimeEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_SchedulingParameters__replenishment), "replenishment",
            true, false, false, "", false, false, true, true, 0, 1, false,
            false);
    m_SchedulingParameters__replenishment->setContainment(true);
    m_SchedulingParameters__replenishment->setResolveProxies(false);
    // ParameterExtension
    m_ParameterExtensionEClass->setName("ParameterExtension");
    m_ParameterExtensionEClass->setAbstract(false);
    m_ParameterExtensionEClass->setInterface(false);
    m_ParameterExtension__key->setEType(
            dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEString());
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute > (m_ParameterExtension__key),
            "key", true, false, false, "", false, false, true, false, 1, 1,
            false, true);
    m_ParameterExtension__key->setID(false);
    m_ParameterExtension__value->setEType(
            dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEString());
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute > (m_ParameterExtension__value),
            "value", true, false, false, "", false, false, true, false, 1, 1,
            false, true);
    m_ParameterExtension__value->setID(false);
    // Algorithm
    m_AlgorithmEClass->setName("Algorithm");
    m_AlgorithmEClass->setAbstract(true);
    m_AlgorithmEClass->setInterface(false);
    // InterruptSchedulingAlgorithm
    m_InterruptSchedulingAlgorithmEClass->setName(
            "InterruptSchedulingAlgorithm");
    m_InterruptSchedulingAlgorithmEClass->setAbstract(true);
    m_InterruptSchedulingAlgorithmEClass->setInterface(false);
    // TaskSchedulingAlgorithm
    m_TaskSchedulingAlgorithmEClass->setName("TaskSchedulingAlgorithm");
    m_TaskSchedulingAlgorithmEClass->setAbstract(true);
    m_TaskSchedulingAlgorithmEClass->setInterface(false);
    // FixedPriority
    m_FixedPriorityEClass->setName("FixedPriority");
    m_FixedPriorityEClass->setAbstract(true);
    m_FixedPriorityEClass->setInterface(false);
    // FixedPriorityPreemptive
    m_FixedPriorityPreemptiveEClass->setName("FixedPriorityPreemptive");
    m_FixedPriorityPreemptiveEClass->setAbstract(false);
    m_FixedPriorityPreemptiveEClass->setInterface(false);
    // FixedPriorityPreemptiveWithBudgetEnforcement
    m_FixedPriorityPreemptiveWithBudgetEnforcementEClass->setName(
            "FixedPriorityPreemptiveWithBudgetEnforcement");
    m_FixedPriorityPreemptiveWithBudgetEnforcementEClass->setAbstract(false);
    m_FixedPriorityPreemptiveWithBudgetEnforcementEClass->setInterface(false);
    // OSEK
    m_OSEKEClass->setName("OSEK");
    m_OSEKEClass->setAbstract(false);
    m_OSEKEClass->setInterface(false);
    // DeadlineMonotonic
    m_DeadlineMonotonicEClass->setName("DeadlineMonotonic");
    m_DeadlineMonotonicEClass->setAbstract(false);
    m_DeadlineMonotonicEClass->setInterface(false);
    // RateMonotonic
    m_RateMonotonicEClass->setName("RateMonotonic");
    m_RateMonotonicEClass->setAbstract(false);
    m_RateMonotonicEClass->setInterface(false);
    // Pfair
    m_PfairEClass->setName("Pfair");
    m_PfairEClass->setAbstract(true);
    m_PfairEClass->setInterface(false);
    m_Pfair__quantSizeNs->setEType(
            dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEInt());
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute > (m_Pfair__quantSizeNs),
            "quantSizeNs", true, false, false, "0", false, false, true, false,
            0, 1, false, false);
    m_Pfair__quantSizeNs->setID(false);
    // PfairPD2
    m_PfairPD2EClass->setName("PfairPD2");
    m_PfairPD2EClass->setAbstract(false);
    m_PfairPD2EClass->setInterface(false);
    // PartlyPFairPD2
    m_PartlyPFairPD2EClass->setName("PartlyPFairPD2");
    m_PartlyPFairPD2EClass->setAbstract(false);
    m_PartlyPFairPD2EClass->setInterface(false);
    // EarlyReleaseFairPD2
    m_EarlyReleaseFairPD2EClass->setName("EarlyReleaseFairPD2");
    m_EarlyReleaseFairPD2EClass->setAbstract(false);
    m_EarlyReleaseFairPD2EClass->setInterface(false);
    // PartlyEarlyReleaseFairPD2
    m_PartlyEarlyReleaseFairPD2EClass->setName("PartlyEarlyReleaseFairPD2");
    m_PartlyEarlyReleaseFairPD2EClass->setAbstract(false);
    m_PartlyEarlyReleaseFairPD2EClass->setInterface(false);
    // DynamicPriority
    m_DynamicPriorityEClass->setName("DynamicPriority");
    m_DynamicPriorityEClass->setAbstract(true);
    m_DynamicPriorityEClass->setInterface(false);
    // LeastLocalRemainingExecutionTimeFirst
    m_LeastLocalRemainingExecutionTimeFirstEClass->setName(
            "LeastLocalRemainingExecutionTimeFirst");
    m_LeastLocalRemainingExecutionTimeFirstEClass->setAbstract(false);
    m_LeastLocalRemainingExecutionTimeFirstEClass->setInterface(false);
    // EarliestDeadlineFirst
    m_EarliestDeadlineFirstEClass->setName("EarliestDeadlineFirst");
    m_EarliestDeadlineFirstEClass->setAbstract(false);
    m_EarliestDeadlineFirstEClass->setInterface(false);
    // PriorityBasedRoundRobin
    m_PriorityBasedRoundRobinEClass->setName("PriorityBasedRoundRobin");
    m_PriorityBasedRoundRobinEClass->setAbstract(false);
    m_PriorityBasedRoundRobinEClass->setInterface(false);
    // ReservationBasedServer
    m_ReservationBasedServerEClass->setName("ReservationBasedServer");
    m_ReservationBasedServerEClass->setAbstract(true);
    m_ReservationBasedServerEClass->setInterface(false);
    // DeferrableServer
    m_DeferrableServerEClass->setName("DeferrableServer");
    m_DeferrableServerEClass->setAbstract(false);
    m_DeferrableServerEClass->setInterface(false);
    // PollingPeriodicServer
    m_PollingPeriodicServerEClass->setName("PollingPeriodicServer");
    m_PollingPeriodicServerEClass->setAbstract(false);
    m_PollingPeriodicServerEClass->setInterface(false);
    // SporadicServer
    m_SporadicServerEClass->setName("SporadicServer");
    m_SporadicServerEClass->setAbstract(false);
    m_SporadicServerEClass->setInterface(false);
    // ConstantBandwidthServer
    m_ConstantBandwidthServerEClass->setName("ConstantBandwidthServer");
    m_ConstantBandwidthServerEClass->setAbstract(false);
    m_ConstantBandwidthServerEClass->setInterface(false);
    // ConstantBandwidthServerWithCASH
    m_ConstantBandwidthServerWithCASHEClass->setName(
            "ConstantBandwidthServerWithCASH");
    m_ConstantBandwidthServerWithCASHEClass->setAbstract(false);
    m_ConstantBandwidthServerWithCASHEClass->setInterface(false);
    // Grouping
    m_GroupingEClass->setName("Grouping");
    m_GroupingEClass->setAbstract(false);
    m_GroupingEClass->setInterface(false);
    // UserSpecificSchedulingAlgorithm
    m_UserSpecificSchedulingAlgorithmEClass->setName(
            "UserSpecificSchedulingAlgorithm");
    m_UserSpecificSchedulingAlgorithmEClass->setAbstract(false);
    m_UserSpecificSchedulingAlgorithmEClass->setInterface(false);
    m_UserSpecificSchedulingAlgorithm__parameterExtensions->setEType(
            m_ParameterExtensionEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_UserSpecificSchedulingAlgorithm__parameterExtensions),
            "parameterExtensions", true, false, false, "", false, false, true,
            true, 0, -1, true, false);
    m_UserSpecificSchedulingAlgorithm__parameterExtensions->setContainment(
            true);
    m_UserSpecificSchedulingAlgorithm__parameterExtensions->setResolveProxies(
            false);
    // PriorityBased
    m_PriorityBasedEClass->setName("PriorityBased");
    m_PriorityBasedEClass->setAbstract(false);
    m_PriorityBasedEClass->setInterface(false);
    // OperatingSystem
    m_OperatingSystemEClass->setName("OperatingSystem");
    m_OperatingSystemEClass->setAbstract(false);
    m_OperatingSystemEClass->setInterface(false);
    m_OperatingSystem__overhead->setEType(m_OsOverheadEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_OperatingSystem__overhead),
            "overhead", true, false, false, "", false, false, true, true, 0, 1,
            false, false);
    m_OperatingSystem__overhead->setContainment(false);
    m_OperatingSystem__overhead->setResolveProxies(true);
    m_OperatingSystem__taskSchedulers->setEType(m_TaskSchedulerEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_OperatingSystem__taskSchedulers), "taskSchedulers",
            true, false, false, "", false, false, true, true, 0, -1, true,
            false);
    m_OperatingSystem__taskSchedulers->setContainment(true);
    m_OperatingSystem__taskSchedulers->setResolveProxies(false);
    m_OperatingSystem__interruptControllers->setEType(
            m_InterruptControllerEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_OperatingSystem__interruptControllers),
            "interruptControllers", true, false, false, "", false, false, true,
            true, 0, -1, true, false);
    m_OperatingSystem__interruptControllers->setContainment(true);
    m_OperatingSystem__interruptControllers->setResolveProxies(false);
    m_OperatingSystem__osDataConsistency->setEType(m_OsDataConsistencyEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_OperatingSystem__osDataConsistency),
            "osDataConsistency", true, false, false, "", false, false, true,
            true, 0, 1, false, false);
    m_OperatingSystem__osDataConsistency->setContainment(true);
    m_OperatingSystem__osDataConsistency->setResolveProxies(false);
    // VendorOperatingSystem
    m_VendorOperatingSystemEClass->setName("VendorOperatingSystem");
    m_VendorOperatingSystemEClass->setAbstract(false);
    m_VendorOperatingSystemEClass->setInterface(false);
    m_VendorOperatingSystem__osName->setEType(
            dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEString());
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute
                    > (m_VendorOperatingSystem__osName), "osName", true, false,
            false, "", false, false, true, false, 0, 1, false, false);
    m_VendorOperatingSystem__osName->setID(false);
    m_VendorOperatingSystem__vendor->setEType(
            dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEString());
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute
                    > (m_VendorOperatingSystem__vendor), "vendor", true, false,
            false, "", false, false, true, false, 0, 1, false, false);
    m_VendorOperatingSystem__vendor->setID(false);
    m_VendorOperatingSystem__version->setEType(
            dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEString());
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute
                    > (m_VendorOperatingSystem__version), "version", true,
            false, false, "", false, false, true, false, 0, 1, false, false);
    m_VendorOperatingSystem__version->setID(false);
    // OsOverhead
    m_OsOverheadEClass->setName("OsOverhead");
    m_OsOverheadEClass->setAbstract(false);
    m_OsOverheadEClass->setInterface(false);
    m_OsOverhead__apiOverhead->setEType(m_OsAPIOverheadEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_OsOverhead__apiOverhead),
            "apiOverhead", true, false, false, "", false, false, true, true, 0,
            1, false, false);
    m_OsOverhead__apiOverhead->setContainment(true);
    m_OsOverhead__apiOverhead->setResolveProxies(false);
    m_OsOverhead__isrCategory1Overhead->setEType(m_OsISROverheadEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_OsOverhead__isrCategory1Overhead),
            "isrCategory1Overhead", true, false, false, "", false, false, true,
            true, 0, 1, false, false);
    m_OsOverhead__isrCategory1Overhead->setContainment(true);
    m_OsOverhead__isrCategory1Overhead->setResolveProxies(false);
    m_OsOverhead__isrCategory2Overhead->setEType(m_OsISROverheadEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_OsOverhead__isrCategory2Overhead),
            "isrCategory2Overhead", true, false, false, "", false, false, true,
            true, 0, 1, false, false);
    m_OsOverhead__isrCategory2Overhead->setContainment(true);
    m_OsOverhead__isrCategory2Overhead->setResolveProxies(false);
    // OsAPIOverhead
    m_OsAPIOverheadEClass->setName("OsAPIOverhead");
    m_OsAPIOverheadEClass->setAbstract(false);
    m_OsAPIOverheadEClass->setInterface(false);
    m_OsAPIOverhead__apiSendMessage->setEType(m_TicksEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_OsAPIOverhead__apiSendMessage), "apiSendMessage", true,
            false, false, "", false, false, true, true, 0, 1, false, false);
    m_OsAPIOverhead__apiSendMessage->setContainment(true);
    m_OsAPIOverhead__apiSendMessage->setResolveProxies(false);
    m_OsAPIOverhead__apiTerminateTask->setEType(m_TicksEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_OsAPIOverhead__apiTerminateTask), "apiTerminateTask",
            true, false, false, "", false, false, true, true, 0, 1, false,
            false);
    m_OsAPIOverhead__apiTerminateTask->setContainment(true);
    m_OsAPIOverhead__apiTerminateTask->setResolveProxies(false);
    m_OsAPIOverhead__apiSchedule->setEType(m_TicksEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_OsAPIOverhead__apiSchedule),
            "apiSchedule", true, false, false, "", false, false, true, true, 0,
            1, false, false);
    m_OsAPIOverhead__apiSchedule->setContainment(true);
    m_OsAPIOverhead__apiSchedule->setResolveProxies(false);
    m_OsAPIOverhead__apiRequestResource->setEType(m_TicksEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_OsAPIOverhead__apiRequestResource),
            "apiRequestResource", true, false, false, "", false, false, true,
            true, 0, 1, false, false);
    m_OsAPIOverhead__apiRequestResource->setContainment(true);
    m_OsAPIOverhead__apiRequestResource->setResolveProxies(false);
    m_OsAPIOverhead__apiReleaseResource->setEType(m_TicksEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_OsAPIOverhead__apiReleaseResource),
            "apiReleaseResource", true, false, false, "", false, false, true,
            true, 0, 1, false, false);
    m_OsAPIOverhead__apiReleaseResource->setContainment(true);
    m_OsAPIOverhead__apiReleaseResource->setResolveProxies(false);
    m_OsAPIOverhead__apiSetEvent->setEType(m_TicksEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_OsAPIOverhead__apiSetEvent),
            "apiSetEvent", true, false, false, "", false, false, true, true, 0,
            1, false, false);
    m_OsAPIOverhead__apiSetEvent->setContainment(true);
    m_OsAPIOverhead__apiSetEvent->setResolveProxies(false);
    m_OsAPIOverhead__apiWaitEvent->setEType(m_TicksEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_OsAPIOverhead__apiWaitEvent),
            "apiWaitEvent", true, false, false, "", false, false, true, true, 0,
            1, false, false);
    m_OsAPIOverhead__apiWaitEvent->setContainment(true);
    m_OsAPIOverhead__apiWaitEvent->setResolveProxies(false);
    m_OsAPIOverhead__apiClearEvent->setEType(m_TicksEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_OsAPIOverhead__apiClearEvent), "apiClearEvent", true,
            false, false, "", false, false, true, true, 0, 1, false, false);
    m_OsAPIOverhead__apiClearEvent->setContainment(true);
    m_OsAPIOverhead__apiClearEvent->setResolveProxies(false);
    m_OsAPIOverhead__apiActivateTask->setEType(m_TicksEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_OsAPIOverhead__apiActivateTask), "apiActivateTask",
            true, false, false, "", false, false, true, true, 0, 1, false,
            false);
    m_OsAPIOverhead__apiActivateTask->setContainment(true);
    m_OsAPIOverhead__apiActivateTask->setResolveProxies(false);
    m_OsAPIOverhead__apiEnforcedMigration->setEType(m_TicksEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_OsAPIOverhead__apiEnforcedMigration),
            "apiEnforcedMigration", true, false, false, "", false, false, true,
            true, 0, 1, false, false);
    m_OsAPIOverhead__apiEnforcedMigration->setContainment(true);
    m_OsAPIOverhead__apiEnforcedMigration->setResolveProxies(false);
    m_OsAPIOverhead__apiSuspendOsInterrupts->setEType(m_TicksEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_OsAPIOverhead__apiSuspendOsInterrupts),
            "apiSuspendOsInterrupts", true, false, false, "", false, false,
            true, true, 0, 1, false, false);
    m_OsAPIOverhead__apiSuspendOsInterrupts->setContainment(true);
    m_OsAPIOverhead__apiSuspendOsInterrupts->setResolveProxies(false);
    m_OsAPIOverhead__apiResumeOsInterrupts->setEType(m_TicksEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_OsAPIOverhead__apiResumeOsInterrupts),
            "apiResumeOsInterrupts", true, false, false, "", false, false, true,
            true, 0, 1, false, false);
    m_OsAPIOverhead__apiResumeOsInterrupts->setContainment(true);
    m_OsAPIOverhead__apiResumeOsInterrupts->setResolveProxies(false);
    m_OsAPIOverhead__apiRequestSpinlock->setEType(m_TicksEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_OsAPIOverhead__apiRequestSpinlock),
            "apiRequestSpinlock", true, false, false, "", false, false, true,
            true, 0, 1, false, false);
    m_OsAPIOverhead__apiRequestSpinlock->setContainment(true);
    m_OsAPIOverhead__apiRequestSpinlock->setResolveProxies(false);
    m_OsAPIOverhead__apiReleaseSpinlock->setEType(m_TicksEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_OsAPIOverhead__apiReleaseSpinlock),
            "apiReleaseSpinlock", true, false, false, "", false, false, true,
            true, 0, 1, false, false);
    m_OsAPIOverhead__apiReleaseSpinlock->setContainment(true);
    m_OsAPIOverhead__apiReleaseSpinlock->setResolveProxies(false);
    m_OsAPIOverhead__apiSenderReceiverRead->setEType(m_TicksEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_OsAPIOverhead__apiSenderReceiverRead),
            "apiSenderReceiverRead", true, false, false, "", false, false, true,
            true, 0, 1, false, false);
    m_OsAPIOverhead__apiSenderReceiverRead->setContainment(true);
    m_OsAPIOverhead__apiSenderReceiverRead->setResolveProxies(false);
    m_OsAPIOverhead__apiSenderReceiverWrite->setEType(m_TicksEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_OsAPIOverhead__apiSenderReceiverWrite),
            "apiSenderReceiverWrite", true, false, false, "", false, false,
            true, true, 0, 1, false, false);
    m_OsAPIOverhead__apiSenderReceiverWrite->setContainment(true);
    m_OsAPIOverhead__apiSenderReceiverWrite->setResolveProxies(false);
    m_OsAPIOverhead__apiSynchronousServerCallPoint->setEType(m_TicksEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_OsAPIOverhead__apiSynchronousServerCallPoint),
            "apiSynchronousServerCallPoint", true, false, false, "", false,
            false, true, true, 0, 1, false, false);
    m_OsAPIOverhead__apiSynchronousServerCallPoint->setContainment(true);
    m_OsAPIOverhead__apiSynchronousServerCallPoint->setResolveProxies(false);
    m_OsAPIOverhead__apiIocRead->setEType(m_TicksEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_OsAPIOverhead__apiIocRead),
            "apiIocRead", true, false, false, "", false, false, true, true, 0,
            1, false, false);
    m_OsAPIOverhead__apiIocRead->setContainment(true);
    m_OsAPIOverhead__apiIocRead->setResolveProxies(false);
    m_OsAPIOverhead__apiIocWrite->setEType(m_TicksEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_OsAPIOverhead__apiIocWrite),
            "apiIocWrite", true, false, false, "", false, false, true, true, 0,
            1, false, false);
    m_OsAPIOverhead__apiIocWrite->setContainment(true);
    m_OsAPIOverhead__apiIocWrite->setResolveProxies(false);
    // OsISROverhead
    m_OsISROverheadEClass->setName("OsISROverhead");
    m_OsISROverheadEClass->setAbstract(false);
    m_OsISROverheadEClass->setInterface(false);
    m_OsISROverhead__preExecutionOverhead->setEType(m_TicksEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_OsISROverhead__preExecutionOverhead),
            "preExecutionOverhead", true, false, false, "", false, false, true,
            true, 0, 1, false, false);
    m_OsISROverhead__preExecutionOverhead->setContainment(true);
    m_OsISROverhead__preExecutionOverhead->setResolveProxies(false);
    m_OsISROverhead__postExecutionOverhead->setEType(m_TicksEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_OsISROverhead__postExecutionOverhead),
            "postExecutionOverhead", true, false, false, "", false, false, true,
            true, 0, 1, false, false);
    m_OsISROverhead__postExecutionOverhead->setContainment(true);
    m_OsISROverhead__postExecutionOverhead->setResolveProxies(false);
    // PropertyConstraintsModel
    m_PropertyConstraintsModelEClass->setName("PropertyConstraintsModel");
    m_PropertyConstraintsModelEClass->setAbstract(false);
    m_PropertyConstraintsModelEClass->setInterface(false);
    m_PropertyConstraintsModel__allocationConstraints->setEType(
            m_CoreAllocationConstraintEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_PropertyConstraintsModel__allocationConstraints),
            "allocationConstraints", true, false, false, "", false, false, true,
            true, 0, -1, true, false);
    m_PropertyConstraintsModel__allocationConstraints->setContainment(true);
    m_PropertyConstraintsModel__allocationConstraints->setResolveProxies(false);
    m_PropertyConstraintsModel__mappingConstraints->setEType(
            m_MemoryMappingConstraintEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_PropertyConstraintsModel__mappingConstraints),
            "mappingConstraints", true, false, false, "", false, false, true,
            true, 0, -1, true, false);
    m_PropertyConstraintsModel__mappingConstraints->setContainment(true);
    m_PropertyConstraintsModel__mappingConstraints->setResolveProxies(false);
    // CoreAllocationConstraint
    m_CoreAllocationConstraintEClass->setName("CoreAllocationConstraint");
    m_CoreAllocationConstraintEClass->setAbstract(true);
    m_CoreAllocationConstraintEClass->setInterface(false);
    m_CoreAllocationConstraint__coreClassification->setEType(
            m_CoreClassificationEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_CoreAllocationConstraint__coreClassification),
            "coreClassification", true, false, false, "", false, false, true,
            true, 0, 1, false, false);
    m_CoreAllocationConstraint__coreClassification->setContainment(true);
    m_CoreAllocationConstraint__coreClassification->setResolveProxies(false);
    // MemoryMappingConstraint
    m_MemoryMappingConstraintEClass->setName("MemoryMappingConstraint");
    m_MemoryMappingConstraintEClass->setAbstract(true);
    m_MemoryMappingConstraintEClass->setInterface(false);
    m_MemoryMappingConstraint__memoryClassification->setEType(
            m_MemoryClassificationEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_MemoryMappingConstraint__memoryClassification),
            "memoryClassification", true, false, false, "", false, false, true,
            true, 0, 1, false, false);
    m_MemoryMappingConstraint__memoryClassification->setContainment(true);
    m_MemoryMappingConstraint__memoryClassification->setResolveProxies(false);
    // ProcessAllocationConstraint
    m_ProcessAllocationConstraintEClass->setName("ProcessAllocationConstraint");
    m_ProcessAllocationConstraintEClass->setAbstract(false);
    m_ProcessAllocationConstraintEClass->setInterface(false);
    m_ProcessAllocationConstraint__process->setEType(m_ProcessEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_ProcessAllocationConstraint__process), "process", true,
            false, false, "", false, false, true, true, 0, 1, false, false);
    m_ProcessAllocationConstraint__process->setContainment(false);
    m_ProcessAllocationConstraint__process->setResolveProxies(true);
    // ProcessPrototypeAllocationConstraint
    m_ProcessPrototypeAllocationConstraintEClass->setName(
            "ProcessPrototypeAllocationConstraint");
    m_ProcessPrototypeAllocationConstraintEClass->setAbstract(false);
    m_ProcessPrototypeAllocationConstraintEClass->setInterface(false);
    m_ProcessPrototypeAllocationConstraint__processPrototype->setEType(
            m_ProcessPrototypeEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_ProcessPrototypeAllocationConstraint__processPrototype),
            "processPrototype", true, false, false, "", false, false, true,
            true, 0, 1, false, false);
    m_ProcessPrototypeAllocationConstraint__processPrototype->setContainment(
            false);
    m_ProcessPrototypeAllocationConstraint__processPrototype->setResolveProxies(
            true);
    // RunnableAllocationConstraint
    m_RunnableAllocationConstraintEClass->setName(
            "RunnableAllocationConstraint");
    m_RunnableAllocationConstraintEClass->setAbstract(false);
    m_RunnableAllocationConstraintEClass->setInterface(false);
    m_RunnableAllocationConstraint__runnable->setEType(m_RunnableEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_RunnableAllocationConstraint__runnable), "runnable",
            true, false, false, "", false, false, true, true, 0, 1, false,
            false);
    m_RunnableAllocationConstraint__runnable->setContainment(false);
    m_RunnableAllocationConstraint__runnable->setResolveProxies(true);
    // AbstractElementMappingConstraint
    m_AbstractElementMappingConstraintEClass->setName(
            "AbstractElementMappingConstraint");
    m_AbstractElementMappingConstraintEClass->setAbstract(false);
    m_AbstractElementMappingConstraintEClass->setInterface(false);
    m_AbstractElementMappingConstraint__abstractElement->setEType(
            m_AbstractMemoryElementEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_AbstractElementMappingConstraint__abstractElement),
            "abstractElement", true, false, false, "", false, false, true, true,
            0, 1, false, false);
    m_AbstractElementMappingConstraint__abstractElement->setContainment(false);
    m_AbstractElementMappingConstraint__abstractElement->setResolveProxies(
            true);
    // Classification
    m_ClassificationEClass->setName("Classification");
    m_ClassificationEClass->setAbstract(true);
    m_ClassificationEClass->setInterface(false);
    m_Classification__condition->setEType(m_ConditionEEnum);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute > (m_Classification__condition),
            "condition", true, false, false, "", false, false, true, false, 0,
            1, false, false);
    m_Classification__condition->setID(false);
    m_Classification__grouping->setEType(m_GroupingTypeEEnum);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute > (m_Classification__grouping),
            "grouping", true, false, false, "", false, false, true, false, 0, 1,
            false, false);
    m_Classification__grouping->setID(false);
    // CoreClassification
    m_CoreClassificationEClass->setName("CoreClassification");
    m_CoreClassificationEClass->setAbstract(false);
    m_CoreClassificationEClass->setInterface(false);
    m_CoreClassification__classifiers->setEType(m_CoreClassifierEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_CoreClassification__classifiers), "classifiers", true,
            false, false, "", false, false, true, true, 0, -1, true, false);
    m_CoreClassification__classifiers->setContainment(false);
    m_CoreClassification__classifiers->setResolveProxies(true);
    // MemoryClassification
    m_MemoryClassificationEClass->setName("MemoryClassification");
    m_MemoryClassificationEClass->setAbstract(false);
    m_MemoryClassificationEClass->setInterface(false);
    m_MemoryClassification__classifiers->setEType(m_MemoryClassifierEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_MemoryClassification__classifiers), "classifiers",
            true, false, false, "", false, false, true, true, 0, -1, true,
            false);
    m_MemoryClassification__classifiers->setContainment(false);
    m_MemoryClassification__classifiers->setResolveProxies(true);
    // StimuliModel
    m_StimuliModelEClass->setName("StimuliModel");
    m_StimuliModelEClass->setAbstract(false);
    m_StimuliModelEClass->setInterface(false);
    m_StimuliModel__stimuli->setEType(m_StimulusEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_StimuliModel__stimuli),
            "stimuli", true, false, false, "", false, false, true, true, 0, -1,
            true, false);
    m_StimuliModel__stimuli->setContainment(true);
    m_StimuliModel__stimuli->setResolveProxies(false);
    m_StimuliModel__clocks->setEType(m_ClockEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_StimuliModel__clocks),
            "clocks", true, false, false, "", false, false, true, true, 0, -1,
            true, false);
    m_StimuliModel__clocks->setContainment(true);
    m_StimuliModel__clocks->setResolveProxies(false);
    // Stimulus
    m_StimulusEClass->setName("Stimulus");
    m_StimulusEClass->setAbstract(true);
    m_StimulusEClass->setInterface(false);
    m_Stimulus__setModeValueList->setEType(m_ModeValueListEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_Stimulus__setModeValueList),
            "setModeValueList", true, false, false, "", false, false, true,
            true, 0, 1, false, false);
    m_Stimulus__setModeValueList->setContainment(true);
    m_Stimulus__setModeValueList->setResolveProxies(false);
    m_Stimulus__executionCondition->setEType(m_ModeConditionDisjunctionEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_Stimulus__executionCondition), "executionCondition",
            true, false, false, "", false, false, true, true, 0, 1, false,
            false);
    m_Stimulus__executionCondition->setContainment(true);
    m_Stimulus__executionCondition->setResolveProxies(false);
    m_Stimulus__affectedProcesses->setEType(m_ProcessEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_Stimulus__affectedProcesses),
            "affectedProcesses", false, true, true, "", false, true, true, true,
            0, -1, true, false);
    m_Stimulus__affectedProcesses->setContainment(false);
    m_Stimulus__affectedProcesses->setResolveProxies(true);
    // ModeValueList
    m_ModeValueListEClass->setName("ModeValueList");
    m_ModeValueListEClass->setAbstract(false);
    m_ModeValueListEClass->setInterface(false);
    m_ModeValueList__entries->setEType(m_ModeAssignmentEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_ModeValueList__entries),
            "entries", true, false, false, "", false, false, true, true, 0, -1,
            true, false);
    m_ModeValueList__entries->setContainment(true);
    m_ModeValueList__entries->setResolveProxies(false);
    // ModeValueMapEntry
    m_ModeValueMapEntryEClass->setName("ModeValueMapEntry");
    m_ModeValueMapEntryEClass->setAbstract(false);
    m_ModeValueMapEntryEClass->setInterface(false);
    m_ModeValueMapEntry__value->setEType(
            dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEString());
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute > (m_ModeValueMapEntry__value),
            "value", true, false, false, "", false, false, true, false, 1, 1,
            false, true);
    m_ModeValueMapEntry__value->setID(false);
    m_ModeValueMapEntry__key->setEType(m_ModeLabelEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_ModeValueMapEntry__key),
            "key", true, false, false, "", false, false, true, true, 1, 1,
            false, true);
    m_ModeValueMapEntry__key->setContainment(false);
    m_ModeValueMapEntry__key->setResolveProxies(true);
    // ModeValue
    m_ModeValueEClass->setName("ModeValue");
    m_ModeValueEClass->setAbstract(true);
    m_ModeValueEClass->setInterface(false);
    m_ModeValue__value->setEType(
            dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEString());
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute > (m_ModeValue__value), "value",
            true, false, false, "", false, false, true, false, 1, 1, false,
            true);
    m_ModeValue__value->setID(false);
    m_ModeValue__label->setEType(m_ModeLabelEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_ModeValue__label), "label",
            true, false, false, "", false, false, true, true, 1, 1, false,
            true);
    m_ModeValue__label->setContainment(false);
    m_ModeValue__label->setResolveProxies(true);
    {
        ::ecore::EOperation_ptr _op = addEOperation(m_ModeValueEClass, nullptr,
                "validateInvariants", 0, 1, false, true);
        _op->setEType(
                dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEBoolean());
        {
            ::ecore::EParameter_ptr _pa = addEParameter(_op, "diagnostics", 0,
                    1, false, true);
            _pa->setEType(
                    dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEDiagnosticChain());
        }
        {
            ::ecore::EParameter_ptr _pa = addEParameter(_op, "context", 0, 1,
                    false, true);
            _pa->setEType(
                    dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEMap());
            {
                ::ecore::EGenericType_ptr _g0 = ::ecore::Ptr
                        < ::ecore::EGenericType > (new ::ecore::EGenericType);
                _g0->setEClassifier(
                        dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEMap());
                ::ecore::EGenericType_ptr _g1 = ::ecore::Ptr
                        < ::ecore::EGenericType > (new ::ecore::EGenericType);
                _g1->setEClassifier(
                        dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEJavaObject());
                _g0->getETypeArguments().push_back(_g1);
                ::ecore::EGenericType_ptr _g2 = ::ecore::Ptr
                        < ::ecore::EGenericType > (new ::ecore::EGenericType);
                _g2->setEClassifier(
                        dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEJavaObject());
                _g0->getETypeArguments().push_back(_g2);
                _pa->setEGenericType(_g0);
            }
        }
    }
    {
        ::ecore::EOperation_ptr _op = addEOperation(m_ModeValueEClass, nullptr,
                "getLiteral", 0, 1, false, true);
        _op->setEType(m_ModeLiteralEClass);
    }
    {
        ::ecore::EOperation_ptr _op = addEOperation(m_ModeValueEClass, nullptr,
                "getInteger", 0, 1, false, true);
        _op->setEType(
                dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEIntegerObject());
    }
    // ModeAssignment
    m_ModeAssignmentEClass->setName("ModeAssignment");
    m_ModeAssignmentEClass->setAbstract(false);
    m_ModeAssignmentEClass->setInterface(false);
    // ModeConditionDisjunction
    m_ModeConditionDisjunctionEClass->setName("ModeConditionDisjunction");
    m_ModeConditionDisjunctionEClass->setAbstract(false);
    m_ModeConditionDisjunctionEClass->setInterface(false);
    m_ModeConditionDisjunction__entries->setEType(
            m_ModeConditionDisjunctionEntryEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_ModeConditionDisjunction__entries), "entries", true,
            false, false, "", false, false, true, true, 1, -1, true, true);
    m_ModeConditionDisjunction__entries->setContainment(true);
    m_ModeConditionDisjunction__entries->setResolveProxies(false);
    {
        ::ecore::EOperation_ptr _op = addEOperation(
                m_ModeConditionDisjunctionEClass, nullptr, "isSatisfiedBy", 0,
                1, false, true);
        _op->setEType(
                dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEBoolean());
        {
            ::ecore::EParameter_ptr _pa = addEParameter(_op, "context", 0, -1,
                    false, true);
            _pa->setEType(m_ModeValueMapEntryEClass);
        }
    }
    // ModeConditionDisjunctionEntry
    m_ModeConditionDisjunctionEntryEClass->setName(
            "ModeConditionDisjunctionEntry");
    m_ModeConditionDisjunctionEntryEClass->setAbstract(true);
    m_ModeConditionDisjunctionEntryEClass->setInterface(true);
    {
        ::ecore::EOperation_ptr _op = addEOperation(
                m_ModeConditionDisjunctionEntryEClass, nullptr, "isSatisfiedBy",
                0, 1, false, true);
        _op->setEType(
                dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEBoolean());
        {
            ::ecore::EParameter_ptr _pa = addEParameter(_op, "assignment", 0,
                    -1, false, true);
            _pa->setEType(m_ModeValueMapEntryEClass);
        }
    }
    // ModeCondition
    m_ModeConditionEClass->setName("ModeCondition");
    m_ModeConditionEClass->setAbstract(true);
    m_ModeConditionEClass->setInterface(true);
    m_ModeCondition__relation->setEType(m_RelationalOperatorEEnum);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute > (m_ModeCondition__relation),
            "relation", true, false, false, "", false, false, true, false, 0, 1,
            false, false);
    m_ModeCondition__relation->setID(false);
    {
        ::ecore::EOperation_ptr _op = addEOperation(m_ModeConditionEClass,
                nullptr, "isSatisfiedBy", 0, 1, false, true);
        _op->setEType(
                dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEBoolean());
        {
            ::ecore::EParameter_ptr _pa = addEParameter(_op, "context", 0, -1,
                    false, true);
            _pa->setEType(m_ModeValueMapEntryEClass);
        }
    }
    // ModeValueCondition
    m_ModeValueConditionEClass->setName("ModeValueCondition");
    m_ModeValueConditionEClass->setAbstract(false);
    m_ModeValueConditionEClass->setInterface(false);
    {
        ::ecore::EOperation_ptr _op = addEOperation(m_ModeValueConditionEClass,
                nullptr, "isSatisfiedBy", 0, 1, false, true);
        _op->setEType(
                dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEBoolean());
        {
            ::ecore::EParameter_ptr _pa = addEParameter(_op, "context", 0, -1,
                    false, true);
            _pa->setEType(m_ModeValueMapEntryEClass);
        }
    }
    // ModeLabelCondition
    m_ModeLabelConditionEClass->setName("ModeLabelCondition");
    m_ModeLabelConditionEClass->setAbstract(false);
    m_ModeLabelConditionEClass->setInterface(false);
    m_ModeLabelCondition__label1->setEType(m_ModeLabelEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_ModeLabelCondition__label1),
            "label1", true, false, false, "", false, false, true, true, 1, 1,
            false, true);
    m_ModeLabelCondition__label1->setContainment(false);
    m_ModeLabelCondition__label1->setResolveProxies(true);
    m_ModeLabelCondition__label2->setEType(m_ModeLabelEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_ModeLabelCondition__label2),
            "label2", true, false, false, "", false, false, true, true, 1, 1,
            false, true);
    m_ModeLabelCondition__label2->setContainment(false);
    m_ModeLabelCondition__label2->setResolveProxies(true);
    {
        ::ecore::EOperation_ptr _op = addEOperation(m_ModeLabelConditionEClass,
                nullptr, "isSatisfiedBy", 0, 1, false, true);
        _op->setEType(
                dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEBoolean());
        {
            ::ecore::EParameter_ptr _pa = addEParameter(_op, "context", 0, -1,
                    false, true);
            _pa->setEType(m_ModeValueMapEntryEClass);
        }
    }
    // ModeConditionConjunction
    m_ModeConditionConjunctionEClass->setName("ModeConditionConjunction");
    m_ModeConditionConjunctionEClass->setAbstract(false);
    m_ModeConditionConjunctionEClass->setInterface(false);
    m_ModeConditionConjunction__entries->setEType(m_ModeConditionEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_ModeConditionConjunction__entries), "entries", true,
            false, false, "", false, false, true, true, 1, -1, true, true);
    m_ModeConditionConjunction__entries->setContainment(true);
    m_ModeConditionConjunction__entries->setResolveProxies(false);
    {
        ::ecore::EOperation_ptr _op = addEOperation(
                m_ModeConditionConjunctionEClass, nullptr, "isSatisfiedBy", 0,
                1, false, true);
        _op->setEType(
                dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEBoolean());
        {
            ::ecore::EParameter_ptr _pa = addEParameter(_op, "context", 0, -1,
                    false, true);
            _pa->setEType(m_ModeValueMapEntryEClass);
        }
    }
    // FixedPeriodic
    m_FixedPeriodicEClass->setName("FixedPeriodic");
    m_FixedPeriodicEClass->setAbstract(true);
    m_FixedPeriodicEClass->setInterface(true);
    m_FixedPeriodic__recurrence->setEType(m_TimeEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_FixedPeriodic__recurrence),
            "recurrence", true, false, false, "", false, false, true, true, 1,
            1, false, true);
    m_FixedPeriodic__recurrence->setContainment(true);
    m_FixedPeriodic__recurrence->setResolveProxies(false);
    m_FixedPeriodic__offset->setEType(m_TimeEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_FixedPeriodic__offset),
            "offset", true, false, false, "", false, false, true, true, 0, 1,
            false, false);
    m_FixedPeriodic__offset->setContainment(true);
    m_FixedPeriodic__offset->setResolveProxies(false);
    // PeriodicStimulus
    m_PeriodicStimulusEClass->setName("PeriodicStimulus");
    m_PeriodicStimulusEClass->setAbstract(false);
    m_PeriodicStimulusEClass->setInterface(false);
    m_PeriodicStimulus__jitter->setEType(m_ITimeDeviationEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_PeriodicStimulus__jitter),
            "jitter", true, false, false, "", false, false, true, true, 0, 1,
            false, false);
    m_PeriodicStimulus__jitter->setContainment(true);
    m_PeriodicStimulus__jitter->setResolveProxies(false);
    m_PeriodicStimulus__minDistance->setEType(m_TimeEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_PeriodicStimulus__minDistance), "minDistance", true,
            false, false, "", false, false, true, true, 0, 1, false, false);
    m_PeriodicStimulus__minDistance->setContainment(true);
    m_PeriodicStimulus__minDistance->setResolveProxies(false);
    // RelativePeriodicStimulus
    m_RelativePeriodicStimulusEClass->setName("RelativePeriodicStimulus");
    m_RelativePeriodicStimulusEClass->setAbstract(false);
    m_RelativePeriodicStimulusEClass->setInterface(false);
    m_RelativePeriodicStimulus__offset->setEType(m_TimeEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_RelativePeriodicStimulus__offset), "offset", true,
            false, false, "", false, false, true, true, 0, 1, false, false);
    m_RelativePeriodicStimulus__offset->setContainment(true);
    m_RelativePeriodicStimulus__offset->setResolveProxies(false);
    m_RelativePeriodicStimulus__nextOccurrence->setEType(
            m_ITimeDeviationEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_RelativePeriodicStimulus__nextOccurrence),
            "nextOccurrence", true, false, false, "", false, false, true, true,
            1, 1, false, true);
    m_RelativePeriodicStimulus__nextOccurrence->setContainment(true);
    m_RelativePeriodicStimulus__nextOccurrence->setResolveProxies(false);
    // VariableRateStimulus
    m_VariableRateStimulusEClass->setName("VariableRateStimulus");
    m_VariableRateStimulusEClass->setAbstract(false);
    m_VariableRateStimulusEClass->setInterface(false);
    m_VariableRateStimulus__maxIncreasePerStep->setEType(
            dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEDoubleObject());
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute
                    > (m_VariableRateStimulus__maxIncreasePerStep),
            "maxIncreasePerStep", true, false, false, "", false, false, true,
            false, 0, 1, false, false);
    m_VariableRateStimulus__maxIncreasePerStep->setID(false);
    m_VariableRateStimulus__maxDecreasePerStep->setEType(
            dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEDoubleObject());
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute
                    > (m_VariableRateStimulus__maxDecreasePerStep),
            "maxDecreasePerStep", true, false, false, "", false, false, true,
            false, 0, 1, false, false);
    m_VariableRateStimulus__maxDecreasePerStep->setID(false);
    m_VariableRateStimulus__step->setEType(m_TimeEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_VariableRateStimulus__step),
            "step", true, false, false, "", false, false, true, true, 1, 1,
            false, true);
    m_VariableRateStimulus__step->setContainment(true);
    m_VariableRateStimulus__step->setResolveProxies(false);
    m_VariableRateStimulus__occurrencesPerStep->setEType(
            m_IContinuousValueDeviationEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_VariableRateStimulus__occurrencesPerStep),
            "occurrencesPerStep", true, false, false, "", false, false, true,
            true, 1, 1, false, true);
    m_VariableRateStimulus__occurrencesPerStep->setContainment(true);
    m_VariableRateStimulus__occurrencesPerStep->setResolveProxies(false);
    m_VariableRateStimulus__scenario->setEType(m_ScenarioEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_VariableRateStimulus__scenario), "scenario", true,
            false, false, "", false, false, true, true, 0, 1, false, false);
    m_VariableRateStimulus__scenario->setContainment(true);
    m_VariableRateStimulus__scenario->setResolveProxies(false);
    // Scenario
    m_ScenarioEClass->setName("Scenario");
    m_ScenarioEClass->setAbstract(false);
    m_ScenarioEClass->setInterface(false);
    m_Scenario__samplingOffset->setEType(m_NonNegativeDoubleEDataType);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute > (m_Scenario__samplingOffset),
            "samplingOffset", true, false, false, "0.0", false, false, true,
            false, 0, 1, false, false);
    m_Scenario__samplingOffset->setID(false);
    m_Scenario__samplingRecurrence->setEType(m_NonNegativeDoubleEDataType);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute
                    > (m_Scenario__samplingRecurrence), "samplingRecurrence",
            true, false, false, "1.0", false, false, true, false, 0, 1, false,
            false);
    m_Scenario__samplingRecurrence->setID(false);
    m_Scenario__clock->setEType(m_ClockEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_Scenario__clock), "clock",
            true, false, false, "", false, false, true, true, 1, 1, false,
            true);
    m_Scenario__clock->setContainment(false);
    m_Scenario__clock->setResolveProxies(true);
    // PeriodicSyntheticStimulus
    m_PeriodicSyntheticStimulusEClass->setName("PeriodicSyntheticStimulus");
    m_PeriodicSyntheticStimulusEClass->setAbstract(false);
    m_PeriodicSyntheticStimulusEClass->setInterface(false);
    m_PeriodicSyntheticStimulus__occurrenceTimes->setEType(m_TimeEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_PeriodicSyntheticStimulus__occurrenceTimes),
            "occurrenceTimes", true, false, false, "", false, false, true, true,
            1, -1, true, true);
    m_PeriodicSyntheticStimulus__occurrenceTimes->setContainment(true);
    m_PeriodicSyntheticStimulus__occurrenceTimes->setResolveProxies(false);
    // CustomStimulus
    m_CustomStimulusEClass->setName("CustomStimulus");
    m_CustomStimulusEClass->setAbstract(false);
    m_CustomStimulusEClass->setInterface(false);
    // SingleStimulus
    m_SingleStimulusEClass->setName("SingleStimulus");
    m_SingleStimulusEClass->setAbstract(false);
    m_SingleStimulusEClass->setInterface(false);
    m_SingleStimulus__occurrence->setEType(m_TimeEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_SingleStimulus__occurrence),
            "occurrence", true, false, false, "", false, false, true, true, 1,
            1, false, true);
    m_SingleStimulus__occurrence->setContainment(true);
    m_SingleStimulus__occurrence->setResolveProxies(false);
    // InterProcessStimulus
    m_InterProcessStimulusEClass->setName("InterProcessStimulus");
    m_InterProcessStimulusEClass->setAbstract(false);
    m_InterProcessStimulusEClass->setInterface(false);
    m_InterProcessStimulus__counter->setEType(m_CounterEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_InterProcessStimulus__counter), "counter", true, false,
            false, "", false, false, true, true, 0, 1, false, false);
    m_InterProcessStimulus__counter->setContainment(true);
    m_InterProcessStimulus__counter->setResolveProxies(false);
    m_InterProcessStimulus__explicitTriggers->setEType(
            m_InterProcessTriggerEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_InterProcessStimulus__explicitTriggers),
            "explicitTriggers", false, true, true, "", false, true, true, true,
            0, -1, true, false);
    m_InterProcessStimulus__explicitTriggers->setContainment(false);
    m_InterProcessStimulus__explicitTriggers->setResolveProxies(true);
    // PeriodicBurstStimulus
    m_PeriodicBurstStimulusEClass->setName("PeriodicBurstStimulus");
    m_PeriodicBurstStimulusEClass->setAbstract(false);
    m_PeriodicBurstStimulusEClass->setInterface(false);
    m_PeriodicBurstStimulus__occurrenceCount->setEType(
            dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEInt());
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute
                    > (m_PeriodicBurstStimulus__occurrenceCount),
            "occurrenceCount", true, false, false, "0", false, false, true,
            false, 0, 1, false, false);
    m_PeriodicBurstStimulus__occurrenceCount->setID(false);
    m_PeriodicBurstStimulus__burstLength->setEType(m_TimeEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_PeriodicBurstStimulus__burstLength), "burstLength",
            true, false, false, "", false, false, true, true, 1, 1, false,
            true);
    m_PeriodicBurstStimulus__burstLength->setContainment(true);
    m_PeriodicBurstStimulus__burstLength->setResolveProxies(false);
    m_PeriodicBurstStimulus__occurrenceMinDistance->setEType(m_TimeEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_PeriodicBurstStimulus__occurrenceMinDistance),
            "occurrenceMinDistance", true, false, false, "", false, false, true,
            true, 0, 1, false, false);
    m_PeriodicBurstStimulus__occurrenceMinDistance->setContainment(true);
    m_PeriodicBurstStimulus__occurrenceMinDistance->setResolveProxies(false);
    // EventStimulus
    m_EventStimulusEClass->setName("EventStimulus");
    m_EventStimulusEClass->setAbstract(false);
    m_EventStimulusEClass->setInterface(false);
    m_EventStimulus__triggeringEvents->setEType(m_TriggerEventEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_EventStimulus__triggeringEvents), "triggeringEvents",
            true, false, false, "", false, false, true, true, 1, -1, true,
            true);
    m_EventStimulus__triggeringEvents->setContainment(false);
    m_EventStimulus__triggeringEvents->setResolveProxies(true);
    m_EventStimulus__counter->setEType(m_CounterEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_EventStimulus__counter),
            "counter", true, false, false, "", false, false, true, true, 0, 1,
            false, false);
    m_EventStimulus__counter->setContainment(true);
    m_EventStimulus__counter->setResolveProxies(false);
    // ArrivalCurveStimulus
    m_ArrivalCurveStimulusEClass->setName("ArrivalCurveStimulus");
    m_ArrivalCurveStimulusEClass->setAbstract(false);
    m_ArrivalCurveStimulusEClass->setInterface(false);
    m_ArrivalCurveStimulus__entries->setEType(m_ArrivalCurveEntryEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_ArrivalCurveStimulus__entries), "entries", true, false,
            false, "", false, false, true, true, 1, -1, true, true);
    m_ArrivalCurveStimulus__entries->setContainment(true);
    m_ArrivalCurveStimulus__entries->setResolveProxies(false);
    // ArrivalCurveEntry
    m_ArrivalCurveEntryEClass->setName("ArrivalCurveEntry");
    m_ArrivalCurveEntryEClass->setAbstract(false);
    m_ArrivalCurveEntryEClass->setInterface(false);
    m_ArrivalCurveEntry__numberOfOccurrences->setEType(
            dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEInt());
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute
                    > (m_ArrivalCurveEntry__numberOfOccurrences),
            "numberOfOccurrences", true, false, false, "0", false, false, true,
            false, 0, 1, false, false);
    m_ArrivalCurveEntry__numberOfOccurrences->setID(false);
    m_ArrivalCurveEntry__lowerTimeBorder->setEType(m_TimeEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_ArrivalCurveEntry__lowerTimeBorder), "lowerTimeBorder",
            true, false, false, "", false, false, true, true, 0, 1, false,
            false);
    m_ArrivalCurveEntry__lowerTimeBorder->setContainment(true);
    m_ArrivalCurveEntry__lowerTimeBorder->setResolveProxies(false);
    m_ArrivalCurveEntry__upperTimeBorder->setEType(m_TimeEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_ArrivalCurveEntry__upperTimeBorder), "upperTimeBorder",
            true, false, false, "", false, false, true, true, 0, 1, false,
            false);
    m_ArrivalCurveEntry__upperTimeBorder->setContainment(true);
    m_ArrivalCurveEntry__upperTimeBorder->setResolveProxies(false);
    // Clock
    m_ClockEClass->setName("Clock");
    m_ClockEClass->setAbstract(true);
    m_ClockEClass->setInterface(false);
    // ClockFunction
    m_ClockFunctionEClass->setName("ClockFunction");
    m_ClockFunctionEClass->setAbstract(false);
    m_ClockFunctionEClass->setInterface(false);
    m_ClockFunction__curveType->setEType(m_CurveTypeEEnum);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute > (m_ClockFunction__curveType),
            "curveType", true, false, false, "", false, false, true, false, 0,
            1, false, false);
    m_ClockFunction__curveType->setID(false);
    m_ClockFunction__period->setEType(m_TimeEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_ClockFunction__period),
            "period", true, false, false, "", false, false, true, true, 1, 1,
            false, true);
    m_ClockFunction__period->setContainment(true);
    m_ClockFunction__period->setResolveProxies(false);
    m_ClockFunction__peakToPeak->setEType(m_FrequencyEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_ClockFunction__peakToPeak),
            "peakToPeak", true, false, false, "", false, false, true, true, 1,
            1, false, true);
    m_ClockFunction__peakToPeak->setContainment(true);
    m_ClockFunction__peakToPeak->setResolveProxies(false);
    m_ClockFunction__xOffset->setEType(m_TimeEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_ClockFunction__xOffset),
            "xOffset", true, false, false, "", false, false, true, true, 0, 1,
            false, false);
    m_ClockFunction__xOffset->setContainment(true);
    m_ClockFunction__xOffset->setResolveProxies(false);
    m_ClockFunction__yOffset->setEType(m_FrequencyEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_ClockFunction__yOffset),
            "yOffset", true, false, false, "", false, false, true, true, 0, 1,
            false, false);
    m_ClockFunction__yOffset->setContainment(true);
    m_ClockFunction__yOffset->setResolveProxies(false);
    // ClockStepList
    m_ClockStepListEClass->setName("ClockStepList");
    m_ClockStepListEClass->setAbstract(false);
    m_ClockStepListEClass->setInterface(false);
    m_ClockStepList__entries->setEType(m_ClockStepEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_ClockStepList__entries),
            "entries", true, false, false, "", false, false, true, true, 1, -1,
            true, true);
    m_ClockStepList__entries->setContainment(true);
    m_ClockStepList__entries->setResolveProxies(false);
    m_ClockStepList__period->setEType(m_TimeEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_ClockStepList__period),
            "period", true, false, false, "", false, false, true, true, 0, 1,
            false, false);
    m_ClockStepList__period->setContainment(true);
    m_ClockStepList__period->setResolveProxies(false);
    // ClockStep
    m_ClockStepEClass->setName("ClockStep");
    m_ClockStepEClass->setAbstract(false);
    m_ClockStepEClass->setInterface(false);
    m_ClockStep__frequency->setEType(m_FrequencyEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_ClockStep__frequency),
            "frequency", true, false, false, "", false, false, true, true, 1, 1,
            false, true);
    m_ClockStep__frequency->setContainment(true);
    m_ClockStep__frequency->setResolveProxies(false);
    m_ClockStep__time->setEType(m_TimeEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_ClockStep__time), "time",
            true, false, false, "", false, false, true, true, 1, 1, false,
            true);
    m_ClockStep__time->setContainment(true);
    m_ClockStep__time->setResolveProxies(false);
    // SWModel
    m_SWModelEClass->setName("SWModel");
    m_SWModelEClass->setAbstract(false);
    m_SWModelEClass->setInterface(false);
    m_SWModel__isrs->setEType(m_ISREClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_SWModel__isrs), "isrs", true,
            false, false, "", false, false, true, true, 0, -1, true, false);
    m_SWModel__isrs->setContainment(true);
    m_SWModel__isrs->setResolveProxies(false);
    m_SWModel__tasks->setEType(m_TaskEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_SWModel__tasks), "tasks",
            true, false, false, "", false, false, true, true, 0, -1, true,
            false);
    m_SWModel__tasks->setContainment(true);
    m_SWModel__tasks->setResolveProxies(false);
    m_SWModel__runnables->setEType(m_RunnableEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_SWModel__runnables),
            "runnables", true, false, false, "", false, false, true, true, 0,
            -1, true, false);
    m_SWModel__runnables->setContainment(true);
    m_SWModel__runnables->setResolveProxies(false);
    m_SWModel__labels->setEType(m_LabelEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_SWModel__labels), "labels",
            true, false, false, "", false, false, true, true, 0, -1, true,
            false);
    m_SWModel__labels->setContainment(true);
    m_SWModel__labels->setResolveProxies(false);
    m_SWModel__channels->setEType(m_ChannelEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_SWModel__channels),
            "channels", true, false, false, "", false, false, true, true, 0, -1,
            true, false);
    m_SWModel__channels->setContainment(true);
    m_SWModel__channels->setResolveProxies(false);
    m_SWModel__processPrototypes->setEType(m_ProcessPrototypeEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_SWModel__processPrototypes),
            "processPrototypes", true, false, false, "", false, false, true,
            true, 0, -1, true, false);
    m_SWModel__processPrototypes->setContainment(true);
    m_SWModel__processPrototypes->setResolveProxies(false);
    m_SWModel__sections->setEType(m_SectionEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_SWModel__sections),
            "sections", true, false, false, "", false, false, true, true, 0, -1,
            true, false);
    m_SWModel__sections->setContainment(true);
    m_SWModel__sections->setResolveProxies(false);
    m_SWModel__activations->setEType(m_ActivationEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_SWModel__activations),
            "activations", true, false, false, "", false, false, true, true, 0,
            -1, true, false);
    m_SWModel__activations->setContainment(true);
    m_SWModel__activations->setResolveProxies(false);
    m_SWModel__events->setEType(m_OsEventEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_SWModel__events), "events",
            true, false, false, "", false, false, true, true, 0, -1, true,
            false);
    m_SWModel__events->setContainment(true);
    m_SWModel__events->setResolveProxies(false);
    m_SWModel__typeDefinitions->setEType(m_TypeDefinitionEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_SWModel__typeDefinitions),
            "typeDefinitions", true, false, false, "", false, false, true, true,
            0, -1, true, false);
    m_SWModel__typeDefinitions->setContainment(true);
    m_SWModel__typeDefinitions->setResolveProxies(false);
    m_SWModel__customEntities->setEType(m_CustomEntityEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_SWModel__customEntities),
            "customEntities", true, false, false, "", false, false, true, true,
            0, -1, true, false);
    m_SWModel__customEntities->setContainment(true);
    m_SWModel__customEntities->setResolveProxies(false);
    m_SWModel__processChains->setEType(m_ProcessChainEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_SWModel__processChains),
            "processChains", true, false, false, "", false, false, true, true,
            0, -1, true, false);
    m_SWModel__processChains->setContainment(true);
    m_SWModel__processChains->setResolveProxies(false);
    m_SWModel__modes->setEType(m_ModeEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_SWModel__modes), "modes",
            true, false, false, "", false, false, true, true, 0, -1, true,
            false);
    m_SWModel__modes->setContainment(true);
    m_SWModel__modes->setResolveProxies(false);
    m_SWModel__modeLabels->setEType(m_ModeLabelEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_SWModel__modeLabels),
            "modeLabels", true, false, false, "", false, false, true, true, 0,
            -1, true, false);
    m_SWModel__modeLabels->setContainment(true);
    m_SWModel__modeLabels->setResolveProxies(false);
    {
        ::ecore::EOperation_ptr _op = addEOperation(m_SWModelEClass, nullptr,
                "modeLiteral", 0, 1, false, true);
        _op->setEType(m_ModeLiteralEClass);
        {
            ::ecore::EParameter_ptr _pa = addEParameter(_op, "mode", 0, 1,
                    false, true);
            _pa->setEType(
                    dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEString());
        }
        {
            ::ecore::EParameter_ptr _pa = addEParameter(_op, "literal", 0, 1,
                    false, true);
            _pa->setEType(
                    dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEString());
        }
    }
    // AbstractMemoryElement
    m_AbstractMemoryElementEClass->setName("AbstractMemoryElement");
    m_AbstractMemoryElementEClass->setAbstract(true);
    m_AbstractMemoryElementEClass->setInterface(false);
    m_AbstractMemoryElement__size->setEType(m_DataSizeEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_AbstractMemoryElement__size),
            "size", true, false, false, "", false, false, true, true, 0, 1,
            false, false);
    m_AbstractMemoryElement__size->setContainment(true);
    m_AbstractMemoryElement__size->setResolveProxies(false);
    m_AbstractMemoryElement__mappings->setEType(m_MemoryMappingEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_AbstractMemoryElement__mappings), "mappings", false,
            true, true, "", false, true, true, true, 0, -1, true, false);
    m_AbstractMemoryElement__mappings->setContainment(false);
    m_AbstractMemoryElement__mappings->setResolveProxies(true);
    // AbstractProcess
    m_AbstractProcessEClass->setName("AbstractProcess");
    m_AbstractProcessEClass->setAbstract(true);
    m_AbstractProcessEClass->setInterface(false);
    m_AbstractProcess__referringComponents->setEType(m_ComponentEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_AbstractProcess__referringComponents),
            "referringComponents", false, true, true, "", false, true, true,
            true, 0, -1, true, false);
    m_AbstractProcess__referringComponents->setContainment(false);
    m_AbstractProcess__referringComponents->setResolveProxies(true);
    // CustomEntity
    m_CustomEntityEClass->setName("CustomEntity");
    m_CustomEntityEClass->setAbstract(false);
    m_CustomEntityEClass->setInterface(false);
    m_CustomEntity__typeName->setEType(
            dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEString());
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute > (m_CustomEntity__typeName),
            "typeName", true, false, false, "", false, false, true, false, 0, 1,
            false, false);
    m_CustomEntity__typeName->setID(false);
    // ProcessChain
    m_ProcessChainEClass->setName("ProcessChain");
    m_ProcessChainEClass->setAbstract(false);
    m_ProcessChainEClass->setInterface(false);
    m_ProcessChain__processes->setEType(m_ProcessEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_ProcessChain__processes),
            "processes", true, false, false, "", false, false, true, true, 0,
            -1, true, false);
    m_ProcessChain__processes->setContainment(false);
    m_ProcessChain__processes->setResolveProxies(true);
    // Process
    m_ProcessEClass->setName("Process");
    m_ProcessEClass->setAbstract(true);
    m_ProcessEClass->setInterface(false);
    m_Process__activityGraph->setEType(m_ActivityGraphEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_Process__activityGraph),
            "activityGraph", true, false, false, "", false, false, true, true,
            0, 1, false, false);
    m_Process__activityGraph->setContainment(true);
    m_Process__activityGraph->setResolveProxies(false);
    m_Process__stimuli->setEType(m_StimulusEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_Process__stimuli), "stimuli",
            true, false, false, "", false, false, true, true, 0, -1, true,
            false);
    m_Process__stimuli->setContainment(false);
    m_Process__stimuli->setResolveProxies(true);
    // IActivityGraphItemContainer
    m_IActivityGraphItemContainerEClass->setName("IActivityGraphItemContainer");
    m_IActivityGraphItemContainerEClass->setAbstract(true);
    m_IActivityGraphItemContainerEClass->setInterface(true);
    m_IActivityGraphItemContainer__items->setEType(m_ActivityGraphItemEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_IActivityGraphItemContainer__items), "items", true,
            false, false, "", false, false, true, true, 0, -1, true, false);
    m_IActivityGraphItemContainer__items->setContainment(true);
    m_IActivityGraphItemContainer__items->setResolveProxies(false);
    // ActivityGraph
    m_ActivityGraphEClass->setName("ActivityGraph");
    m_ActivityGraphEClass->setAbstract(false);
    m_ActivityGraphEClass->setInterface(false);
    // ActivityGraphItem
    m_ActivityGraphItemEClass->setName("ActivityGraphItem");
    m_ActivityGraphItemEClass->setAbstract(true);
    m_ActivityGraphItemEClass->setInterface(false);
    m_ActivityGraphItem__containingProcess->setEType(m_ProcessEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_ActivityGraphItem__containingProcess),
            "containingProcess", false, true, true, "", false, true, true, true,
            0, 1, false, false);
    m_ActivityGraphItem__containingProcess->setContainment(false);
    m_ActivityGraphItem__containingProcess->setResolveProxies(false);
    m_ActivityGraphItem__containingRunnable->setEType(m_RunnableEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_ActivityGraphItem__containingRunnable),
            "containingRunnable", false, true, true, "", false, true, true,
            true, 0, 1, false, false);
    m_ActivityGraphItem__containingRunnable->setContainment(false);
    m_ActivityGraphItem__containingRunnable->setResolveProxies(false);
    m_ActivityGraphItem__containingActivityGraph->setEType(
            m_ActivityGraphEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_ActivityGraphItem__containingActivityGraph),
            "containingActivityGraph", false, true, true, "", false, true, true,
            true, 0, 1, false, false);
    m_ActivityGraphItem__containingActivityGraph->setContainment(false);
    m_ActivityGraphItem__containingActivityGraph->setResolveProxies(false);
    // ModeSwitch
    m_ModeSwitchEClass->setName("ModeSwitch");
    m_ModeSwitchEClass->setAbstract(false);
    m_ModeSwitchEClass->setInterface(false);
    m_ModeSwitch__entries->setEType(m_ModeSwitchEntryEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_ModeSwitch__entries),
            "entries", true, false, false, "", false, false, true, true, 0, -1,
            true, false);
    m_ModeSwitch__entries->setContainment(true);
    m_ModeSwitch__entries->setResolveProxies(false);
    m_ModeSwitch__defaultEntry->setEType(m_ModeSwitchDefaultEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_ModeSwitch__defaultEntry),
            "defaultEntry", true, false, false, "", false, false, true, true, 0,
            1, false, false);
    m_ModeSwitch__defaultEntry->setContainment(true);
    m_ModeSwitch__defaultEntry->setResolveProxies(false);
    // ModeSwitchEntry
    m_ModeSwitchEntryEClass->setName("ModeSwitchEntry");
    m_ModeSwitchEntryEClass->setAbstract(false);
    m_ModeSwitchEntryEClass->setInterface(false);
    m_ModeSwitchEntry__condition->setEType(m_ModeConditionDisjunctionEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_ModeSwitchEntry__condition),
            "condition", true, false, false, "", false, false, true, true, 1, 1,
            false, true);
    m_ModeSwitchEntry__condition->setContainment(true);
    m_ModeSwitchEntry__condition->setResolveProxies(false);
    // ModeSwitchDefault
    m_ModeSwitchDefaultEClass->setName("ModeSwitchDefault");
    m_ModeSwitchDefaultEClass->setAbstract(false);
    m_ModeSwitchDefaultEClass->setInterface(false);
    // ProbabilitySwitch
    m_ProbabilitySwitchEClass->setName("ProbabilitySwitch");
    m_ProbabilitySwitchEClass->setAbstract(false);
    m_ProbabilitySwitchEClass->setInterface(false);
    m_ProbabilitySwitch__entries->setEType(m_ProbabilitySwitchEntryEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_ProbabilitySwitch__entries),
            "entries", true, false, false, "", false, false, true, true, 0, -1,
            true, false);
    m_ProbabilitySwitch__entries->setContainment(true);
    m_ProbabilitySwitch__entries->setResolveProxies(false);
    // ProbabilitySwitchEntry
    m_ProbabilitySwitchEntryEClass->setName("ProbabilitySwitchEntry");
    m_ProbabilitySwitchEntryEClass->setAbstract(false);
    m_ProbabilitySwitchEntryEClass->setInterface(false);
    m_ProbabilitySwitchEntry__probability->setEType(
            dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEDouble());
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute
                    > (m_ProbabilitySwitchEntry__probability), "probability",
            true, false, false, "0.0", false, false, true, false, 0, 1, false,
            false);
    m_ProbabilitySwitchEntry__probability->setID(false);
    // Counter
    m_CounterEClass->setName("Counter");
    m_CounterEClass->setAbstract(false);
    m_CounterEClass->setInterface(false);
    m_Counter__prescaler->setEType(m_PositiveLongEDataType);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute > (m_Counter__prescaler),
            "prescaler", true, false, false, "1", false, false, true, false, 0,
            1, false, false);
    m_Counter__prescaler->setID(false);
    m_Counter__offset->setEType(m_NonNegativeLongEDataType);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute > (m_Counter__offset), "offset",
            true, false, false, "0", false, false, true, false, 0, 1, false,
            false);
    m_Counter__offset->setID(false);
    // WaitEvent
    m_WaitEventEClass->setName("WaitEvent");
    m_WaitEventEClass->setAbstract(false);
    m_WaitEventEClass->setInterface(false);
    m_WaitEvent__maskType->setEType(m_WaitEventTypeEEnum);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute > (m_WaitEvent__maskType),
            "maskType", true, false, false, "", false, false, true, false, 0, 1,
            false, false);
    m_WaitEvent__maskType->setID(false);
    m_WaitEvent__waitingBehaviour->setEType(m_WaitingBehaviourEEnum);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute > (m_WaitEvent__waitingBehaviour),
            "waitingBehaviour", true, false, false, "", false, false, true,
            false, 0, 1, false, false);
    m_WaitEvent__waitingBehaviour->setID(false);
    m_WaitEvent__eventMask->setEType(m_EventMaskEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_WaitEvent__eventMask),
            "eventMask", true, false, false, "", false, false, true, true, 0, 1,
            false, false);
    m_WaitEvent__eventMask->setContainment(true);
    m_WaitEvent__eventMask->setResolveProxies(false);
    m_WaitEvent__counter->setEType(m_CounterEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_WaitEvent__counter),
            "counter", true, false, false, "", false, false, true, true, 0, 1,
            false, false);
    m_WaitEvent__counter->setContainment(true);
    m_WaitEvent__counter->setResolveProxies(false);
    // SetEvent
    m_SetEventEClass->setName("SetEvent");
    m_SetEventEClass->setAbstract(false);
    m_SetEventEClass->setInterface(false);
    m_SetEvent__eventMask->setEType(m_EventMaskEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_SetEvent__eventMask),
            "eventMask", true, false, false, "", false, false, true, true, 0, 1,
            false, false);
    m_SetEvent__eventMask->setContainment(true);
    m_SetEvent__eventMask->setResolveProxies(false);
    m_SetEvent__process->setEType(m_ProcessEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_SetEvent__process),
            "process", true, false, false, "", false, false, true, true, 0, 1,
            false, false);
    m_SetEvent__process->setContainment(false);
    m_SetEvent__process->setResolveProxies(true);
    m_SetEvent__counter->setEType(m_CounterEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_SetEvent__counter),
            "counter", true, false, false, "", false, false, true, true, 0, 1,
            false, false);
    m_SetEvent__counter->setContainment(true);
    m_SetEvent__counter->setResolveProxies(false);
    // ClearEvent
    m_ClearEventEClass->setName("ClearEvent");
    m_ClearEventEClass->setAbstract(false);
    m_ClearEventEClass->setInterface(false);
    m_ClearEvent__eventMask->setEType(m_EventMaskEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_ClearEvent__eventMask),
            "eventMask", true, false, false, "", false, false, true, true, 0, 1,
            false, false);
    m_ClearEvent__eventMask->setContainment(true);
    m_ClearEvent__eventMask->setResolveProxies(false);
    m_ClearEvent__counter->setEType(m_CounterEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_ClearEvent__counter),
            "counter", true, false, false, "", false, false, true, true, 0, 1,
            false, false);
    m_ClearEvent__counter->setContainment(true);
    m_ClearEvent__counter->setResolveProxies(false);
    // EventMask
    m_EventMaskEClass->setName("EventMask");
    m_EventMaskEClass->setAbstract(false);
    m_EventMaskEClass->setInterface(false);
    m_EventMask__events->setEType(m_OsEventEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_EventMask__events), "events",
            true, false, false, "", false, false, true, true, 0, -1, true,
            false);
    m_EventMask__events->setContainment(false);
    m_EventMask__events->setResolveProxies(true);
    // OsEvent
    m_OsEventEClass->setName("OsEvent");
    m_OsEventEClass->setAbstract(false);
    m_OsEventEClass->setInterface(false);
    m_OsEvent__communicationOverheadInBit->setEType(
            dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEInt());
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute
                    > (m_OsEvent__communicationOverheadInBit),
            "communicationOverheadInBit", true, false, false, "0", false, false,
            true, false, 0, 1, false, false);
    m_OsEvent__communicationOverheadInBit->setID(false);
    m_OsEvent__referringComponents->setEType(m_ComponentEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_OsEvent__referringComponents), "referringComponents",
            false, true, true, "", false, true, true, true, 0, -1, true, false);
    m_OsEvent__referringComponents->setContainment(false);
    m_OsEvent__referringComponents->setResolveProxies(true);
    // InterProcessTrigger
    m_InterProcessTriggerEClass->setName("InterProcessTrigger");
    m_InterProcessTriggerEClass->setAbstract(false);
    m_InterProcessTriggerEClass->setInterface(false);
    m_InterProcessTrigger__stimulus->setEType(m_InterProcessStimulusEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_InterProcessTrigger__stimulus), "stimulus", true,
            false, false, "", false, false, true, true, 1, 1, false, true);
    m_InterProcessTrigger__stimulus->setContainment(false);
    m_InterProcessTrigger__stimulus->setResolveProxies(true);
    m_InterProcessTrigger__counter->setEType(m_CounterEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_InterProcessTrigger__counter), "counter", true, false,
            false, "", false, false, true, true, 0, 1, false, false);
    m_InterProcessTrigger__counter->setContainment(true);
    m_InterProcessTrigger__counter->setResolveProxies(false);
    // EnforcedMigration
    m_EnforcedMigrationEClass->setName("EnforcedMigration");
    m_EnforcedMigrationEClass->setAbstract(false);
    m_EnforcedMigrationEClass->setInterface(false);
    m_EnforcedMigration__resourceOwner->setEType(m_TaskSchedulerEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_EnforcedMigration__resourceOwner), "resourceOwner",
            true, false, false, "", false, false, true, true, 1, 1, false,
            true);
    m_EnforcedMigration__resourceOwner->setContainment(false);
    m_EnforcedMigration__resourceOwner->setResolveProxies(true);
    // SchedulePoint
    m_SchedulePointEClass->setName("SchedulePoint");
    m_SchedulePointEClass->setAbstract(false);
    m_SchedulePointEClass->setInterface(false);
    // TerminateProcess
    m_TerminateProcessEClass->setName("TerminateProcess");
    m_TerminateProcessEClass->setAbstract(false);
    m_TerminateProcessEClass->setInterface(false);
    m_TerminateProcess__counter->setEType(m_CounterEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_TerminateProcess__counter),
            "counter", true, false, false, "", false, false, true, true, 0, 1,
            false, false);
    m_TerminateProcess__counter->setContainment(true);
    m_TerminateProcess__counter->setResolveProxies(false);
    // Task
    m_TaskEClass->setName("Task");
    m_TaskEClass->setAbstract(false);
    m_TaskEClass->setInterface(false);
    m_Task__preemption->setEType(m_PreemptionEEnum);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute > (m_Task__preemption),
            "preemption", true, false, false, "", false, false, true, false, 0,
            1, false, false);
    m_Task__preemption->setID(false);
    m_Task__multipleTaskActivationLimit->setEType(
            dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEInt());
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute
                    > (m_Task__multipleTaskActivationLimit),
            "multipleTaskActivationLimit", true, false, false, "0", false,
            false, true, false, 0, 1, false, false);
    m_Task__multipleTaskActivationLimit->setID(false);
    // ISR
    m_ISREClass->setName("ISR");
    m_ISREClass->setAbstract(false);
    m_ISREClass->setInterface(false);
    m_ISR__category->setEType(m_ISRCategoryEEnum);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute > (m_ISR__category), "category",
            true, false, false, "", false, false, true, false, 0, 1, false,
            false);
    m_ISR__category->setID(false);
    // ProcessPrototype
    m_ProcessPrototypeEClass->setName("ProcessPrototype");
    m_ProcessPrototypeEClass->setAbstract(false);
    m_ProcessPrototypeEClass->setInterface(false);
    m_ProcessPrototype__preemption->setEType(m_PreemptionEEnum);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute
                    > (m_ProcessPrototype__preemption), "preemption", true,
            false, false, "", false, false, true, false, 0, 1, false, false);
    m_ProcessPrototype__preemption->setID(false);
    m_ProcessPrototype__firstRunnable->setEType(m_RunnableEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_ProcessPrototype__firstRunnable), "firstRunnable",
            true, false, false, "", false, false, true, true, 0, 1, false,
            false);
    m_ProcessPrototype__firstRunnable->setContainment(false);
    m_ProcessPrototype__firstRunnable->setResolveProxies(true);
    m_ProcessPrototype__lastRunnable->setEType(m_RunnableEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_ProcessPrototype__lastRunnable), "lastRunnable", true,
            false, false, "", false, false, true, true, 0, 1, false, false);
    m_ProcessPrototype__lastRunnable->setContainment(false);
    m_ProcessPrototype__lastRunnable->setResolveProxies(true);
    m_ProcessPrototype__accessPrecedenceSpec->setEType(
            m_AccessPrecedenceSpecEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_ProcessPrototype__accessPrecedenceSpec),
            "accessPrecedenceSpec", true, false, false, "", false, false, true,
            true, 0, -1, true, false);
    m_ProcessPrototype__accessPrecedenceSpec->setContainment(true);
    m_ProcessPrototype__accessPrecedenceSpec->setResolveProxies(false);
    m_ProcessPrototype__orderPrecedenceSpec->setEType(
            m_OrderPrecedenceSpecEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_ProcessPrototype__orderPrecedenceSpec),
            "orderPrecedenceSpec", true, false, false, "", false, false, true,
            true, 0, -1, true, false);
    m_ProcessPrototype__orderPrecedenceSpec->setContainment(true);
    m_ProcessPrototype__orderPrecedenceSpec->setResolveProxies(false);
    m_ProcessPrototype__chainedPrototypes->setEType(
            m_ChainedProcessPrototypeEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_ProcessPrototype__chainedPrototypes),
            "chainedPrototypes", true, false, false, "", false, false, true,
            true, 0, -1, true, false);
    m_ProcessPrototype__chainedPrototypes->setContainment(true);
    m_ProcessPrototype__chainedPrototypes->setResolveProxies(false);
    m_ProcessPrototype__activation->setEType(m_ActivationEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_ProcessPrototype__activation), "activation", true,
            false, false, "", false, false, true, true, 0, 1, false, false);
    m_ProcessPrototype__activation->setContainment(false);
    m_ProcessPrototype__activation->setResolveProxies(true);
    m_ProcessPrototype__runnableCalls->setEType(m_RunnableCallEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_ProcessPrototype__runnableCalls), "runnableCalls",
            true, false, false, "", false, false, true, true, 0, -1, true,
            false);
    m_ProcessPrototype__runnableCalls->setContainment(true);
    m_ProcessPrototype__runnableCalls->setResolveProxies(false);
    // ChainedProcessPrototype
    m_ChainedProcessPrototypeEClass->setName("ChainedProcessPrototype");
    m_ChainedProcessPrototypeEClass->setAbstract(false);
    m_ChainedProcessPrototypeEClass->setInterface(false);
    m_ChainedProcessPrototype__apply->setEType(
            dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEInt());
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute
                    > (m_ChainedProcessPrototype__apply), "apply", true, false,
            false, "0", false, false, true, false, 0, 1, false, false);
    m_ChainedProcessPrototype__apply->setID(false);
    m_ChainedProcessPrototype__offset->setEType(
            dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEInt());
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute
                    > (m_ChainedProcessPrototype__offset), "offset", true,
            false, false, "0", false, false, true, false, 0, 1, false, false);
    m_ChainedProcessPrototype__offset->setID(false);
    m_ChainedProcessPrototype__prototype->setEType(m_ProcessPrototypeEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_ChainedProcessPrototype__prototype), "prototype", true,
            false, false, "", false, false, true, true, 1, 1, false, true);
    m_ChainedProcessPrototype__prototype->setContainment(false);
    m_ChainedProcessPrototype__prototype->setResolveProxies(true);
    // GeneralPrecedence
    m_GeneralPrecedenceEClass->setName("GeneralPrecedence");
    m_GeneralPrecedenceEClass->setAbstract(true);
    m_GeneralPrecedenceEClass->setInterface(false);
    m_GeneralPrecedence__origin->setEType(m_RunnableEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_GeneralPrecedence__origin),
            "origin", true, false, false, "", false, false, true, true, 0, 1,
            false, false);
    m_GeneralPrecedence__origin->setContainment(false);
    m_GeneralPrecedence__origin->setResolveProxies(true);
    m_GeneralPrecedence__target->setEType(m_RunnableEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_GeneralPrecedence__target),
            "target", true, false, false, "", false, false, true, true, 0, 1,
            false, false);
    m_GeneralPrecedence__target->setContainment(false);
    m_GeneralPrecedence__target->setResolveProxies(true);
    // AccessPrecedenceSpec
    m_AccessPrecedenceSpecEClass->setName("AccessPrecedenceSpec");
    m_AccessPrecedenceSpecEClass->setAbstract(false);
    m_AccessPrecedenceSpecEClass->setInterface(false);
    m_AccessPrecedenceSpec__orderType->setEType(m_AccessPrecedenceTypeEEnum);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute
                    > (m_AccessPrecedenceSpec__orderType), "orderType", true,
            false, false, "", false, false, true, false, 0, 1, false, false);
    m_AccessPrecedenceSpec__orderType->setID(false);
    m_AccessPrecedenceSpec__label->setEType(m_LabelEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_AccessPrecedenceSpec__label),
            "label", true, false, false, "", false, false, true, true, 1, 1,
            false, true);
    m_AccessPrecedenceSpec__label->setContainment(false);
    m_AccessPrecedenceSpec__label->setResolveProxies(true);
    // OrderPrecedenceSpec
    m_OrderPrecedenceSpecEClass->setName("OrderPrecedenceSpec");
    m_OrderPrecedenceSpecEClass->setAbstract(false);
    m_OrderPrecedenceSpecEClass->setInterface(false);
    m_OrderPrecedenceSpec__orderType->setEType(m_OrderTypeEEnum);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute
                    > (m_OrderPrecedenceSpec__orderType), "orderType", true,
            false, false, "", false, false, true, false, 0, 1, false, false);
    m_OrderPrecedenceSpec__orderType->setID(false);
    // IDependsOn
    m_IDependsOnEClass->setName("IDependsOn");
    m_IDependsOnEClass->setAbstract(true);
    m_IDependsOnEClass->setInterface(true);
    m_IDependsOn__dependsOn->setEType(m_DataDependencyEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_IDependsOn__dependsOn),
            "dependsOn", true, false, false, "", false, false, true, true, 0, 1,
            false, false);
    m_IDependsOn__dependsOn->setContainment(true);
    m_IDependsOn__dependsOn->setResolveProxies(false);
    // DataDependency
    m_DataDependencyEClass->setName("DataDependency");
    m_DataDependencyEClass->setAbstract(false);
    m_DataDependencyEClass->setInterface(false);
    m_DataDependency__labels->setEType(m_LabelEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_DataDependency__labels),
            "labels", true, false, false, "", false, false, true, true, 0, -1,
            true, false);
    m_DataDependency__labels->setContainment(false);
    m_DataDependency__labels->setResolveProxies(true);
    m_DataDependency__parameters->setEType(m_RunnableParameterEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_DataDependency__parameters),
            "parameters", true, false, false, "", false, false, true, true, 0,
            -1, true, false);
    m_DataDependency__parameters->setContainment(false);
    m_DataDependency__parameters->setResolveProxies(true);
    m_DataDependency__callArguments->setEType(m_CallArgumentEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_DataDependency__callArguments), "callArguments", true,
            false, false, "", false, false, true, true, 0, -1, true, false);
    m_DataDependency__callArguments->setContainment(false);
    m_DataDependency__callArguments->setResolveProxies(true);
    m_DataDependency__containingRunnable->setEType(m_RunnableEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_DataDependency__containingRunnable),
            "containingRunnable", false, true, true, "", false, true, true,
            true, 0, 1, false, false);
    m_DataDependency__containingRunnable->setContainment(false);
    m_DataDependency__containingRunnable->setResolveProxies(false);
    // RunnableParameter
    m_RunnableParameterEClass->setName("RunnableParameter");
    m_RunnableParameterEClass->setAbstract(false);
    m_RunnableParameterEClass->setInterface(false);
    m_RunnableParameter__direction->setEType(m_DirectionTypeEEnum);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute
                    > (m_RunnableParameter__direction), "direction", true,
            false, false, "", false, false, true, false, 0, 1, false, false);
    m_RunnableParameter__direction->setID(false);
    m_RunnableParameter__containingRunnable->setEType(m_RunnableEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_RunnableParameter__containingRunnable),
            "containingRunnable", false, false, false, "", false, false, true,
            true, 0, 1, false, false);
    m_RunnableParameter__containingRunnable->setContainment(false);
    m_RunnableParameter__containingRunnable->setResolveProxies(true);
    m_RunnableParameter__containingRunnable->setEOpposite(
            ::ecore::as < ::ecore::EReference
                    > (m_RunnableEClass->getEStructuralFeatures()[4]));
    m_RunnableParameter__dataType->setEType(m_TypeDefinitionEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_RunnableParameter__dataType),
            "dataType", true, false, false, "", false, false, true, true, 0, 1,
            false, false);
    m_RunnableParameter__dataType->setContainment(false);
    m_RunnableParameter__dataType->setResolveProxies(true);
    {
        ::ecore::EOperation_ptr _op = addEOperation(m_RunnableParameterEClass,
                nullptr, "getNamePrefixSegments", 0, -1, false, true);
        _op->setEType(
                dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEString());
    }
    {
        ::ecore::EOperation_ptr _op = addEOperation(m_RunnableParameterEClass,
                nullptr, "toString", 0, 1, false, true);
        _op->setEType(
                dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEString());
    }
    // Runnable
    m_RunnableEClass->setName("Runnable");
    m_RunnableEClass->setAbstract(false);
    m_RunnableEClass->setInterface(false);
    m_Runnable__callback->setEType(
            dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEBoolean());
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute > (m_Runnable__callback),
            "callback", true, false, false, "false", false, false, true, false,
            0, 1, false, false);
    m_Runnable__callback->setID(false);
    m_Runnable__service->setEType(
            dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEBoolean());
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute > (m_Runnable__service),
            "service", true, false, false, "false", false, false, true, false,
            0, 1, false, false);
    m_Runnable__service->setID(false);
    m_Runnable__asilLevel->setEType(m_ASILTypeEEnum);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute > (m_Runnable__asilLevel),
            "asilLevel", true, false, false, "", false, false, true, false, 0,
            1, false, false);
    m_Runnable__asilLevel->setID(false);
    m_Runnable__executionCondition->setEType(m_ModeConditionDisjunctionEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_Runnable__executionCondition), "executionCondition",
            true, false, false, "", false, false, true, true, 0, 1, false,
            false);
    m_Runnable__executionCondition->setContainment(true);
    m_Runnable__executionCondition->setResolveProxies(false);
    m_Runnable__parameters->setEType(m_RunnableParameterEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_Runnable__parameters),
            "parameters", true, false, false, "", false, false, true, true, 0,
            -1, true, false);
    m_Runnable__parameters->setContainment(true);
    m_Runnable__parameters->setResolveProxies(false);
    m_Runnable__parameters->setEOpposite(
            ::ecore::as < ::ecore::EReference
                    > (m_RunnableParameterEClass->getEStructuralFeatures()[1]));
    m_Runnable__activityGraph->setEType(m_ActivityGraphEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_Runnable__activityGraph),
            "activityGraph", true, false, false, "", false, false, true, true,
            0, 1, false, false);
    m_Runnable__activityGraph->setContainment(true);
    m_Runnable__activityGraph->setResolveProxies(false);
    m_Runnable__activations->setEType(m_ActivationEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_Runnable__activations),
            "activations", true, false, false, "", false, false, true, true, 0,
            -1, true, false);
    m_Runnable__activations->setContainment(false);
    m_Runnable__activations->setResolveProxies(true);
    m_Runnable__section->setEType(m_SectionEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_Runnable__section),
            "section", true, false, false, "", false, false, true, true, 0, 1,
            false, false);
    m_Runnable__section->setContainment(false);
    m_Runnable__section->setResolveProxies(true);
    m_Runnable__runnableCalls->setEType(m_RunnableCallEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_Runnable__runnableCalls),
            "runnableCalls", false, true, true, "", false, true, true, true, 0,
            -1, true, false);
    m_Runnable__runnableCalls->setContainment(false);
    m_Runnable__runnableCalls->setResolveProxies(true);
    m_Runnable__referringComponents->setEType(m_ComponentEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_Runnable__referringComponents), "referringComponents",
            false, true, true, "", false, true, true, true, 0, -1, true, false);
    m_Runnable__referringComponents->setContainment(false);
    m_Runnable__referringComponents->setResolveProxies(true);
    {
        ::ecore::EOperation_ptr _op = addEOperation(m_RunnableEClass, nullptr,
                "getRunnableItems", 0, -1, false, true);
        _op->setEType(m_ActivityGraphItemEClass);
    }
    {
        ::ecore::EOperation_ptr _op = addEOperation(m_RunnableEClass, nullptr,
                "getFirstActivation", 0, 1, false, true);
        _op->setEType(m_ActivationEClass);
    }
    // Label
    m_LabelEClass->setName("Label");
    m_LabelEClass->setAbstract(false);
    m_LabelEClass->setInterface(false);
    m_Label__constant->setEType(
            dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEBoolean());
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute > (m_Label__constant), "constant",
            true, false, false, "false", false, false, true, false, 0, 1, false,
            false);
    m_Label__constant->setID(false);
    m_Label__bVolatile->setEType(
            dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEBoolean());
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute > (m_Label__bVolatile),
            "bVolatile", true, false, false, "false", false, false, true, false,
            0, 1, false, false);
    m_Label__bVolatile->setID(false);
    m_Label__dataStability->setEType(m_LabelDataStabilityEEnum);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute > (m_Label__dataStability),
            "dataStability", true, false, false, "", false, false, true, false,
            0, 1, false, false);
    m_Label__dataStability->setID(false);
    m_Label__stabilityLevel->setEType(m_DataStabilityLevelEEnum);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute > (m_Label__stabilityLevel),
            "stabilityLevel", true, false, false, "", false, false, true, false,
            0, 1, false, false);
    m_Label__stabilityLevel->setID(false);
    m_Label__dataType->setEType(m_DataTypeEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_Label__dataType), "dataType",
            true, false, false, "", false, false, true, true, 0, 1, false,
            false);
    m_Label__dataType->setContainment(true);
    m_Label__dataType->setResolveProxies(false);
    m_Label__section->setEType(m_SectionEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_Label__section), "section",
            true, false, false, "", false, false, true, true, 0, 1, false,
            false);
    m_Label__section->setContainment(false);
    m_Label__section->setResolveProxies(true);
    m_Label__labelAccesses->setEType(m_LabelAccessEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_Label__labelAccesses),
            "labelAccesses", false, true, true, "", false, true, true, true, 0,
            -1, true, false);
    m_Label__labelAccesses->setContainment(false);
    m_Label__labelAccesses->setResolveProxies(true);
    m_Label__referringComponents->setEType(m_ComponentEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_Label__referringComponents),
            "referringComponents", false, true, true, "", false, true, true,
            true, 0, -1, true, false);
    m_Label__referringComponents->setContainment(false);
    m_Label__referringComponents->setResolveProxies(true);
    // Channel
    m_ChannelEClass->setName("Channel");
    m_ChannelEClass->setAbstract(false);
    m_ChannelEClass->setInterface(false);
    m_Channel__defaultElements->setEType(
            dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEInt());
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute > (m_Channel__defaultElements),
            "defaultElements", true, false, false, "0", false, false, true,
            false, 0, 1, false, false);
    m_Channel__defaultElements->setID(false);
    m_Channel__maxElements->setEType(
            dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEInt());
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute > (m_Channel__maxElements),
            "maxElements", true, false, false, "0", false, false, true, false,
            0, 1, false, false);
    m_Channel__maxElements->setID(false);
    m_Channel__elementType->setEType(m_DataTypeEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_Channel__elementType),
            "elementType", true, false, false, "", false, false, true, true, 0,
            1, false, false);
    m_Channel__elementType->setContainment(true);
    m_Channel__elementType->setResolveProxies(false);
    m_Channel__channelAccesses->setEType(m_ChannelAccessEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_Channel__channelAccesses),
            "channelAccesses", false, true, true, "", false, true, true, true,
            0, -1, true, false);
    m_Channel__channelAccesses->setContainment(false);
    m_Channel__channelAccesses->setResolveProxies(true);
    // ModeLabel
    m_ModeLabelEClass->setName("ModeLabel");
    m_ModeLabelEClass->setAbstract(false);
    m_ModeLabelEClass->setInterface(false);
    m_ModeLabel__initialValue->setEType(
            dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEString());
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute > (m_ModeLabel__initialValue),
            "initialValue", true, false, false, "", false, false, true, false,
            0, 1, false, false);
    m_ModeLabel__initialValue->setID(false);
    m_ModeLabel__mode->setEType(m_ModeEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_ModeLabel__mode), "mode",
            true, false, false, "", false, false, true, true, 1, 1, false,
            true);
    m_ModeLabel__mode->setContainment(false);
    m_ModeLabel__mode->setResolveProxies(true);
    {
        ::ecore::EOperation_ptr _op = addEOperation(m_ModeLabelEClass, nullptr,
                "validateInvariants", 0, 1, false, true);
        _op->setEType(
                dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEBoolean());
        {
            ::ecore::EParameter_ptr _pa = addEParameter(_op, "diagnostics", 0,
                    1, false, true);
            _pa->setEType(
                    dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEDiagnosticChain());
        }
        {
            ::ecore::EParameter_ptr _pa = addEParameter(_op, "context", 0, 1,
                    false, true);
            _pa->setEType(
                    dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEMap());
            {
                ::ecore::EGenericType_ptr _g0 = ::ecore::Ptr
                        < ::ecore::EGenericType > (new ::ecore::EGenericType);
                _g0->setEClassifier(
                        dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEMap());
                ::ecore::EGenericType_ptr _g1 = ::ecore::Ptr
                        < ::ecore::EGenericType > (new ::ecore::EGenericType);
                _g1->setEClassifier(
                        dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEJavaObject());
                _g0->getETypeArguments().push_back(_g1);
                ::ecore::EGenericType_ptr _g2 = ::ecore::Ptr
                        < ::ecore::EGenericType > (new ::ecore::EGenericType);
                _g2->setEClassifier(
                        dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEJavaObject());
                _g0->getETypeArguments().push_back(_g2);
                _pa->setEGenericType(_g0);
            }
        }
    }
    {
        ::ecore::EOperation_ptr _op = addEOperation(m_ModeLabelEClass, nullptr,
                "isEnum", 0, 1, false, true);
        _op->setEType(
                dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEBoolean());
    }
    {
        ::ecore::EOperation_ptr _op = addEOperation(m_ModeLabelEClass, nullptr,
                "isNumeric", 0, 1, false, true);
        _op->setEType(
                dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEBoolean());
    }
    // Section
    m_SectionEClass->setName("Section");
    m_SectionEClass->setAbstract(false);
    m_SectionEClass->setInterface(false);
    m_Section__asilLevel->setEType(m_ASILTypeEEnum);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute > (m_Section__asilLevel),
            "asilLevel", true, false, false, "", false, false, true, false, 0,
            1, false, false);
    m_Section__asilLevel->setID(false);
    m_Section__labels->setEType(m_LabelEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_Section__labels), "labels",
            false, true, true, "", false, true, true, true, 0, -1, true, false);
    m_Section__labels->setContainment(false);
    m_Section__labels->setResolveProxies(true);
    m_Section__runnables->setEType(m_RunnableEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_Section__runnables),
            "runnables", false, true, true, "", false, true, true, true, 0, -1,
            true, false);
    m_Section__runnables->setContainment(false);
    m_Section__runnables->setResolveProxies(true);
    // ComputationItem
    m_ComputationItemEClass->setName("ComputationItem");
    m_ComputationItemEClass->setAbstract(true);
    m_ComputationItemEClass->setInterface(false);
    // ExecutionNeed
    m_ExecutionNeedEClass->setName("ExecutionNeed");
    m_ExecutionNeedEClass->setAbstract(false);
    m_ExecutionNeedEClass->setInterface(false);
    m_ExecutionNeed__needs->setEType(m_NeedEntryEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_ExecutionNeed__needs),
            "needs", true, false, false, "", false, false, true, true, 0, -1,
            true, false);
    m_ExecutionNeed__needs->setContainment(true);
    m_ExecutionNeed__needs->setResolveProxies(false);
    // NeedEntry
    m_NeedEntryEClass->setName("NeedEntry");
    m_NeedEntryEClass->setAbstract(false);
    m_NeedEntryEClass->setInterface(false);
    m_NeedEntry__key->setEType(
            dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEString());
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute > (m_NeedEntry__key), "key", true,
            false, false, "", false, false, true, false, 1, 1, false, true);
    m_NeedEntry__key->setID(false);
    m_NeedEntry__value->setEType(m_IDiscreteValueDeviationEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_NeedEntry__value), "value",
            true, false, false, "", false, false, true, true, 1, 1, false,
            true);
    m_NeedEntry__value->setContainment(true);
    m_NeedEntry__value->setResolveProxies(false);
    // Ticks
    m_TicksEClass->setName("Ticks");
    m_TicksEClass->setAbstract(false);
    m_TicksEClass->setInterface(false);
    m_Ticks__default->setEType(m_IDiscreteValueDeviationEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_Ticks__default), "default",
            true, false, false, "", false, false, true, true, 0, 1, false,
            false);
    m_Ticks__default->setContainment(true);
    m_Ticks__default->setResolveProxies(false);
    m_Ticks__extended->setEType(m_TicksEntryEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_Ticks__extended), "extended",
            true, false, false, "", false, false, true, true, 0, -1, true,
            false);
    m_Ticks__extended->setContainment(true);
    m_Ticks__extended->setResolveProxies(false);
    // TicksEntry
    m_TicksEntryEClass->setName("TicksEntry");
    m_TicksEntryEClass->setAbstract(false);
    m_TicksEntryEClass->setInterface(false);
    m_TicksEntry__key->setEType(m_ProcessingUnitDefinitionEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_TicksEntry__key), "key",
            true, false, false, "", false, false, true, true, 1, 1, false,
            true);
    m_TicksEntry__key->setContainment(false);
    m_TicksEntry__key->setResolveProxies(true);
    m_TicksEntry__value->setEType(m_IDiscreteValueDeviationEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_TicksEntry__value), "value",
            true, false, false, "", false, false, true, true, 1, 1, false,
            true);
    m_TicksEntry__value->setContainment(true);
    m_TicksEntry__value->setResolveProxies(false);
    // ModeLabelAccess
    m_ModeLabelAccessEClass->setName("ModeLabelAccess");
    m_ModeLabelAccessEClass->setAbstract(false);
    m_ModeLabelAccessEClass->setInterface(false);
    m_ModeLabelAccess__access->setEType(m_ModeLabelAccessEnumEEnum);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute > (m_ModeLabelAccess__access),
            "access", true, false, false, "", false, false, true, false, 0, 1,
            false, false);
    m_ModeLabelAccess__access->setID(false);
    m_ModeLabelAccess__value->setEType(
            dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEString());
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute > (m_ModeLabelAccess__value),
            "value", true, false, false, "", false, false, true, false, 0, 1,
            false, false);
    m_ModeLabelAccess__value->setID(false);
    m_ModeLabelAccess__step->setEType(m_PositiveIntEDataType);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute > (m_ModeLabelAccess__step),
            "step", true, false, false, "1", false, false, true, false, 0, 1,
            false, false);
    m_ModeLabelAccess__step->setID(false);
    m_ModeLabelAccess__data->setEType(m_ModeLabelEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_ModeLabelAccess__data),
            "data", true, false, false, "", false, false, true, true, 1, 1,
            false, true);
    m_ModeLabelAccess__data->setContainment(false);
    m_ModeLabelAccess__data->setResolveProxies(true);
    {
        ::ecore::EOperation_ptr _op = addEOperation(m_ModeLabelAccessEClass,
                nullptr, "validateInvariants", 0, 1, false, true);
        _op->setEType(
                dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEBoolean());
        {
            ::ecore::EParameter_ptr _pa = addEParameter(_op, "diagnostics", 0,
                    1, false, true);
            _pa->setEType(
                    dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEDiagnosticChain());
        }
        {
            ::ecore::EParameter_ptr _pa = addEParameter(_op, "context", 0, 1,
                    false, true);
            _pa->setEType(
                    dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEMap());
            {
                ::ecore::EGenericType_ptr _g0 = ::ecore::Ptr
                        < ::ecore::EGenericType > (new ::ecore::EGenericType);
                _g0->setEClassifier(
                        dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEMap());
                ::ecore::EGenericType_ptr _g1 = ::ecore::Ptr
                        < ::ecore::EGenericType > (new ::ecore::EGenericType);
                _g1->setEClassifier(
                        dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEJavaObject());
                _g0->getETypeArguments().push_back(_g1);
                ::ecore::EGenericType_ptr _g2 = ::ecore::Ptr
                        < ::ecore::EGenericType > (new ::ecore::EGenericType);
                _g2->setEClassifier(
                        dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEJavaObject());
                _g0->getETypeArguments().push_back(_g2);
                _pa->setEGenericType(_g0);
            }
        }
    }
    // LabelAccess
    m_LabelAccessEClass->setName("LabelAccess");
    m_LabelAccessEClass->setAbstract(false);
    m_LabelAccessEClass->setInterface(false);
    m_LabelAccess__access->setEType(m_LabelAccessEnumEEnum);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute > (m_LabelAccess__access),
            "access", true, false, false, "", false, false, true, false, 0, 1,
            false, false);
    m_LabelAccess__access->setID(false);
    m_LabelAccess__dataStability->setEType(m_LabelAccessDataStabilityEEnum);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute > (m_LabelAccess__dataStability),
            "dataStability", true, false, false, "", false, false, true, false,
            0, 1, false, false);
    m_LabelAccess__dataStability->setID(false);
    m_LabelAccess__implementation->setEType(m_LabelAccessImplementationEEnum);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute > (m_LabelAccess__implementation),
            "implementation", true, false, false, "", false, false, true, false,
            0, 1, false, false);
    m_LabelAccess__implementation->setID(false);
    m_LabelAccess__data->setEType(m_LabelEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_LabelAccess__data), "data",
            true, false, false, "", false, false, true, true, 1, 1, false,
            true);
    m_LabelAccess__data->setContainment(false);
    m_LabelAccess__data->setResolveProxies(true);
    m_LabelAccess__statistic->setEType(m_LabelAccessStatisticEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_LabelAccess__statistic),
            "statistic", true, false, false, "", false, false, true, true, 0, 1,
            false, false);
    m_LabelAccess__statistic->setContainment(true);
    m_LabelAccess__statistic->setResolveProxies(false);
    m_LabelAccess__transmissionPolicy->setEType(m_TransmissionPolicyEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_LabelAccess__transmissionPolicy), "transmissionPolicy",
            true, false, false, "", false, false, true, true, 0, 1, false,
            false);
    m_LabelAccess__transmissionPolicy->setContainment(true);
    m_LabelAccess__transmissionPolicy->setResolveProxies(false);
    // ChannelAccess
    m_ChannelAccessEClass->setName("ChannelAccess");
    m_ChannelAccessEClass->setAbstract(true);
    m_ChannelAccessEClass->setInterface(false);
    m_ChannelAccess__elements->setEType(
            dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEInt());
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute > (m_ChannelAccess__elements),
            "elements", true, false, false, "0", false, false, true, false, 0,
            1, false, false);
    m_ChannelAccess__elements->setID(false);
    m_ChannelAccess__data->setEType(m_ChannelEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_ChannelAccess__data), "data",
            true, false, false, "", false, false, true, true, 1, 1, false,
            true);
    m_ChannelAccess__data->setContainment(false);
    m_ChannelAccess__data->setResolveProxies(true);
    m_ChannelAccess__transmissionPolicy->setEType(m_TransmissionPolicyEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_ChannelAccess__transmissionPolicy),
            "transmissionPolicy", true, false, false, "", false, false, true,
            true, 0, 1, false, false);
    m_ChannelAccess__transmissionPolicy->setContainment(true);
    m_ChannelAccess__transmissionPolicy->setResolveProxies(false);
    // ChannelSend
    m_ChannelSendEClass->setName("ChannelSend");
    m_ChannelSendEClass->setAbstract(false);
    m_ChannelSendEClass->setInterface(false);
    // ChannelReceive
    m_ChannelReceiveEClass->setName("ChannelReceive");
    m_ChannelReceiveEClass->setAbstract(false);
    m_ChannelReceiveEClass->setInterface(false);
    m_ChannelReceive__receiveOperation->setEType(m_ReceiveOperationEEnum);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute
                    > (m_ChannelReceive__receiveOperation), "receiveOperation",
            true, false, false, "", false, false, true, false, 0, 1, false,
            false);
    m_ChannelReceive__receiveOperation->setID(false);
    m_ChannelReceive__dataMustBeNew->setEType(
            dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEBoolean());
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute
                    > (m_ChannelReceive__dataMustBeNew), "dataMustBeNew", true,
            false, false, "false", false, false, true, false, 0, 1, false,
            false);
    m_ChannelReceive__dataMustBeNew->setID(false);
    m_ChannelReceive__elementIndex->setEType(
            dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEInt());
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute
                    > (m_ChannelReceive__elementIndex), "elementIndex", true,
            false, false, "0", false, false, true, false, 0, 1, false, false);
    m_ChannelReceive__elementIndex->setID(false);
    m_ChannelReceive__lowerBound->setEType(
            dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEInt());
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute > (m_ChannelReceive__lowerBound),
            "lowerBound", true, false, false, "0", false, false, true, false, 0,
            1, false, false);
    m_ChannelReceive__lowerBound->setID(false);
    // SemaphoreAccess
    m_SemaphoreAccessEClass->setName("SemaphoreAccess");
    m_SemaphoreAccessEClass->setAbstract(false);
    m_SemaphoreAccessEClass->setInterface(false);
    m_SemaphoreAccess__access->setEType(m_SemaphoreAccessEnumEEnum);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute > (m_SemaphoreAccess__access),
            "access", true, false, false, "", false, false, true, false, 0, 1,
            false, false);
    m_SemaphoreAccess__access->setID(false);
    m_SemaphoreAccess__waitingBehaviour->setEType(m_WaitingBehaviourEEnum);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute
                    > (m_SemaphoreAccess__waitingBehaviour), "waitingBehaviour",
            true, false, false, "", false, false, true, false, 0, 1, false,
            false);
    m_SemaphoreAccess__waitingBehaviour->setID(false);
    m_SemaphoreAccess__semaphore->setEType(m_SemaphoreEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_SemaphoreAccess__semaphore),
            "semaphore", true, false, false, "", false, false, true, true, 1, 1,
            false, true);
    m_SemaphoreAccess__semaphore->setContainment(false);
    m_SemaphoreAccess__semaphore->setResolveProxies(true);
    // SenderReceiverCommunication
    m_SenderReceiverCommunicationEClass->setName("SenderReceiverCommunication");
    m_SenderReceiverCommunicationEClass->setAbstract(true);
    m_SenderReceiverCommunicationEClass->setInterface(false);
    m_SenderReceiverCommunication__buffered->setEType(
            dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEBoolean());
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute
                    > (m_SenderReceiverCommunication__buffered), "buffered",
            true, false, false, "false", false, false, true, false, 0, 1, false,
            false);
    m_SenderReceiverCommunication__buffered->setID(false);
    m_SenderReceiverCommunication__label->setEType(m_LabelEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_SenderReceiverCommunication__label), "label", true,
            false, false, "", false, false, true, true, 1, 1, false, true);
    m_SenderReceiverCommunication__label->setContainment(false);
    m_SenderReceiverCommunication__label->setResolveProxies(true);
    m_SenderReceiverCommunication__port->setEType(m_ComponentPortEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_SenderReceiverCommunication__port), "port", true,
            false, false, "", false, false, true, true, 0, 1, false, false);
    m_SenderReceiverCommunication__port->setContainment(false);
    m_SenderReceiverCommunication__port->setResolveProxies(true);
    // SenderReceiverRead
    m_SenderReceiverReadEClass->setName("SenderReceiverRead");
    m_SenderReceiverReadEClass->setAbstract(false);
    m_SenderReceiverReadEClass->setInterface(false);
    // SenderReceiverWrite
    m_SenderReceiverWriteEClass->setName("SenderReceiverWrite");
    m_SenderReceiverWriteEClass->setAbstract(false);
    m_SenderReceiverWriteEClass->setInterface(false);
    m_SenderReceiverWrite__notifiedRunnables->setEType(m_RunnableEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_SenderReceiverWrite__notifiedRunnables),
            "notifiedRunnables", true, false, false, "", false, false, true,
            true, 0, -1, true, false);
    m_SenderReceiverWrite__notifiedRunnables->setContainment(false);
    m_SenderReceiverWrite__notifiedRunnables->setResolveProxies(true);
    // ServerCall
    m_ServerCallEClass->setName("ServerCall");
    m_ServerCallEClass->setAbstract(true);
    m_ServerCallEClass->setInterface(false);
    m_ServerCall__serverRunnable->setEType(m_RunnableEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_ServerCall__serverRunnable),
            "serverRunnable", true, false, false, "", false, false, true, true,
            1, 1, false, true);
    m_ServerCall__serverRunnable->setContainment(false);
    m_ServerCall__serverRunnable->setResolveProxies(true);
    m_ServerCall__port->setEType(m_ComponentPortEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_ServerCall__port), "port",
            true, false, false, "", false, false, true, true, 0, 1, false,
            false);
    m_ServerCall__port->setContainment(false);
    m_ServerCall__port->setResolveProxies(true);
    // SynchronousServerCall
    m_SynchronousServerCallEClass->setName("SynchronousServerCall");
    m_SynchronousServerCallEClass->setAbstract(false);
    m_SynchronousServerCallEClass->setInterface(false);
    m_SynchronousServerCall__waitingBehaviour->setEType(
            m_WaitingBehaviourEEnum);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute
                    > (m_SynchronousServerCall__waitingBehaviour),
            "waitingBehaviour", true, false, false, "", false, false, true,
            false, 0, 1, false, false);
    m_SynchronousServerCall__waitingBehaviour->setID(false);
    // AsynchronousServerCall
    m_AsynchronousServerCallEClass->setName("AsynchronousServerCall");
    m_AsynchronousServerCallEClass->setAbstract(false);
    m_AsynchronousServerCallEClass->setInterface(false);
    m_AsynchronousServerCall__resultRunnable->setEType(m_RunnableEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_AsynchronousServerCall__resultRunnable),
            "resultRunnable", true, false, false, "", false, false, true, true,
            0, 1, false, false);
    m_AsynchronousServerCall__resultRunnable->setContainment(false);
    m_AsynchronousServerCall__resultRunnable->setResolveProxies(true);
    // GetResultServerCall
    m_GetResultServerCallEClass->setName("GetResultServerCall");
    m_GetResultServerCallEClass->setAbstract(false);
    m_GetResultServerCallEClass->setInterface(false);
    m_GetResultServerCall__blockingType->setEType(m_BlockingTypeEEnum);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute
                    > (m_GetResultServerCall__blockingType), "blockingType",
            true, false, false, "", false, false, true, false, 0, 1, false,
            false);
    m_GetResultServerCall__blockingType->setID(false);
    // Group
    m_GroupEClass->setName("Group");
    m_GroupEClass->setAbstract(false);
    m_GroupEClass->setInterface(false);
    m_Group__ordered->setEType(
            dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEBoolean());
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute > (m_Group__ordered), "ordered",
            true, false, false, "true", false, false, true, false, 0, 1, false,
            false);
    m_Group__ordered->setID(false);
    // CallArgument
    m_CallArgumentEClass->setName("CallArgument");
    m_CallArgumentEClass->setAbstract(false);
    m_CallArgumentEClass->setInterface(false);
    m_CallArgument__containingCall->setEType(m_RunnableCallEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_CallArgument__containingCall), "containingCall", false,
            false, false, "", false, false, true, true, 0, 1, false, false);
    m_CallArgument__containingCall->setContainment(false);
    m_CallArgument__containingCall->setResolveProxies(true);
    m_CallArgument__containingCall->setEOpposite(
            ::ecore::as < ::ecore::EReference
                    > (m_RunnableCallEClass->getEStructuralFeatures()[1]));
    m_CallArgument__parameter->setEType(m_RunnableParameterEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_CallArgument__parameter),
            "parameter", true, false, false, "", false, false, true, true, 0, 1,
            false, false);
    m_CallArgument__parameter->setContainment(false);
    m_CallArgument__parameter->setResolveProxies(true);
    {
        ::ecore::EOperation_ptr _op = addEOperation(m_CallArgumentEClass,
                nullptr, "getName", 0, 1, false, true);
        _op->setEType(
                dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEString());
    }
    {
        ::ecore::EOperation_ptr _op = addEOperation(m_CallArgumentEClass,
                nullptr, "getNamePrefixSegments", 0, -1, false, true);
        _op->setEType(
                dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEString());
    }
    // RunnableCall
    m_RunnableCallEClass->setName("RunnableCall");
    m_RunnableCallEClass->setAbstract(false);
    m_RunnableCallEClass->setInterface(false);
    m_RunnableCall__runnable->setEType(m_RunnableEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_RunnableCall__runnable),
            "runnable", true, false, false, "", false, false, true, true, 1, 1,
            false, true);
    m_RunnableCall__runnable->setContainment(false);
    m_RunnableCall__runnable->setResolveProxies(true);
    m_RunnableCall__arguments->setEType(m_CallArgumentEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_RunnableCall__arguments),
            "arguments", true, false, false, "", false, false, true, true, 0,
            -1, true, false);
    m_RunnableCall__arguments->setContainment(true);
    m_RunnableCall__arguments->setResolveProxies(false);
    m_RunnableCall__arguments->setEOpposite(
            ::ecore::as < ::ecore::EReference
                    > (m_CallArgumentEClass->getEStructuralFeatures()[0]));
    m_RunnableCall__counter->setEType(m_CounterEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_RunnableCall__counter),
            "counter", true, false, false, "", false, false, true, true, 0, 1,
            false, false);
    m_RunnableCall__counter->setContainment(true);
    m_RunnableCall__counter->setResolveProxies(false);
    m_RunnableCall__statistic->setEType(m_RunEntityCallStatisticEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_RunnableCall__statistic),
            "statistic", true, false, false, "", false, false, true, true, 0, 1,
            false, false);
    m_RunnableCall__statistic->setContainment(true);
    m_RunnableCall__statistic->setResolveProxies(false);
    // CustomEventTrigger
    m_CustomEventTriggerEClass->setName("CustomEventTrigger");
    m_CustomEventTriggerEClass->setAbstract(false);
    m_CustomEventTriggerEClass->setInterface(false);
    m_CustomEventTrigger__event->setEType(m_CustomEventEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_CustomEventTrigger__event),
            "event", true, false, false, "", false, false, true, true, 1, 1,
            false, true);
    m_CustomEventTrigger__event->setContainment(false);
    m_CustomEventTrigger__event->setResolveProxies(true);
    // DataType
    m_DataTypeEClass->setName("DataType");
    m_DataTypeEClass->setAbstract(true);
    m_DataTypeEClass->setInterface(true);
    // CompoundType
    m_CompoundTypeEClass->setName("CompoundType");
    m_CompoundTypeEClass->setAbstract(true);
    m_CompoundTypeEClass->setInterface(false);
    // Struct
    m_StructEClass->setName("Struct");
    m_StructEClass->setAbstract(false);
    m_StructEClass->setInterface(false);
    m_Struct__entries->setEType(m_StructEntryEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_Struct__entries), "entries",
            true, false, false, "", false, false, true, true, 0, -1, true,
            false);
    m_Struct__entries->setContainment(true);
    m_Struct__entries->setResolveProxies(false);
    // StructEntry
    m_StructEntryEClass->setName("StructEntry");
    m_StructEntryEClass->setAbstract(false);
    m_StructEntryEClass->setInterface(false);
    m_StructEntry__dataType->setEType(m_DataTypeEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_StructEntry__dataType),
            "dataType", true, false, false, "", false, false, true, true, 0, 1,
            false, false);
    m_StructEntry__dataType->setContainment(true);
    m_StructEntry__dataType->setResolveProxies(false);
    // Array
    m_ArrayEClass->setName("Array");
    m_ArrayEClass->setAbstract(false);
    m_ArrayEClass->setInterface(false);
    m_Array__numberElements->setEType(
            dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEInt());
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute > (m_Array__numberElements),
            "numberElements", true, false, false, "0", false, false, true,
            false, 0, 1, false, false);
    m_Array__numberElements->setID(false);
    m_Array__dataType->setEType(m_DataTypeEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_Array__dataType), "dataType",
            true, false, false, "", false, false, true, true, 0, 1, false,
            false);
    m_Array__dataType->setContainment(true);
    m_Array__dataType->setResolveProxies(false);
    // Pointer
    m_PointerEClass->setName("Pointer");
    m_PointerEClass->setAbstract(false);
    m_PointerEClass->setInterface(false);
    m_Pointer__dataType->setEType(m_DataTypeEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_Pointer__dataType),
            "dataType", true, false, false, "", false, false, true, true, 0, 1,
            false, false);
    m_Pointer__dataType->setContainment(true);
    m_Pointer__dataType->setResolveProxies(false);
    // TypeRef
    m_TypeRefEClass->setName("TypeRef");
    m_TypeRefEClass->setAbstract(false);
    m_TypeRefEClass->setInterface(false);
    m_TypeRef__typeDef->setEType(m_TypeDefinitionEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_TypeRef__typeDef), "typeDef",
            true, false, false, "", false, false, true, true, 0, 1, false,
            false);
    m_TypeRef__typeDef->setContainment(false);
    m_TypeRef__typeDef->setResolveProxies(true);
    // Alias
    m_AliasEClass->setName("Alias");
    m_AliasEClass->setAbstract(false);
    m_AliasEClass->setInterface(false);
    m_Alias__target->setEType(
            dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEString());
    initEStructuralFeature(
            ::ecore::as < ::ecore::EAttribute > (m_Alias__target), "target",
            true, false, false, "", false, false, true, false, 0, 1, false,
            false);
    m_Alias__target->setID(false);
    m_Alias__alias->setEType(
            dynamic_cast< ::ecore::EcorePackage* >(::ecore::EcorePackage::_instance().get())->getEString());
    initEStructuralFeature(::ecore::as < ::ecore::EAttribute > (m_Alias__alias),
            "alias", true, false, false, "", false, false, true, false, 0, 1,
            false, false);
    m_Alias__alias->setID(false);
    // TypeDefinition
    m_TypeDefinitionEClass->setName("TypeDefinition");
    m_TypeDefinitionEClass->setAbstract(true);
    m_TypeDefinitionEClass->setInterface(false);
    m_TypeDefinition__size->setEType(m_DataSizeEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_TypeDefinition__size),
            "size", true, false, false, "", false, false, true, true, 0, 1,
            false, false);
    m_TypeDefinition__size->setContainment(true);
    m_TypeDefinition__size->setResolveProxies(false);
    // DataTypeDefinition
    m_DataTypeDefinitionEClass->setName("DataTypeDefinition");
    m_DataTypeDefinitionEClass->setAbstract(false);
    m_DataTypeDefinitionEClass->setInterface(false);
    m_DataTypeDefinition__dataType->setEType(m_DataTypeEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_DataTypeDefinition__dataType), "dataType", true, false,
            false, "", false, false, true, true, 0, 1, false, false);
    m_DataTypeDefinition__dataType->setContainment(true);
    m_DataTypeDefinition__dataType->setResolveProxies(false);
    // BaseTypeDefinition
    m_BaseTypeDefinitionEClass->setName("BaseTypeDefinition");
    m_BaseTypeDefinitionEClass->setAbstract(false);
    m_BaseTypeDefinitionEClass->setInterface(false);
    m_BaseTypeDefinition__aliases->setEType(m_AliasEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_BaseTypeDefinition__aliases),
            "aliases", true, false, false, "", false, false, true, true, 0, -1,
            true, false);
    m_BaseTypeDefinition__aliases->setContainment(true);
    m_BaseTypeDefinition__aliases->setResolveProxies(false);
    // Activation
    m_ActivationEClass->setName("Activation");
    m_ActivationEClass->setAbstract(true);
    m_ActivationEClass->setInterface(false);
    // PeriodicActivation
    m_PeriodicActivationEClass->setName("PeriodicActivation");
    m_PeriodicActivationEClass->setAbstract(false);
    m_PeriodicActivationEClass->setInterface(false);
    m_PeriodicActivation__min->setEType(m_TimeEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_PeriodicActivation__min),
            "min", true, false, false, "", false, false, true, true, 0, 1,
            false, false);
    m_PeriodicActivation__min->setContainment(true);
    m_PeriodicActivation__min->setResolveProxies(false);
    m_PeriodicActivation__max->setEType(m_TimeEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_PeriodicActivation__max),
            "max", true, false, false, "", false, false, true, true, 0, 1,
            false, false);
    m_PeriodicActivation__max->setContainment(true);
    m_PeriodicActivation__max->setResolveProxies(false);
    m_PeriodicActivation__recurrence->setEType(m_TimeEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_PeriodicActivation__recurrence), "recurrence", true,
            false, false, "", false, false, true, true, 1, 1, false, true);
    m_PeriodicActivation__recurrence->setContainment(true);
    m_PeriodicActivation__recurrence->setResolveProxies(false);
    m_PeriodicActivation__offset->setEType(m_TimeEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_PeriodicActivation__offset),
            "offset", true, false, false, "", false, false, true, true, 0, 1,
            false, false);
    m_PeriodicActivation__offset->setContainment(true);
    m_PeriodicActivation__offset->setResolveProxies(false);
    // VariableRateActivation
    m_VariableRateActivationEClass->setName("VariableRateActivation");
    m_VariableRateActivationEClass->setAbstract(false);
    m_VariableRateActivationEClass->setInterface(false);
    m_VariableRateActivation__step->setEType(m_TimeEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_VariableRateActivation__step), "step", true, false,
            false, "", false, false, true, true, 1, 1, false, true);
    m_VariableRateActivation__step->setContainment(true);
    m_VariableRateActivation__step->setResolveProxies(false);
    m_VariableRateActivation__occurrencesPerStep->setEType(
            m_IContinuousValueDeviationEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_VariableRateActivation__occurrencesPerStep),
            "occurrencesPerStep", true, false, false, "", false, false, true,
            true, 1, 1, false, true);
    m_VariableRateActivation__occurrencesPerStep->setContainment(true);
    m_VariableRateActivation__occurrencesPerStep->setResolveProxies(false);
    // SporadicActivation
    m_SporadicActivationEClass->setName("SporadicActivation");
    m_SporadicActivationEClass->setAbstract(false);
    m_SporadicActivationEClass->setInterface(false);
    m_SporadicActivation__occurrence->setEType(m_ITimeDeviationEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_SporadicActivation__occurrence), "occurrence", true,
            false, false, "", false, false, true, true, 1, 1, false, true);
    m_SporadicActivation__occurrence->setContainment(true);
    m_SporadicActivation__occurrence->setResolveProxies(false);
    // SingleActivation
    m_SingleActivationEClass->setName("SingleActivation");
    m_SingleActivationEClass->setAbstract(false);
    m_SingleActivationEClass->setInterface(false);
    m_SingleActivation__min->setEType(m_TimeEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_SingleActivation__min),
            "min", true, false, false, "", false, false, true, true, 1, 1,
            false, true);
    m_SingleActivation__min->setContainment(true);
    m_SingleActivation__min->setResolveProxies(false);
    m_SingleActivation__max->setEType(m_TimeEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_SingleActivation__max),
            "max", true, false, false, "", false, false, true, true, 1, 1,
            false, true);
    m_SingleActivation__max->setContainment(true);
    m_SingleActivation__max->setResolveProxies(false);
    // EventActivation
    m_EventActivationEClass->setName("EventActivation");
    m_EventActivationEClass->setAbstract(false);
    m_EventActivationEClass->setInterface(false);
    m_EventActivation__triggeringEvents->setEType(m_TriggerEventEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_EventActivation__triggeringEvents), "triggeringEvents",
            true, false, false, "", false, false, true, true, 1, -1, true,
            true);
    m_EventActivation__triggeringEvents->setContainment(false);
    m_EventActivation__triggeringEvents->setResolveProxies(true);
    m_EventActivation__counter->setEType(m_CounterEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_EventActivation__counter),
            "counter", true, false, false, "", false, false, true, true, 0, 1,
            false, false);
    m_EventActivation__counter->setContainment(true);
    m_EventActivation__counter->setResolveProxies(false);
    // CustomActivation
    m_CustomActivationEClass->setName("CustomActivation");
    m_CustomActivationEClass->setAbstract(false);
    m_CustomActivationEClass->setInterface(false);
    // LabelAccessStatistic
    m_LabelAccessStatisticEClass->setName("LabelAccessStatistic");
    m_LabelAccessStatisticEClass->setAbstract(false);
    m_LabelAccessStatisticEClass->setInterface(false);
    m_LabelAccessStatistic__value->setEType(m_NumericStatisticEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference > (m_LabelAccessStatistic__value),
            "value", true, false, false, "", false, false, true, true, 0, 1,
            false, false);
    m_LabelAccessStatistic__value->setContainment(true);
    m_LabelAccessStatistic__value->setResolveProxies(false);
    m_LabelAccessStatistic__cacheMisses->setEType(m_NumericStatisticEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_LabelAccessStatistic__cacheMisses), "cacheMisses",
            true, false, false, "", false, false, true, true, 0, 1, false,
            false);
    m_LabelAccessStatistic__cacheMisses->setContainment(true);
    m_LabelAccessStatistic__cacheMisses->setResolveProxies(false);
    // RunEntityCallStatistic
    m_RunEntityCallStatisticEClass->setName("RunEntityCallStatistic");
    m_RunEntityCallStatisticEClass->setAbstract(false);
    m_RunEntityCallStatisticEClass->setInterface(false);
    m_RunEntityCallStatistic__statistic->setEType(m_NumericStatisticEClass);
    initEStructuralFeature(
            ::ecore::as < ::ecore::EReference
                    > (m_RunEntityCallStatistic__statistic), "statistic", true,
            false, false, "", false, false, true, true, 0, 1, false, false);
    m_RunEntityCallStatistic__statistic->setContainment(true);
    m_RunEntityCallStatistic__statistic->setResolveProxies(false);

    // TODO: Initialize data types

    // Address
    m_AddressEDataType->setName("Address");
    m_AddressEDataType->setSerializable(true);

    // PositiveInt
    m_PositiveIntEDataType->setName("PositiveInt");
    m_PositiveIntEDataType->setSerializable(true);

    // PositiveLong
    m_PositiveLongEDataType->setName("PositiveLong");
    m_PositiveLongEDataType->setSerializable(true);

    // PositiveDouble
    m_PositiveDoubleEDataType->setName("PositiveDouble");
    m_PositiveDoubleEDataType->setSerializable(true);

    // NonNegativeInt
    m_NonNegativeIntEDataType->setName("NonNegativeInt");
    m_NonNegativeIntEDataType->setSerializable(true);

    // NonNegativeLong
    m_NonNegativeLongEDataType->setName("NonNegativeLong");
    m_NonNegativeLongEDataType->setSerializable(true);

    // NonNegativeDouble
    m_NonNegativeDoubleEDataType->setName("NonNegativeDouble");
    m_NonNegativeDoubleEDataType->setSerializable(true);

    // RelationalOperator
    m_RelationalOperatorEEnum->setName("RelationalOperator");
    m_RelationalOperatorEEnum->setSerializable(true);

    {
        // _undefined_
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(
                m_RelationalOperatorEEnum, "_undefined_", 0, "_undefined_");
    }

    {
        // EQUAL
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(
                m_RelationalOperatorEEnum, "EQUAL", 1, "EQUAL");
    }

    {
        // NOT_EQUAL
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(
                m_RelationalOperatorEEnum, "NOT_EQUAL", 2, "NOT_EQUAL");
    }

    {
        // LESS_THAN
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(
                m_RelationalOperatorEEnum, "LESS_THAN", 3, "LESS_THAN");
    }

    {
        // GREATER_THAN
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(
                m_RelationalOperatorEEnum, "GREATER_THAN", 4, "GREATER_THAN");
    }

    // TimeUnit
    m_TimeUnitEEnum->setName("TimeUnit");
    m_TimeUnitEEnum->setSerializable(true);

    {
        // _undefined_
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_TimeUnitEEnum,
                "_undefined_", 0, "_undefined_");
    }

    {
        // s
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_TimeUnitEEnum, "s", 1,
                "s");
    }

    {
        // ms
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_TimeUnitEEnum, "ms",
                2, "ms");
    }

    {
        // us
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_TimeUnitEEnum, "us",
                3, "us");
    }

    {
        // ns
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_TimeUnitEEnum, "ns",
                4, "ns");
    }

    {
        // ps
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_TimeUnitEEnum, "ps",
                5, "ps");
    }

    // FrequencyUnit
    m_FrequencyUnitEEnum->setName("FrequencyUnit");
    m_FrequencyUnitEEnum->setSerializable(true);

    {
        // _undefined_
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_FrequencyUnitEEnum,
                "_undefined_", 0, "_undefined_");
    }

    {
        // Hz
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_FrequencyUnitEEnum,
                "Hz", 1, "Hz");
    }

    {
        // kHz
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_FrequencyUnitEEnum,
                "kHz", 2, "kHz");
    }

    {
        // MHz
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_FrequencyUnitEEnum,
                "MHz", 3, "MHz");
    }

    {
        // GHz
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_FrequencyUnitEEnum,
                "GHz", 4, "GHz");
    }

    // VoltageUnit
    m_VoltageUnitEEnum->setName("VoltageUnit");
    m_VoltageUnitEEnum->setSerializable(true);

    {
        // _undefined_
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_VoltageUnitEEnum,
                "_undefined_", 0, "_undefined_");
    }

    {
        // uV
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_VoltageUnitEEnum,
                "uV", 1, "uV");
    }

    {
        // mV
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_VoltageUnitEEnum,
                "mV", 2, "mV");
    }

    {
        // V
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_VoltageUnitEEnum, "V",
                3, "V");
    }

    // DataSizeUnit
    m_DataSizeUnitEEnum->setName("DataSizeUnit");
    m_DataSizeUnitEEnum->setSerializable(true);

    {
        // _undefined_
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_DataSizeUnitEEnum,
                "_undefined_", 0, "_undefined_");
    }

    {
        // bit
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_DataSizeUnitEEnum,
                "bit", 1, "bit");
    }

    {
        // kbit
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_DataSizeUnitEEnum,
                "kbit", 2, "kbit");
    }

    {
        // Mbit
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_DataSizeUnitEEnum,
                "Mbit", 3, "Mbit");
    }

    {
        // Gbit
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_DataSizeUnitEEnum,
                "Gbit", 4, "Gbit");
    }

    {
        // Tbit
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_DataSizeUnitEEnum,
                "Tbit", 5, "Tbit");
    }

    {
        // Kibit
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_DataSizeUnitEEnum,
                "Kibit", 6, "Kibit");
    }

    {
        // Mibit
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_DataSizeUnitEEnum,
                "Mibit", 7, "Mibit");
    }

    {
        // Gibit
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_DataSizeUnitEEnum,
                "Gibit", 8, "Gibit");
    }

    {
        // Tibit
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_DataSizeUnitEEnum,
                "Tibit", 9, "Tibit");
    }

    {
        // B
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_DataSizeUnitEEnum,
                "B", 10, "B");
    }

    {
        // kB
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_DataSizeUnitEEnum,
                "kB", 11, "kB");
    }

    {
        // MB
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_DataSizeUnitEEnum,
                "MB", 12, "MB");
    }

    {
        // GB
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_DataSizeUnitEEnum,
                "GB", 13, "GB");
    }

    {
        // TB
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_DataSizeUnitEEnum,
                "TB", 14, "TB");
    }

    {
        // KiB
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_DataSizeUnitEEnum,
                "KiB", 15, "KiB");
    }

    {
        // MiB
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_DataSizeUnitEEnum,
                "MiB", 16, "MiB");
    }

    {
        // GiB
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_DataSizeUnitEEnum,
                "GiB", 17, "GiB");
    }

    {
        // TiB
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_DataSizeUnitEEnum,
                "TiB", 18, "TiB");
    }

    // DataRateUnit
    m_DataRateUnitEEnum->setName("DataRateUnit");
    m_DataRateUnitEEnum->setSerializable(true);

    {
        // _undefined_
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_DataRateUnitEEnum,
                "_undefined_", 0, "_undefined_");
    }

    {
        // bitPerSecond
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_DataRateUnitEEnum,
                "bitPerSecond", 1, "bitPerSecond");
    }

    {
        // kbitPerSecond
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_DataRateUnitEEnum,
                "kbitPerSecond", 2, "kbitPerSecond");
    }

    {
        // MbitPerSecond
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_DataRateUnitEEnum,
                "MbitPerSecond", 3, "MbitPerSecond");
    }

    {
        // GbitPerSecond
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_DataRateUnitEEnum,
                "GbitPerSecond", 4, "GbitPerSecond");
    }

    {
        // TbitPerSecond
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_DataRateUnitEEnum,
                "TbitPerSecond", 5, "TbitPerSecond");
    }

    {
        // KibitPerSecond
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_DataRateUnitEEnum,
                "KibitPerSecond", 6, "KibitPerSecond");
    }

    {
        // MibitPerSecond
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_DataRateUnitEEnum,
                "MibitPerSecond", 7, "MibitPerSecond");
    }

    {
        // GibitPerSecond
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_DataRateUnitEEnum,
                "GibitPerSecond", 8, "GibitPerSecond");
    }

    {
        // TibitPerSecond
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_DataRateUnitEEnum,
                "TibitPerSecond", 9, "TibitPerSecond");
    }

    {
        // BPerSecond
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_DataRateUnitEEnum,
                "BPerSecond", 10, "BPerSecond");
    }

    {
        // kBPerSecond
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_DataRateUnitEEnum,
                "kBPerSecond", 11, "kBPerSecond");
    }

    {
        // MBPerSecond
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_DataRateUnitEEnum,
                "MBPerSecond", 12, "MBPerSecond");
    }

    {
        // GBPerSecond
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_DataRateUnitEEnum,
                "GBPerSecond", 13, "GBPerSecond");
    }

    {
        // TBPerSecond
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_DataRateUnitEEnum,
                "TBPerSecond", 14, "TBPerSecond");
    }

    {
        // KiBPerSecond
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_DataRateUnitEEnum,
                "KiBPerSecond", 15, "KiBPerSecond");
    }

    {
        // MiBPerSecond
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_DataRateUnitEEnum,
                "MiBPerSecond", 16, "MiBPerSecond");
    }

    {
        // GiBPerSecond
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_DataRateUnitEEnum,
                "GiBPerSecond", 17, "GiBPerSecond");
    }

    {
        // TiBPerSecond
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_DataRateUnitEEnum,
                "TiBPerSecond", 18, "TiBPerSecond");
    }

    // SamplingType
    m_SamplingTypeEEnum->setName("SamplingType");
    m_SamplingTypeEEnum->setSerializable(true);

    {
        // default
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_SamplingTypeEEnum,
                "default", 0, "default");
    }

    {
        // BestCase
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_SamplingTypeEEnum,
                "BestCase", 1, "BestCase");
    }

    {
        // WorstCase
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_SamplingTypeEEnum,
                "WorstCase", 2, "WorstCase");
    }

    {
        // AverageCase
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_SamplingTypeEEnum,
                "AverageCase", 3, "AverageCase");
    }

    {
        // CornerCase
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_SamplingTypeEEnum,
                "CornerCase", 4, "CornerCase");
    }

    {
        // Uniform
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_SamplingTypeEEnum,
                "Uniform", 5, "Uniform");
    }

    // InterfaceKind
    m_InterfaceKindEEnum->setName("InterfaceKind");
    m_InterfaceKindEEnum->setSerializable(true);

    {
        // _undefined_
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_InterfaceKindEEnum,
                "_undefined_", 0, "_undefined_");
    }

    {
        // provides
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_InterfaceKindEEnum,
                "provides", 1, "provides");
    }

    {
        // requires
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_InterfaceKindEEnum,
                "requires", 2, "requires");
    }

    {
        // provides_requires
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_InterfaceKindEEnum,
                "provides_requires", 3, "provides_requires");
    }

    // RunnableOrderType
    m_RunnableOrderTypeEEnum->setName("RunnableOrderType");
    m_RunnableOrderTypeEEnum->setSerializable(true);

    {
        // _undefined_
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(
                m_RunnableOrderTypeEEnum, "_undefined_", 0, "_undefined_");
    }

    {
        // successor
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(
                m_RunnableOrderTypeEEnum, "successor", 1, "successor");
    }

    {
        // immediateSuccessorStartSequence
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(
                m_RunnableOrderTypeEEnum, "immediateSuccessorStartSequence", 2,
                "immediateSuccessorStartSequence");
    }

    {
        // immediateSuccessorAnySequence
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(
                m_RunnableOrderTypeEEnum, "immediateSuccessorAnySequence", 3,
                "immediateSuccessorAnySequence");
    }

    {
        // immediateSuccessorEndSequence
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(
                m_RunnableOrderTypeEEnum, "immediateSuccessorEndSequence", 4,
                "immediateSuccessorEndSequence");
    }

    // EventChainItemType
    m_EventChainItemTypeEEnum->setName("EventChainItemType");
    m_EventChainItemTypeEEnum->setSerializable(true);

    {
        // _undefined_
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(
                m_EventChainItemTypeEEnum, "_undefined_", 0, "_undefined_");
    }

    {
        // sequence
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(
                m_EventChainItemTypeEEnum, "sequence", 1, "sequence");
    }

    {
        // parallel
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(
                m_EventChainItemTypeEEnum, "parallel", 2, "parallel");
    }

    // SynchronizationType
    m_SynchronizationTypeEEnum->setName("SynchronizationType");
    m_SynchronizationTypeEEnum->setSerializable(true);

    {
        // _undefined_
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(
                m_SynchronizationTypeEEnum, "_undefined_", 0, "_undefined_");
    }

    {
        // Stimulus
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(
                m_SynchronizationTypeEEnum, "Stimulus", 1, "Stimulus");
    }

    {
        // Response
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(
                m_SynchronizationTypeEEnum, "Response", 2, "Response");
    }

    // MappingType
    m_MappingTypeEEnum->setName("MappingType");
    m_MappingTypeEEnum->setSerializable(true);

    {
        // _undefined_
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_MappingTypeEEnum,
                "_undefined_", 0, "_undefined_");
    }

    {
        // OneToOne
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_MappingTypeEEnum,
                "OneToOne", 1, "OneToOne");
    }

    {
        // Reaction
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_MappingTypeEEnum,
                "Reaction", 2, "Reaction");
    }

    {
        // UniqueReaction
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_MappingTypeEEnum,
                "UniqueReaction", 3, "UniqueReaction");
    }

    // LatencyType
    m_LatencyTypeEEnum->setName("LatencyType");
    m_LatencyTypeEEnum->setSerializable(true);

    {
        // _undefined_
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_LatencyTypeEEnum,
                "_undefined_", 0, "_undefined_");
    }

    {
        // Age
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_LatencyTypeEEnum,
                "Age", 1, "Age");
    }

    {
        // Reaction
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_LatencyTypeEEnum,
                "Reaction", 2, "Reaction");
    }

    // Severity
    m_SeverityEEnum->setName("Severity");
    m_SeverityEEnum->setSerializable(true);

    {
        // _undefined_
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_SeverityEEnum,
                "_undefined_", 0, "_undefined_");
    }

    {
        // Cosmetic
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_SeverityEEnum,
                "Cosmetic", 1, "Cosmetic");
    }

    {
        // Minor
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_SeverityEEnum,
                "Minor", 2, "Minor");
    }

    {
        // Major
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_SeverityEEnum,
                "Major", 3, "Major");
    }

    {
        // Critical
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_SeverityEEnum,
                "Critical", 4, "Critical");
    }

    // LimitType
    m_LimitTypeEEnum->setName("LimitType");
    m_LimitTypeEEnum->setSerializable(true);

    {
        // _undefined_
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_LimitTypeEEnum,
                "_undefined_", 0, "_undefined_");
    }

    {
        // UpperLimit
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_LimitTypeEEnum,
                "UpperLimit", 1, "UpperLimit");
    }

    {
        // LowerLimit
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_LimitTypeEEnum,
                "LowerLimit", 2, "LowerLimit");
    }

    // TimeMetric
    m_TimeMetricEEnum->setName("TimeMetric");
    m_TimeMetricEEnum->setSerializable(true);

    {
        // _undefined_
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_TimeMetricEEnum,
                "_undefined_", 0, "_undefined_");
    }

    {
        // ActivateToActivate
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_TimeMetricEEnum,
                "ActivateToActivate", 1, "ActivateToActivate");
    }

    {
        // CoreExecutionTime
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_TimeMetricEEnum,
                "CoreExecutionTime", 2, "CoreExecutionTime");
    }

    {
        // EndToEnd
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_TimeMetricEEnum,
                "EndToEnd", 3, "EndToEnd");
    }

    {
        // EndToStart
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_TimeMetricEEnum,
                "EndToStart", 4, "EndToStart");
    }

    {
        // GrossExecutionTime
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_TimeMetricEEnum,
                "GrossExecutionTime", 5, "GrossExecutionTime");
    }

    {
        // Lateness
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_TimeMetricEEnum,
                "Lateness", 6, "Lateness");
    }

    {
        // MemoryAccessTime
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_TimeMetricEEnum,
                "MemoryAccessTime", 7, "MemoryAccessTime");
    }

    {
        // NetExecutionTime
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_TimeMetricEEnum,
                "NetExecutionTime", 8, "NetExecutionTime");
    }

    {
        // OsOverhead
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_TimeMetricEEnum,
                "OsOverhead", 9, "OsOverhead");
    }

    {
        // ParkingTime
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_TimeMetricEEnum,
                "ParkingTime", 10, "ParkingTime");
    }

    {
        // PollingTime
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_TimeMetricEEnum,
                "PollingTime", 11, "PollingTime");
    }

    {
        // ReadyTime
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_TimeMetricEEnum,
                "ReadyTime", 12, "ReadyTime");
    }

    {
        // ResponseTime
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_TimeMetricEEnum,
                "ResponseTime", 13, "ResponseTime");
    }

    {
        // RunningTime
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_TimeMetricEEnum,
                "RunningTime", 14, "RunningTime");
    }

    {
        // StartDelay
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_TimeMetricEEnum,
                "StartDelay", 15, "StartDelay");
    }

    {
        // StartToStart
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_TimeMetricEEnum,
                "StartToStart", 16, "StartToStart");
    }

    {
        // WaitingTime
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_TimeMetricEEnum,
                "WaitingTime", 17, "WaitingTime");
    }

    // CountMetric
    m_CountMetricEEnum->setName("CountMetric");
    m_CountMetricEEnum->setSerializable(true);

    {
        // _undefined_
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_CountMetricEEnum,
                "_undefined_", 0, "_undefined_");
    }

    {
        // Activations
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_CountMetricEEnum,
                "Activations", 1, "Activations");
    }

    {
        // BoundedMigrations
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_CountMetricEEnum,
                "BoundedMigrations", 2, "BoundedMigrations");
    }

    {
        // CacheHit
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_CountMetricEEnum,
                "CacheHit", 3, "CacheHit");
    }

    {
        // CacheMiss
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_CountMetricEEnum,
                "CacheMiss", 4, "CacheMiss");
    }

    {
        // FullMigrations
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_CountMetricEEnum,
                "FullMigrations", 5, "FullMigrations");
    }

    {
        // MtaLimitExceeding
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_CountMetricEEnum,
                "MtaLimitExceeding", 6, "MtaLimitExceeding");
    }

    {
        // Preemptions
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_CountMetricEEnum,
                "Preemptions", 7, "Preemptions");
    }

    // PercentageMetric
    m_PercentageMetricEEnum->setName("PercentageMetric");
    m_PercentageMetricEEnum->setSerializable(true);

    {
        // _undefined_
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_PercentageMetricEEnum,
                "_undefined_", 0, "_undefined_");
    }

    {
        // CacheHitRatio
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_PercentageMetricEEnum,
                "CacheHitRatio", 1, "CacheHitRatio");
    }

    {
        // CacheMissRatio
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_PercentageMetricEEnum,
                "CacheMissRatio", 2, "CacheMissRatio");
    }

    {
        // CoreExecutionTimeRelative
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_PercentageMetricEEnum,
                "CoreExecutionTimeRelative", 3, "CoreExecutionTimeRelative");
    }

    {
        // MemoryAccessTimeRelative
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_PercentageMetricEEnum,
                "MemoryAccessTimeRelative", 4, "MemoryAccessTimeRelative");
    }

    {
        // NormalizedLateness
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_PercentageMetricEEnum,
                "NormalizedLateness", 5, "NormalizedLateness");
    }

    {
        // NormalizedResponseTime
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_PercentageMetricEEnum,
                "NormalizedResponseTime", 6, "NormalizedResponseTime");
    }

    {
        // OsOverheadRelative
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_PercentageMetricEEnum,
                "OsOverheadRelative", 7, "OsOverheadRelative");
    }

    // CPUPercentageMetric
    m_CPUPercentageMetricEEnum->setName("CPUPercentageMetric");
    m_CPUPercentageMetricEEnum->setSerializable(true);

    {
        // _undefined_
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(
                m_CPUPercentageMetricEEnum, "_undefined_", 0, "_undefined_");
    }

    {
        // CPUBuffering
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(
                m_CPUPercentageMetricEEnum, "CPUBuffering", 1, "CPUBuffering");
    }

    {
        // CPULoad
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(
                m_CPUPercentageMetricEEnum, "CPULoad", 2, "CPULoad");
    }

    {
        // CPUParking
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(
                m_CPUPercentageMetricEEnum, "CPUParking", 3, "CPUParking");
    }

    {
        // CPUPolling
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(
                m_CPUPercentageMetricEEnum, "CPUPolling", 4, "CPUPolling");
    }

    {
        // CPUReady
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(
                m_CPUPercentageMetricEEnum, "CPUReady", 5, "CPUReady");
    }

    {
        // CPURunning
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(
                m_CPUPercentageMetricEEnum, "CPURunning", 6, "CPURunning");
    }

    {
        // CPUWaiting
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(
                m_CPUPercentageMetricEEnum, "CPUWaiting", 7, "CPUWaiting");
    }

    // FrequencyMetric
    m_FrequencyMetricEEnum->setName("FrequencyMetric");
    m_FrequencyMetricEEnum->setSerializable(true);

    {
        // _undefined_
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_FrequencyMetricEEnum,
                "_undefined_", 0, "_undefined_");
    }

    {
        // CacheHitFrequency
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_FrequencyMetricEEnum,
                "CacheHitFrequency", 1, "CacheHitFrequency");
    }

    {
        // CacheMissFrequency
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_FrequencyMetricEEnum,
                "CacheMissFrequency", 2, "CacheMissFrequency");
    }

    // CoherencyDirection
    m_CoherencyDirectionEEnum->setName("CoherencyDirection");
    m_CoherencyDirectionEEnum->setSerializable(true);

    {
        // _undefined_
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(
                m_CoherencyDirectionEEnum, "_undefined_", 0, "_undefined_");
    }

    {
        // input
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(
                m_CoherencyDirectionEEnum, "input", 1, "input");
    }

    {
        // output
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(
                m_CoherencyDirectionEEnum, "output", 2, "output");
    }

    // ProcessEventType
    m_ProcessEventTypeEEnum->setName("ProcessEventType");
    m_ProcessEventTypeEEnum->setSerializable(true);

    {
        // _all_
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_ProcessEventTypeEEnum,
                "_all_", 0, "_all_");
    }

    {
        // activate
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_ProcessEventTypeEEnum,
                "activate", 1, "activate");
    }

    {
        // start
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_ProcessEventTypeEEnum,
                "start", 2, "start");
    }

    {
        // resume
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_ProcessEventTypeEEnum,
                "resume", 3, "resume");
    }

    {
        // preempt
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_ProcessEventTypeEEnum,
                "preempt", 4, "preempt");
    }

    {
        // poll
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_ProcessEventTypeEEnum,
                "poll", 5, "poll");
    }

    {
        // run
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_ProcessEventTypeEEnum,
                "run", 6, "run");
    }

    {
        // wait
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_ProcessEventTypeEEnum,
                "wait", 7, "wait");
    }

    {
        // poll_parking
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_ProcessEventTypeEEnum,
                "poll_parking", 8, "poll_parking");
    }

    {
        // park
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_ProcessEventTypeEEnum,
                "park", 9, "park");
    }

    {
        // release_parking
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_ProcessEventTypeEEnum,
                "release_parking", 10, "release_parking");
    }

    {
        // release
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_ProcessEventTypeEEnum,
                "release", 11, "release");
    }

    {
        // terminate
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_ProcessEventTypeEEnum,
                "terminate", 12, "terminate");
    }

    // RunnableEventType
    m_RunnableEventTypeEEnum->setName("RunnableEventType");
    m_RunnableEventTypeEEnum->setSerializable(true);

    {
        // _all_
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(
                m_RunnableEventTypeEEnum, "_all_", 0, "_all_");
    }

    {
        // start
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(
                m_RunnableEventTypeEEnum, "start", 1, "start");
    }

    {
        // suspend
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(
                m_RunnableEventTypeEEnum, "suspend", 2, "suspend");
    }

    {
        // resume
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(
                m_RunnableEventTypeEEnum, "resume", 3, "resume");
    }

    {
        // terminate
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(
                m_RunnableEventTypeEEnum, "terminate", 4, "terminate");
    }

    // LabelEventType
    m_LabelEventTypeEEnum->setName("LabelEventType");
    m_LabelEventTypeEEnum->setSerializable(true);

    {
        // _all_
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_LabelEventTypeEEnum,
                "_all_", 0, "_all_");
    }

    {
        // read
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_LabelEventTypeEEnum,
                "read", 1, "read");
    }

    {
        // write
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_LabelEventTypeEEnum,
                "write", 2, "write");
    }

    // ChannelEventType
    m_ChannelEventTypeEEnum->setName("ChannelEventType");
    m_ChannelEventTypeEEnum->setSerializable(true);

    {
        // _all_
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_ChannelEventTypeEEnum,
                "_all_", 0, "_all_");
    }

    {
        // send
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_ChannelEventTypeEEnum,
                "send", 1, "send");
    }

    {
        // receive
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_ChannelEventTypeEEnum,
                "receive", 2, "receive");
    }

    // SemaphoreEventType
    m_SemaphoreEventTypeEEnum->setName("SemaphoreEventType");
    m_SemaphoreEventTypeEEnum->setSerializable(true);

    {
        // _all_
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(
                m_SemaphoreEventTypeEEnum, "_all_", 0, "_all_");
    }

    {
        // lock
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(
                m_SemaphoreEventTypeEEnum, "lock", 1, "lock");
    }

    {
        // unlock
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(
                m_SemaphoreEventTypeEEnum, "unlock", 2, "unlock");
    }

    // ComponentEventType
    m_ComponentEventTypeEEnum->setName("ComponentEventType");
    m_ComponentEventTypeEEnum->setSerializable(true);

    {
        // _all_
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(
                m_ComponentEventTypeEEnum, "_all_", 0, "_all_");
    }

    {
        // start
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(
                m_ComponentEventTypeEEnum, "start", 1, "start");
    }

    {
        // end
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(
                m_ComponentEventTypeEEnum, "end", 2, "end");
    }

    // MemoryType
    m_MemoryTypeEEnum->setName("MemoryType");
    m_MemoryTypeEEnum->setSerializable(true);

    {
        // _undefined_
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_MemoryTypeEEnum,
                "_undefined_", 0, "_undefined_");
    }

    {
        // DRAM
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_MemoryTypeEEnum,
                "DRAM", 1, "DRAM");
    }

    {
        // SRAM
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_MemoryTypeEEnum,
                "SRAM", 2, "SRAM");
    }

    {
        // FLASH
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_MemoryTypeEEnum,
                "FLASH", 3, "FLASH");
    }

    {
        // PCM
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_MemoryTypeEEnum,
                "PCM", 4, "PCM");
    }

    // StructureType
    m_StructureTypeEEnum->setName("StructureType");
    m_StructureTypeEEnum->setSerializable(true);

    {
        // _undefined_
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_StructureTypeEEnum,
                "_undefined_", 0, "_undefined_");
    }

    {
        // System
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_StructureTypeEEnum,
                "System", 1, "System");
    }

    {
        // ECU
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_StructureTypeEEnum,
                "ECU", 2, "ECU");
    }

    {
        // Microcontroller
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_StructureTypeEEnum,
                "Microcontroller", 3, "Microcontroller");
    }

    {
        // SoC
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_StructureTypeEEnum,
                "SoC", 4, "SoC");
    }

    {
        // Cluster
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_StructureTypeEEnum,
                "Cluster", 5, "Cluster");
    }

    {
        // Group
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_StructureTypeEEnum,
                "Group", 6, "Group");
    }

    {
        // Array
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_StructureTypeEEnum,
                "Array", 7, "Array");
    }

    {
        // Area
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_StructureTypeEEnum,
                "Area", 8, "Area");
    }

    {
        // Region
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_StructureTypeEEnum,
                "Region", 9, "Region");
    }

    // CacheType
    m_CacheTypeEEnum->setName("CacheType");
    m_CacheTypeEEnum->setSerializable(true);

    {
        // _undefined_
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_CacheTypeEEnum,
                "_undefined_", 0, "_undefined_");
    }

    {
        // instruction
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_CacheTypeEEnum,
                "instruction", 1, "instruction");
    }

    {
        // data
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_CacheTypeEEnum,
                "data", 2, "data");
    }

    {
        // unified
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_CacheTypeEEnum,
                "unified", 3, "unified");
    }

    // PortType
    m_PortTypeEEnum->setName("PortType");
    m_PortTypeEEnum->setSerializable(true);

    {
        // _undefined_
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_PortTypeEEnum,
                "_undefined_", 0, "_undefined_");
    }

    {
        // initiator
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_PortTypeEEnum,
                "initiator", 1, "initiator");
    }

    {
        // responder
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_PortTypeEEnum,
                "responder", 2, "responder");
    }

    // SchedPolicy
    m_SchedPolicyEEnum->setName("SchedPolicy");
    m_SchedPolicyEEnum->setSerializable(true);

    {
        // _undefined_
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_SchedPolicyEEnum,
                "_undefined_", 0, "_undefined_");
    }

    {
        // RoundRobin
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_SchedPolicyEEnum,
                "RoundRobin", 1, "RoundRobin");
    }

    {
        // FCFS
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_SchedPolicyEEnum,
                "FCFS", 2, "FCFS");
    }

    {
        // PriorityBased
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_SchedPolicyEEnum,
                "PriorityBased", 3, "PriorityBased");
    }

    // WriteStrategy
    m_WriteStrategyEEnum->setName("WriteStrategy");
    m_WriteStrategyEEnum->setSerializable(true);

    {
        // _undefined_
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_WriteStrategyEEnum,
                "_undefined_", 0, "_undefined_");
    }

    {
        // none
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_WriteStrategyEEnum,
                "none", 1, "none");
    }

    {
        // writeback
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_WriteStrategyEEnum,
                "writeback", 2, "writeback");
    }

    {
        // writethrough
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_WriteStrategyEEnum,
                "writethrough", 3, "writethrough");
    }

    // PuType
    m_PuTypeEEnum->setName("PuType");
    m_PuTypeEEnum->setSerializable(true);

    {
        // _undefined_
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_PuTypeEEnum,
                "_undefined_", 0, "_undefined_");
    }

    {
        // GPU
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_PuTypeEEnum, "GPU", 1,
                "GPU");
    }

    {
        // CPU
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_PuTypeEEnum, "CPU", 2,
                "CPU");
    }

    {
        // Accelerator
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_PuTypeEEnum,
                "Accelerator", 3, "Accelerator");
    }

    // PortInterface
    m_PortInterfaceEEnum->setName("PortInterface");
    m_PortInterfaceEEnum->setSerializable(true);

    {
        // _undefined_
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_PortInterfaceEEnum,
                "_undefined_", 0, "_undefined_");
    }

    {
        // custom
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_PortInterfaceEEnum,
                "custom", 1, "custom");
    }

    {
        // CAN
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_PortInterfaceEEnum,
                "CAN", 2, "CAN");
    }

    {
        // Flexray
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_PortInterfaceEEnum,
                "Flexray", 3, "Flexray");
    }

    {
        // LIN
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_PortInterfaceEEnum,
                "LIN", 4, "LIN");
    }

    {
        // MOST
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_PortInterfaceEEnum,
                "MOST", 5, "MOST");
    }

    {
        // Ethernet
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_PortInterfaceEEnum,
                "Ethernet", 6, "Ethernet");
    }

    {
        // SPI
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_PortInterfaceEEnum,
                "SPI", 7, "SPI");
    }

    {
        // I2C
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_PortInterfaceEEnum,
                "I2C", 8, "I2C");
    }

    {
        // AXI
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_PortInterfaceEEnum,
                "AXI", 9, "AXI");
    }

    {
        // AHB
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_PortInterfaceEEnum,
                "AHB", 10, "AHB");
    }

    {
        // APB
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_PortInterfaceEEnum,
                "APB", 11, "APB");
    }

    {
        // SWR
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_PortInterfaceEEnum,
                "SWR", 12, "SWR");
    }

    // HwFeatureType
    m_HwFeatureTypeEEnum->setName("HwFeatureType");
    m_HwFeatureTypeEEnum->setSerializable(true);

    {
        // _undefined_
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_HwFeatureTypeEEnum,
                "_undefined_", 0, "_undefined_");
    }

    {
        // performance
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_HwFeatureTypeEEnum,
                "performance", 1, "performance");
    }

    {
        // power
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_HwFeatureTypeEEnum,
                "power", 2, "power");
    }

    {
        // performance_and_power
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_HwFeatureTypeEEnum,
                "performance_and_power", 3, "performance_and_power");
    }

    // MemoryAddressMappingType
    m_MemoryAddressMappingTypeEEnum->setName("MemoryAddressMappingType");
    m_MemoryAddressMappingTypeEEnum->setSerializable(true);

    {
        // _undefined_
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(
                m_MemoryAddressMappingTypeEEnum, "_undefined_", 0,
                "_undefined_");
    }

    {
        // none
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(
                m_MemoryAddressMappingTypeEEnum, "none", 1, "none");
    }

    {
        // address
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(
                m_MemoryAddressMappingTypeEEnum, "address", 2, "address");
    }

    {
        // offset
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(
                m_MemoryAddressMappingTypeEEnum, "offset", 3, "offset");
    }

    // OsDataConsistencyMode
    m_OsDataConsistencyModeEEnum->setName("OsDataConsistencyMode");
    m_OsDataConsistencyModeEEnum->setSerializable(true);

    {
        // _undefined_
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(
                m_OsDataConsistencyModeEEnum, "_undefined_", 0, "_undefined_");
    }

    {
        // noProtection
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(
                m_OsDataConsistencyModeEEnum, "noProtection", 1,
                "noProtection");
    }

    {
        // automaticProtection
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(
                m_OsDataConsistencyModeEEnum, "automaticProtection", 2,
                "automaticProtection");
    }

    {
        // customProtection
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(
                m_OsDataConsistencyModeEEnum, "customProtection", 3,
                "customProtection");
    }

    {
        // handledByModelElements
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(
                m_OsDataConsistencyModeEEnum, "handledByModelElements", 4,
                "handledByModelElements");
    }

    // AccessMultiplicity
    m_AccessMultiplicityEEnum->setName("AccessMultiplicity");
    m_AccessMultiplicityEEnum->setSerializable(true);

    {
        // _undefined_
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(
                m_AccessMultiplicityEEnum, "_undefined_", 0, "_undefined_");
    }

    {
        // singleAccess
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(
                m_AccessMultiplicityEEnum, "singleAccess", 1, "singleAccess");
    }

    {
        // multipleAccesses
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(
                m_AccessMultiplicityEEnum, "multipleAccesses", 2,
                "multipleAccesses");
    }

    // DataStabilityLevel
    m_DataStabilityLevelEEnum->setName("DataStabilityLevel");
    m_DataStabilityLevelEEnum->setSerializable(true);

    {
        // _undefined_
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(
                m_DataStabilityLevelEEnum, "_undefined_", 0, "_undefined_");
    }

    {
        // period
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(
                m_DataStabilityLevelEEnum, "period", 1, "period");
    }

    {
        // process
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(
                m_DataStabilityLevelEEnum, "process", 2, "process");
    }

    {
        // scheduleSection
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(
                m_DataStabilityLevelEEnum, "scheduleSection", 3,
                "scheduleSection");
    }

    {
        // runnable
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(
                m_DataStabilityLevelEEnum, "runnable", 4, "runnable");
    }

    // SemaphoreType
    m_SemaphoreTypeEEnum->setName("SemaphoreType");
    m_SemaphoreTypeEEnum->setSerializable(true);

    {
        // _undefined_
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_SemaphoreTypeEEnum,
                "_undefined_", 0, "_undefined_");
    }

    {
        // CountingSemaphore
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_SemaphoreTypeEEnum,
                "CountingSemaphore", 1, "CountingSemaphore");
    }

    {
        // Resource
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_SemaphoreTypeEEnum,
                "Resource", 2, "Resource");
    }

    {
        // Spinlock
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_SemaphoreTypeEEnum,
                "Spinlock", 3, "Spinlock");
    }

    // Condition
    m_ConditionEEnum->setName("Condition");
    m_ConditionEEnum->setSerializable(true);

    {
        // _undefined_
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_ConditionEEnum,
                "_undefined_", 0, "_undefined_");
    }

    {
        // requires
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_ConditionEEnum,
                "requires", 1, "requires");
    }

    {
        // excludes
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_ConditionEEnum,
                "excludes", 2, "excludes");
    }

    // GroupingType
    m_GroupingTypeEEnum->setName("GroupingType");
    m_GroupingTypeEEnum->setSerializable(true);

    {
        // _undefined_
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_GroupingTypeEEnum,
                "_undefined_", 0, "_undefined_");
    }

    {
        // allOfThem
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_GroupingTypeEEnum,
                "allOfThem", 1, "allOfThem");
    }

    {
        // atLeastOneOfThem
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_GroupingTypeEEnum,
                "atLeastOneOfThem", 2, "atLeastOneOfThem");
    }

    // CurveType
    m_CurveTypeEEnum->setName("CurveType");
    m_CurveTypeEEnum->setSerializable(true);

    {
        // _undefined_
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_CurveTypeEEnum,
                "_undefined_", 0, "_undefined_");
    }

    {
        // sine
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_CurveTypeEEnum,
                "sine", 1, "sine");
    }

    {
        // triangle
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_CurveTypeEEnum,
                "triangle", 2, "triangle");
    }

    // WaitEventType
    m_WaitEventTypeEEnum->setName("WaitEventType");
    m_WaitEventTypeEEnum->setSerializable(true);

    {
        // _undefined_
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_WaitEventTypeEEnum,
                "_undefined_", 0, "_undefined_");
    }

    {
        // AND
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_WaitEventTypeEEnum,
                "AND", 1, "AND");
    }

    {
        // OR
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_WaitEventTypeEEnum,
                "OR", 2, "OR");
    }

    // WaitingBehaviour
    m_WaitingBehaviourEEnum->setName("WaitingBehaviour");
    m_WaitingBehaviourEEnum->setSerializable(true);

    {
        // _undefined_
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_WaitingBehaviourEEnum,
                "_undefined_", 0, "_undefined_");
    }

    {
        // active
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_WaitingBehaviourEEnum,
                "active", 1, "active");
    }

    {
        // passive
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_WaitingBehaviourEEnum,
                "passive", 2, "passive");
    }

    // ISRCategory
    m_ISRCategoryEEnum->setName("ISRCategory");
    m_ISRCategoryEEnum->setSerializable(true);

    {
        // _undefined_
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_ISRCategoryEEnum,
                "_undefined_", 0, "_undefined_");
    }

    {
        // CATEGORY_1
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_ISRCategoryEEnum,
                "CATEGORY_1", 1, "CATEGORY_1");
    }

    {
        // CATEGORY_2
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_ISRCategoryEEnum,
                "CATEGORY_2", 2, "CATEGORY_2");
    }

    // AccessPrecedenceType
    m_AccessPrecedenceTypeEEnum->setName("AccessPrecedenceType");
    m_AccessPrecedenceTypeEEnum->setSerializable(true);

    {
        // _undefined_
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(
                m_AccessPrecedenceTypeEEnum, "_undefined_", 0, "_undefined_");
    }

    {
        // defaultWR
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(
                m_AccessPrecedenceTypeEEnum, "defaultWR", 1, "defaultWR");
    }

    {
        // ignoreWR
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(
                m_AccessPrecedenceTypeEEnum, "ignoreWR", 2, "ignoreWR");
    }

    {
        // enforceRW
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(
                m_AccessPrecedenceTypeEEnum, "enforceRW", 3, "enforceRW");
    }

    // OrderType
    m_OrderTypeEEnum->setName("OrderType");
    m_OrderTypeEEnum->setSerializable(true);

    {
        // _undefined_
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_OrderTypeEEnum,
                "_undefined_", 0, "_undefined_");
    }

    {
        // order
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_OrderTypeEEnum,
                "order", 1, "order");
    }

    {
        // directOrder
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_OrderTypeEEnum,
                "directOrder", 2, "directOrder");
    }

    {
        // startSequence
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_OrderTypeEEnum,
                "startSequence", 3, "startSequence");
    }

    {
        // endSequence
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_OrderTypeEEnum,
                "endSequence", 4, "endSequence");
    }

    // DirectionType
    m_DirectionTypeEEnum->setName("DirectionType");
    m_DirectionTypeEEnum->setSerializable(true);

    {
        // _undefined_
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_DirectionTypeEEnum,
                "_undefined_", 0, "_undefined_");
    }

    {
        // in
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_DirectionTypeEEnum,
                "in", 1, "in");
    }

    {
        // out
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_DirectionTypeEEnum,
                "out", 2, "out");
    }

    {
        // inout
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_DirectionTypeEEnum,
                "inout", 3, "inout");
    }

    // LabelDataStability
    m_LabelDataStabilityEEnum->setName("LabelDataStability");
    m_LabelDataStabilityEEnum->setSerializable(true);

    {
        // _undefined_
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(
                m_LabelDataStabilityEEnum, "_undefined_", 0, "_undefined_");
    }

    {
        // noProtection
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(
                m_LabelDataStabilityEEnum, "noProtection", 1, "noProtection");
    }

    {
        // automaticProtection
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(
                m_LabelDataStabilityEEnum, "automaticProtection", 2,
                "automaticProtection");
    }

    {
        // customProtection
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(
                m_LabelDataStabilityEEnum, "customProtection", 3,
                "customProtection");
    }

    {
        // handledByModelElements
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(
                m_LabelDataStabilityEEnum, "handledByModelElements", 4,
                "handledByModelElements");
    }

    // ModeLabelAccessEnum
    m_ModeLabelAccessEnumEEnum->setName("ModeLabelAccessEnum");
    m_ModeLabelAccessEnumEEnum->setSerializable(true);

    {
        // _undefined_
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(
                m_ModeLabelAccessEnumEEnum, "_undefined_", 0, "_undefined_");
    }

    {
        // read
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(
                m_ModeLabelAccessEnumEEnum, "read", 1, "read");
    }

    {
        // set
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(
                m_ModeLabelAccessEnumEEnum, "set", 2, "set");
    }

    {
        // increment
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(
                m_ModeLabelAccessEnumEEnum, "increment", 3, "increment");
    }

    {
        // decrement
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(
                m_ModeLabelAccessEnumEEnum, "decrement", 4, "decrement");
    }

    // ReceiveOperation
    m_ReceiveOperationEEnum->setName("ReceiveOperation");
    m_ReceiveOperationEEnum->setSerializable(true);

    {
        // _undefined_
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_ReceiveOperationEEnum,
                "_undefined_", 0, "_undefined_");
    }

    {
        // FIFO_Read
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_ReceiveOperationEEnum,
                "FIFO_Read", 1, "FIFO_Read");
    }

    {
        // FIFO_Take
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_ReceiveOperationEEnum,
                "FIFO_Take", 2, "FIFO_Take");
    }

    {
        // LIFO_Read
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_ReceiveOperationEEnum,
                "LIFO_Read", 3, "LIFO_Read");
    }

    {
        // LIFO_Take
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_ReceiveOperationEEnum,
                "LIFO_Take", 4, "LIFO_Take");
    }

    // LabelAccessDataStability
    m_LabelAccessDataStabilityEEnum->setName("LabelAccessDataStability");
    m_LabelAccessDataStabilityEEnum->setSerializable(true);

    {
        // _undefined_
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(
                m_LabelAccessDataStabilityEEnum, "_undefined_", 0,
                "_undefined_");
    }

    {
        // inherited
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(
                m_LabelAccessDataStabilityEEnum, "inherited", 1, "inherited");
    }

    {
        // noProtection
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(
                m_LabelAccessDataStabilityEEnum, "noProtection", 2,
                "noProtection");
    }

    {
        // automaticProtection
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(
                m_LabelAccessDataStabilityEEnum, "automaticProtection", 3,
                "automaticProtection");
    }

    {
        // customProtection
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(
                m_LabelAccessDataStabilityEEnum, "customProtection", 4,
                "customProtection");
    }

    {
        // handledByModelElements
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(
                m_LabelAccessDataStabilityEEnum, "handledByModelElements", 5,
                "handledByModelElements");
    }

    // LabelAccessEnum
    m_LabelAccessEnumEEnum->setName("LabelAccessEnum");
    m_LabelAccessEnumEEnum->setSerializable(true);

    {
        // _undefined_
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_LabelAccessEnumEEnum,
                "_undefined_", 0, "_undefined_");
    }

    {
        // read
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_LabelAccessEnumEEnum,
                "read", 1, "read");
    }

    {
        // write
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_LabelAccessEnumEEnum,
                "write", 2, "write");
    }

    // LabelAccessImplementation
    m_LabelAccessImplementationEEnum->setName("LabelAccessImplementation");
    m_LabelAccessImplementationEEnum->setSerializable(true);

    {
        // _undefined_
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(
                m_LabelAccessImplementationEEnum, "_undefined_", 0,
                "_undefined_");
    }

    {
        // explicit
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(
                m_LabelAccessImplementationEEnum, "explicit", 1, "explicit");
    }

    {
        // implicit
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(
                m_LabelAccessImplementationEEnum, "implicit", 2, "implicit");
    }

    {
        // timed
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(
                m_LabelAccessImplementationEEnum, "timed", 3, "timed");
    }

    // SemaphoreAccessEnum
    m_SemaphoreAccessEnumEEnum->setName("SemaphoreAccessEnum");
    m_SemaphoreAccessEnumEEnum->setSerializable(true);

    {
        // _undefined_
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(
                m_SemaphoreAccessEnumEEnum, "_undefined_", 0, "_undefined_");
    }

    {
        // request
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(
                m_SemaphoreAccessEnumEEnum, "request", 1, "request");
    }

    {
        // exclusive
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(
                m_SemaphoreAccessEnumEEnum, "exclusive", 2, "exclusive");
    }

    {
        // release
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(
                m_SemaphoreAccessEnumEEnum, "release", 3, "release");
    }

    // BlockingType
    m_BlockingTypeEEnum->setName("BlockingType");
    m_BlockingTypeEEnum->setSerializable(true);

    {
        // _undefined_
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_BlockingTypeEEnum,
                "_undefined_", 0, "_undefined_");
    }

    {
        // active_wait
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_BlockingTypeEEnum,
                "active_wait", 1, "active_wait");
    }

    {
        // passive_wait
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_BlockingTypeEEnum,
                "passive_wait", 2, "passive_wait");
    }

    {
        // non_blocking
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_BlockingTypeEEnum,
                "non_blocking", 3, "non_blocking");
    }

    // Preemption
    m_PreemptionEEnum->setName("Preemption");
    m_PreemptionEEnum->setSerializable(true);

    {
        // _undefined_
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_PreemptionEEnum,
                "_undefined_", 0, "_undefined_");
    }

    {
        // preemptive
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_PreemptionEEnum,
                "preemptive", 1, "preemptive");
    }

    {
        // cooperative
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_PreemptionEEnum,
                "cooperative", 2, "cooperative");
    }

    {
        // non_preemptive
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_PreemptionEEnum,
                "non_preemptive", 3, "non_preemptive");
    }

    // ConcurrencyType
    m_ConcurrencyTypeEEnum->setName("ConcurrencyType");
    m_ConcurrencyTypeEEnum->setSerializable(true);

    {
        // _undefined_
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_ConcurrencyTypeEEnum,
                "_undefined_", 0, "_undefined_");
    }

    {
        // SingleCoreSafe
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_ConcurrencyTypeEEnum,
                "SingleCoreSafe", 1, "SingleCoreSafe");
    }

    {
        // MultiCoreSafe
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_ConcurrencyTypeEEnum,
                "MultiCoreSafe", 2, "MultiCoreSafe");
    }

    {
        // SingleCorePrioSafe
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_ConcurrencyTypeEEnum,
                "SingleCorePrioSafe", 3, "SingleCorePrioSafe");
    }

    // ASILType
    m_ASILTypeEEnum->setName("ASILType");
    m_ASILTypeEEnum->setSerializable(true);

    {
        // _undefined_
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_ASILTypeEEnum,
                "_undefined_", 0, "_undefined_");
    }

    {
        // D
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_ASILTypeEEnum, "D", 1,
                "D");
    }

    {
        // C
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_ASILTypeEEnum, "C", 2,
                "C");
    }

    {
        // B
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_ASILTypeEEnum, "B", 3,
                "B");
    }

    {
        // A
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_ASILTypeEEnum, "A", 4,
                "A");
    }

    {
        // QM
        ::ecore::EEnumLiteral_ptr _el = addEEnumLiteral(m_ASILTypeEEnum, "QM",
                5, "QM");
    }

    _initialize();
}

::ecore::EClass_ptr AmaltheaPackage::getAmalthea()
{
    return m_AmaltheaEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getCommonElements()
{
    return m_CommonElementsEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getBaseObject()
{
    return m_BaseObjectEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getReferableObject()
{
    return m_ReferableObjectEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getReferableBaseObject()
{
    return m_ReferableBaseObjectEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getIAnnotatable()
{
    return m_IAnnotatableEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getITaggable()
{
    return m_ITaggableEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getINamed()
{
    return m_INamedEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getIReferable()
{
    return m_IReferableEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getIDisplayName()
{
    return m_IDisplayNameEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getIDescription()
{
    return m_IDescriptionEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getINamespaceMember()
{
    return m_INamespaceMemberEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getTag()
{
    return m_TagEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getNamespace()
{
    return m_NamespaceEClass;
}
::ecore::EEnum_ptr AmaltheaPackage::getRelationalOperator()
{
    return m_RelationalOperatorEEnum;
}
::ecore::EClass_ptr AmaltheaPackage::getClassifier()
{
    return m_ClassifierEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getCoreClassifier()
{
    return m_CoreClassifierEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getMemoryClassifier()
{
    return m_MemoryClassifierEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getTransmissionPolicy()
{
    return m_TransmissionPolicyEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getQuantity()
{
    return m_QuantityEClass;
}
::ecore::EEnum_ptr AmaltheaPackage::getTimeUnit()
{
    return m_TimeUnitEEnum;
}
::ecore::EClass_ptr AmaltheaPackage::getTimeComparable()
{
    return m_TimeComparableEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getTime()
{
    return m_TimeEClass;
}
::ecore::EEnum_ptr AmaltheaPackage::getFrequencyUnit()
{
    return m_FrequencyUnitEEnum;
}
::ecore::EClass_ptr AmaltheaPackage::getFrequency()
{
    return m_FrequencyEClass;
}
::ecore::EEnum_ptr AmaltheaPackage::getVoltageUnit()
{
    return m_VoltageUnitEEnum;
}
::ecore::EClass_ptr AmaltheaPackage::getVoltage()
{
    return m_VoltageEClass;
}
::ecore::EEnum_ptr AmaltheaPackage::getDataSizeUnit()
{
    return m_DataSizeUnitEEnum;
}
::ecore::EClass_ptr AmaltheaPackage::getDataSize()
{
    return m_DataSizeEClass;
}
::ecore::EEnum_ptr AmaltheaPackage::getDataRateUnit()
{
    return m_DataRateUnitEEnum;
}
::ecore::EClass_ptr AmaltheaPackage::getDataRateComparable()
{
    return m_DataRateComparableEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getDataRate()
{
    return m_DataRateEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getCustomProperty()
{
    return m_CustomPropertyEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getValue()
{
    return m_ValueEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getListObject()
{
    return m_ListObjectEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getStringObject()
{
    return m_StringObjectEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getBigIntegerObject()
{
    return m_BigIntegerObjectEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getReferenceObject()
{
    return m_ReferenceObjectEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getIntegerObject()
{
    return m_IntegerObjectEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getLongObject()
{
    return m_LongObjectEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getFloatObject()
{
    return m_FloatObjectEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getDoubleObject()
{
    return m_DoubleObjectEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getBooleanObject()
{
    return m_BooleanObjectEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getNumericStatistic()
{
    return m_NumericStatisticEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getMinAvgMaxStatistic()
{
    return m_MinAvgMaxStatisticEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getSingleValueStatistic()
{
    return m_SingleValueStatisticEClass;
}
::ecore::EEnum_ptr AmaltheaPackage::getSamplingType()
{
    return m_SamplingTypeEEnum;
}
::ecore::EClass_ptr AmaltheaPackage::getITimeDeviation()
{
    return m_ITimeDeviationEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getTimeInterval()
{
    return m_TimeIntervalEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getTimeConstant()
{
    return m_TimeConstantEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getTimeHistogram()
{
    return m_TimeHistogramEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getTimeHistogramEntry()
{
    return m_TimeHistogramEntryEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getBoundedTimeDistribution()
{
    return m_BoundedTimeDistributionEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getTruncatedTimeDistribution()
{
    return m_TruncatedTimeDistributionEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getTimeBoundaries()
{
    return m_TimeBoundariesEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getTimeStatistics()
{
    return m_TimeStatisticsEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getTimeUniformDistribution()
{
    return m_TimeUniformDistributionEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getTimeGaussDistribution()
{
    return m_TimeGaussDistributionEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getTimeWeibullEstimatorsDistribution()
{
    return m_TimeWeibullEstimatorsDistributionEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getTimeBetaDistribution()
{
    return m_TimeBetaDistributionEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getIDiscreteValueDeviation()
{
    return m_IDiscreteValueDeviationEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getDiscreteValueInterval()
{
    return m_DiscreteValueIntervalEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getDiscreteValueConstant()
{
    return m_DiscreteValueConstantEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getDiscreteValueHistogram()
{
    return m_DiscreteValueHistogramEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getDiscreteValueHistogramEntry()
{
    return m_DiscreteValueHistogramEntryEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getBoundedDiscreteValueDistribution()
{
    return m_BoundedDiscreteValueDistributionEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getTruncatedDiscreteValueDistribution()
{
    return m_TruncatedDiscreteValueDistributionEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getDiscreteValueBoundaries()
{
    return m_DiscreteValueBoundariesEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getDiscreteValueStatistics()
{
    return m_DiscreteValueStatisticsEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getDiscreteValueUniformDistribution()
{
    return m_DiscreteValueUniformDistributionEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getDiscreteValueGaussDistribution()
{
    return m_DiscreteValueGaussDistributionEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getDiscreteValueWeibullEstimatorsDistribution()
{
    return m_DiscreteValueWeibullEstimatorsDistributionEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getDiscreteValueBetaDistribution()
{
    return m_DiscreteValueBetaDistributionEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getIContinuousValueDeviation()
{
    return m_IContinuousValueDeviationEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getContinuousValueInterval()
{
    return m_ContinuousValueIntervalEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getContinuousValueConstant()
{
    return m_ContinuousValueConstantEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getContinuousValueHistogram()
{
    return m_ContinuousValueHistogramEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getContinuousValueHistogramEntry()
{
    return m_ContinuousValueHistogramEntryEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getBoundedContinuousValueDistribution()
{
    return m_BoundedContinuousValueDistributionEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getTruncatedContinuousValueDistribution()
{
    return m_TruncatedContinuousValueDistributionEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getContinuousValueBoundaries()
{
    return m_ContinuousValueBoundariesEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getContinuousValueStatistics()
{
    return m_ContinuousValueStatisticsEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getContinuousValueUniformDistribution()
{
    return m_ContinuousValueUniformDistributionEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getContinuousValueGaussDistribution()
{
    return m_ContinuousValueGaussDistributionEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getContinuousValueWeibullEstimatorsDistribution()
{
    return m_ContinuousValueWeibullEstimatorsDistributionEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getContinuousValueBetaDistribution()
{
    return m_ContinuousValueBetaDistributionEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getMode()
{
    return m_ModeEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getNumericMode()
{
    return m_NumericModeEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getEnumMode()
{
    return m_EnumModeEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getModeLiteral()
{
    return m_ModeLiteralEClass;
}
::ecore::EDataType_ptr AmaltheaPackage::getAddress()
{
    return m_AddressEDataType;
}
::ecore::EDataType_ptr AmaltheaPackage::getPositiveInt()
{
    return m_PositiveIntEDataType;
}
::ecore::EDataType_ptr AmaltheaPackage::getPositiveLong()
{
    return m_PositiveLongEDataType;
}
::ecore::EDataType_ptr AmaltheaPackage::getPositiveDouble()
{
    return m_PositiveDoubleEDataType;
}
::ecore::EDataType_ptr AmaltheaPackage::getNonNegativeInt()
{
    return m_NonNegativeIntEDataType;
}
::ecore::EDataType_ptr AmaltheaPackage::getNonNegativeLong()
{
    return m_NonNegativeLongEDataType;
}
::ecore::EDataType_ptr AmaltheaPackage::getNonNegativeDouble()
{
    return m_NonNegativeDoubleEDataType;
}
::ecore::EClass_ptr AmaltheaPackage::getComponentsModel()
{
    return m_ComponentsModelEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getIComponentContainer()
{
    return m_IComponentContainerEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getIInterfaceContainer()
{
    return m_IInterfaceContainerEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getISystem()
{
    return m_ISystemEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getComponentInterface()
{
    return m_ComponentInterfaceEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getMainInterface()
{
    return m_MainInterfaceEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getSubInterface()
{
    return m_SubInterfaceEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getComponentPort()
{
    return m_ComponentPortEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getComponentStructure()
{
    return m_ComponentStructureEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getIComponentStructureMember()
{
    return m_IComponentStructureMemberEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getComponent()
{
    return m_ComponentEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getComposite()
{
    return m_CompositeEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getSystem()
{
    return m_SystemEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getComponentInstance()
{
    return m_ComponentInstanceEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getConnector()
{
    return m_ConnectorEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getInterfaceChannel()
{
    return m_InterfaceChannelEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getQualifiedPort()
{
    return m_QualifiedPortEClass;
}
::ecore::EEnum_ptr AmaltheaPackage::getInterfaceKind()
{
    return m_InterfaceKindEEnum;
}
::ecore::EClass_ptr AmaltheaPackage::getConfigModel()
{
    return m_ConfigModelEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getEventConfig()
{
    return m_EventConfigEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getConstraintsModel()
{
    return m_ConstraintsModelEClass;
}
::ecore::EEnum_ptr AmaltheaPackage::getRunnableOrderType()
{
    return m_RunnableOrderTypeEEnum;
}
::ecore::EClass_ptr AmaltheaPackage::getRunnableSequencingConstraint()
{
    return m_RunnableSequencingConstraintEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getAffinityConstraint()
{
    return m_AffinityConstraintEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getSeparationConstraint()
{
    return m_SeparationConstraintEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getPairingConstraint()
{
    return m_PairingConstraintEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getProcessConstraint()
{
    return m_ProcessConstraintEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getRunnableConstraint()
{
    return m_RunnableConstraintEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getDataConstraint()
{
    return m_DataConstraintEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getRunnableSeparationConstraint()
{
    return m_RunnableSeparationConstraintEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getProcessSeparationConstraint()
{
    return m_ProcessSeparationConstraintEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getDataSeparationConstraint()
{
    return m_DataSeparationConstraintEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getRunnablePairingConstraint()
{
    return m_RunnablePairingConstraintEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getProcessPairingConstraint()
{
    return m_ProcessPairingConstraintEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getDataPairingConstraint()
{
    return m_DataPairingConstraintEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getRunnableConstraintTarget()
{
    return m_RunnableConstraintTargetEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getProcessConstraintTarget()
{
    return m_ProcessConstraintTargetEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getDataConstraintTarget()
{
    return m_DataConstraintTargetEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getTargetMemory()
{
    return m_TargetMemoryEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getTargetCore()
{
    return m_TargetCoreEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getTargetScheduler()
{
    return m_TargetSchedulerEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getLabelGroup()
{
    return m_LabelGroupEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getRunnableGroup()
{
    return m_RunnableGroupEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getProcessGroup()
{
    return m_ProcessGroupEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getLabelEntityGroup()
{
    return m_LabelEntityGroupEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getRunnableEntityGroup()
{
    return m_RunnableEntityGroupEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getProcessEntityGroup()
{
    return m_ProcessEntityGroupEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getTagGroup()
{
    return m_TagGroupEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getAbstractEventChain()
{
    return m_AbstractEventChainEClass;
}
::ecore::EEnum_ptr AmaltheaPackage::getEventChainItemType()
{
    return m_EventChainItemTypeEEnum;
}
::ecore::EClass_ptr AmaltheaPackage::getEventChain()
{
    return m_EventChainEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getSubEventChain()
{
    return m_SubEventChainEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getEventChainItem()
{
    return m_EventChainItemEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getEventChainReference()
{
    return m_EventChainReferenceEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getEventChainContainer()
{
    return m_EventChainContainerEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getTimingConstraint()
{
    return m_TimingConstraintEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getPhysicalSectionConstraint()
{
    return m_PhysicalSectionConstraintEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getSynchronizationConstraint()
{
    return m_SynchronizationConstraintEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getEventSynchronizationConstraint()
{
    return m_EventSynchronizationConstraintEClass;
}
::ecore::EEnum_ptr AmaltheaPackage::getSynchronizationType()
{
    return m_SynchronizationTypeEEnum;
}
::ecore::EClass_ptr AmaltheaPackage::getEventChainSynchronizationConstraint()
{
    return m_EventChainSynchronizationConstraintEClass;
}
::ecore::EEnum_ptr AmaltheaPackage::getMappingType()
{
    return m_MappingTypeEEnum;
}
::ecore::EClass_ptr AmaltheaPackage::getDelayConstraint()
{
    return m_DelayConstraintEClass;
}
::ecore::EEnum_ptr AmaltheaPackage::getLatencyType()
{
    return m_LatencyTypeEEnum;
}
::ecore::EClass_ptr AmaltheaPackage::getEventChainLatencyConstraint()
{
    return m_EventChainLatencyConstraintEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getRepetitionConstraint()
{
    return m_RepetitionConstraintEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getDataAgeConstraint()
{
    return m_DataAgeConstraintEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getDataAge()
{
    return m_DataAgeEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getDataAgeCycle()
{
    return m_DataAgeCycleEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getDataAgeTime()
{
    return m_DataAgeTimeEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getRequirement()
{
    return m_RequirementEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getProcessRequirement()
{
    return m_ProcessRequirementEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getRunnableRequirement()
{
    return m_RunnableRequirementEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getArchitectureRequirement()
{
    return m_ArchitectureRequirementEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getProcessChainRequirement()
{
    return m_ProcessChainRequirementEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getRequirementLimit()
{
    return m_RequirementLimitEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getCPUPercentageRequirementLimit()
{
    return m_CPUPercentageRequirementLimitEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getFrequencyRequirementLimit()
{
    return m_FrequencyRequirementLimitEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getPercentageRequirementLimit()
{
    return m_PercentageRequirementLimitEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getCountRequirementLimit()
{
    return m_CountRequirementLimitEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getTimeRequirementLimit()
{
    return m_TimeRequirementLimitEClass;
}
::ecore::EEnum_ptr AmaltheaPackage::getSeverity()
{
    return m_SeverityEEnum;
}
::ecore::EEnum_ptr AmaltheaPackage::getLimitType()
{
    return m_LimitTypeEEnum;
}
::ecore::EEnum_ptr AmaltheaPackage::getTimeMetric()
{
    return m_TimeMetricEEnum;
}
::ecore::EEnum_ptr AmaltheaPackage::getCountMetric()
{
    return m_CountMetricEEnum;
}
::ecore::EEnum_ptr AmaltheaPackage::getPercentageMetric()
{
    return m_PercentageMetricEEnum;
}
::ecore::EEnum_ptr AmaltheaPackage::getCPUPercentageMetric()
{
    return m_CPUPercentageMetricEEnum;
}
::ecore::EEnum_ptr AmaltheaPackage::getFrequencyMetric()
{
    return m_FrequencyMetricEEnum;
}
::ecore::EClass_ptr AmaltheaPackage::getDataCoherencyGroup()
{
    return m_DataCoherencyGroupEClass;
}
::ecore::EEnum_ptr AmaltheaPackage::getCoherencyDirection()
{
    return m_CoherencyDirectionEEnum;
}
::ecore::EClass_ptr AmaltheaPackage::getDataStabilityGroup()
{
    return m_DataStabilityGroupEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getDataGroupScope()
{
    return m_DataGroupScopeEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getProcessScope()
{
    return m_ProcessScopeEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getRunnableScope()
{
    return m_RunnableScopeEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getComponentScope()
{
    return m_ComponentScopeEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getEventModel()
{
    return m_EventModelEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getEvent()
{
    return m_EventEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getEventSet()
{
    return m_EventSetEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getEntityEvent()
{
    return m_EntityEventEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getTriggerEvent()
{
    return m_TriggerEventEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getCustomEvent()
{
    return m_CustomEventEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getStimulusEvent()
{
    return m_StimulusEventEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getProcessEvent()
{
    return m_ProcessEventEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getProcessChainEvent()
{
    return m_ProcessChainEventEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getRunnableEvent()
{
    return m_RunnableEventEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getLabelEvent()
{
    return m_LabelEventEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getChannelEvent()
{
    return m_ChannelEventEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getSemaphoreEvent()
{
    return m_SemaphoreEventEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getComponentEvent()
{
    return m_ComponentEventEClass;
}
::ecore::EEnum_ptr AmaltheaPackage::getProcessEventType()
{
    return m_ProcessEventTypeEEnum;
}
::ecore::EEnum_ptr AmaltheaPackage::getRunnableEventType()
{
    return m_RunnableEventTypeEEnum;
}
::ecore::EEnum_ptr AmaltheaPackage::getLabelEventType()
{
    return m_LabelEventTypeEEnum;
}
::ecore::EEnum_ptr AmaltheaPackage::getChannelEventType()
{
    return m_ChannelEventTypeEEnum;
}
::ecore::EEnum_ptr AmaltheaPackage::getSemaphoreEventType()
{
    return m_SemaphoreEventTypeEEnum;
}
::ecore::EEnum_ptr AmaltheaPackage::getComponentEventType()
{
    return m_ComponentEventTypeEEnum;
}
::ecore::EClass_ptr AmaltheaPackage::getHWModel()
{
    return m_HWModelEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getHwStructure()
{
    return m_HwStructureEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getHwModule()
{
    return m_HwModuleEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getHwDomain()
{
    return m_HwDomainEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getFrequencyDomain()
{
    return m_FrequencyDomainEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getPowerDomain()
{
    return m_PowerDomainEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getProcessingUnit()
{
    return m_ProcessingUnitEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getMemory()
{
    return m_MemoryEClass;
}
::ecore::EEnum_ptr AmaltheaPackage::getMemoryType()
{
    return m_MemoryTypeEEnum;
}
::ecore::EClass_ptr AmaltheaPackage::getCache()
{
    return m_CacheEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getHwFeatureCategory()
{
    return m_HwFeatureCategoryEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getHwFeature()
{
    return m_HwFeatureEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getHwPort()
{
    return m_HwPortEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getConnectionHandler()
{
    return m_ConnectionHandlerEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getHwConnection()
{
    return m_HwConnectionEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getHwAccessElement()
{
    return m_HwAccessElementEClass;
}
::ecore::EEnum_ptr AmaltheaPackage::getStructureType()
{
    return m_StructureTypeEEnum;
}
::ecore::EEnum_ptr AmaltheaPackage::getCacheType()
{
    return m_CacheTypeEEnum;
}
::ecore::EEnum_ptr AmaltheaPackage::getPortType()
{
    return m_PortTypeEEnum;
}
::ecore::EEnum_ptr AmaltheaPackage::getSchedPolicy()
{
    return m_SchedPolicyEEnum;
}
::ecore::EEnum_ptr AmaltheaPackage::getWriteStrategy()
{
    return m_WriteStrategyEEnum;
}
::ecore::EClass_ptr AmaltheaPackage::getHwDefinition()
{
    return m_HwDefinitionEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getProcessingUnitDefinition()
{
    return m_ProcessingUnitDefinitionEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getConnectionHandlerDefinition()
{
    return m_ConnectionHandlerDefinitionEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getMemoryDefinition()
{
    return m_MemoryDefinitionEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getCacheDefinition()
{
    return m_CacheDefinitionEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getHwPath()
{
    return m_HwPathEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getHwAccessPath()
{
    return m_HwAccessPathEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getHwPathElement()
{
    return m_HwPathElementEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getHwDestination()
{
    return m_HwDestinationEClass;
}
::ecore::EEnum_ptr AmaltheaPackage::getPuType()
{
    return m_PuTypeEEnum;
}
::ecore::EEnum_ptr AmaltheaPackage::getPortInterface()
{
    return m_PortInterfaceEEnum;
}
::ecore::EEnum_ptr AmaltheaPackage::getHwFeatureType()
{
    return m_HwFeatureTypeEEnum;
}
::ecore::EClass_ptr AmaltheaPackage::getMappingModel()
{
    return m_MappingModelEClass;
}
::ecore::EEnum_ptr AmaltheaPackage::getMemoryAddressMappingType()
{
    return m_MemoryAddressMappingTypeEEnum;
}
::ecore::EClass_ptr AmaltheaPackage::getSchedulerAllocation()
{
    return m_SchedulerAllocationEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getTaskAllocation()
{
    return m_TaskAllocationEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getISRAllocation()
{
    return m_ISRAllocationEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getRunnableAllocation()
{
    return m_RunnableAllocationEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getMemoryMapping()
{
    return m_MemoryMappingEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getPhysicalSectionMapping()
{
    return m_PhysicalSectionMappingEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getOSModel()
{
    return m_OSModelEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getOsDataConsistency()
{
    return m_OsDataConsistencyEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getDataStability()
{
    return m_DataStabilityEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getNonAtomicDataCoherency()
{
    return m_NonAtomicDataCoherencyEClass;
}
::ecore::EEnum_ptr AmaltheaPackage::getOsDataConsistencyMode()
{
    return m_OsDataConsistencyModeEEnum;
}
::ecore::EEnum_ptr AmaltheaPackage::getAccessMultiplicity()
{
    return m_AccessMultiplicityEEnum;
}
::ecore::EEnum_ptr AmaltheaPackage::getDataStabilityLevel()
{
    return m_DataStabilityLevelEEnum;
}
::ecore::EClass_ptr AmaltheaPackage::getSemaphore()
{
    return m_SemaphoreEClass;
}
::ecore::EEnum_ptr AmaltheaPackage::getSemaphoreType()
{
    return m_SemaphoreTypeEEnum;
}
::ecore::EClass_ptr AmaltheaPackage::getScheduler()
{
    return m_SchedulerEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getTaskScheduler()
{
    return m_TaskSchedulerEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getSchedulerAssociation()
{
    return m_SchedulerAssociationEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getInterruptController()
{
    return m_InterruptControllerEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getSchedulingParameters()
{
    return m_SchedulingParametersEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getParameterExtension()
{
    return m_ParameterExtensionEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getAlgorithm()
{
    return m_AlgorithmEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getInterruptSchedulingAlgorithm()
{
    return m_InterruptSchedulingAlgorithmEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getTaskSchedulingAlgorithm()
{
    return m_TaskSchedulingAlgorithmEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getFixedPriority()
{
    return m_FixedPriorityEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getFixedPriorityPreemptive()
{
    return m_FixedPriorityPreemptiveEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getFixedPriorityPreemptiveWithBudgetEnforcement()
{
    return m_FixedPriorityPreemptiveWithBudgetEnforcementEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getOSEK()
{
    return m_OSEKEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getDeadlineMonotonic()
{
    return m_DeadlineMonotonicEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getRateMonotonic()
{
    return m_RateMonotonicEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getPfair()
{
    return m_PfairEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getPfairPD2()
{
    return m_PfairPD2EClass;
}
::ecore::EClass_ptr AmaltheaPackage::getPartlyPFairPD2()
{
    return m_PartlyPFairPD2EClass;
}
::ecore::EClass_ptr AmaltheaPackage::getEarlyReleaseFairPD2()
{
    return m_EarlyReleaseFairPD2EClass;
}
::ecore::EClass_ptr AmaltheaPackage::getPartlyEarlyReleaseFairPD2()
{
    return m_PartlyEarlyReleaseFairPD2EClass;
}
::ecore::EClass_ptr AmaltheaPackage::getDynamicPriority()
{
    return m_DynamicPriorityEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getLeastLocalRemainingExecutionTimeFirst()
{
    return m_LeastLocalRemainingExecutionTimeFirstEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getEarliestDeadlineFirst()
{
    return m_EarliestDeadlineFirstEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getPriorityBasedRoundRobin()
{
    return m_PriorityBasedRoundRobinEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getReservationBasedServer()
{
    return m_ReservationBasedServerEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getDeferrableServer()
{
    return m_DeferrableServerEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getPollingPeriodicServer()
{
    return m_PollingPeriodicServerEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getSporadicServer()
{
    return m_SporadicServerEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getConstantBandwidthServer()
{
    return m_ConstantBandwidthServerEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getConstantBandwidthServerWithCASH()
{
    return m_ConstantBandwidthServerWithCASHEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getGrouping()
{
    return m_GroupingEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getUserSpecificSchedulingAlgorithm()
{
    return m_UserSpecificSchedulingAlgorithmEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getPriorityBased()
{
    return m_PriorityBasedEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getOperatingSystem()
{
    return m_OperatingSystemEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getVendorOperatingSystem()
{
    return m_VendorOperatingSystemEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getOsOverhead()
{
    return m_OsOverheadEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getOsAPIOverhead()
{
    return m_OsAPIOverheadEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getOsISROverhead()
{
    return m_OsISROverheadEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getPropertyConstraintsModel()
{
    return m_PropertyConstraintsModelEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getCoreAllocationConstraint()
{
    return m_CoreAllocationConstraintEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getMemoryMappingConstraint()
{
    return m_MemoryMappingConstraintEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getProcessAllocationConstraint()
{
    return m_ProcessAllocationConstraintEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getProcessPrototypeAllocationConstraint()
{
    return m_ProcessPrototypeAllocationConstraintEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getRunnableAllocationConstraint()
{
    return m_RunnableAllocationConstraintEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getAbstractElementMappingConstraint()
{
    return m_AbstractElementMappingConstraintEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getClassification()
{
    return m_ClassificationEClass;
}
::ecore::EEnum_ptr AmaltheaPackage::getCondition()
{
    return m_ConditionEEnum;
}
::ecore::EEnum_ptr AmaltheaPackage::getGroupingType()
{
    return m_GroupingTypeEEnum;
}
::ecore::EClass_ptr AmaltheaPackage::getCoreClassification()
{
    return m_CoreClassificationEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getMemoryClassification()
{
    return m_MemoryClassificationEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getStimuliModel()
{
    return m_StimuliModelEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getStimulus()
{
    return m_StimulusEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getModeValueList()
{
    return m_ModeValueListEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getModeValueMapEntry()
{
    return m_ModeValueMapEntryEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getModeValue()
{
    return m_ModeValueEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getModeAssignment()
{
    return m_ModeAssignmentEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getModeConditionDisjunction()
{
    return m_ModeConditionDisjunctionEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getModeConditionDisjunctionEntry()
{
    return m_ModeConditionDisjunctionEntryEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getModeCondition()
{
    return m_ModeConditionEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getModeValueCondition()
{
    return m_ModeValueConditionEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getModeLabelCondition()
{
    return m_ModeLabelConditionEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getModeConditionConjunction()
{
    return m_ModeConditionConjunctionEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getFixedPeriodic()
{
    return m_FixedPeriodicEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getPeriodicStimulus()
{
    return m_PeriodicStimulusEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getRelativePeriodicStimulus()
{
    return m_RelativePeriodicStimulusEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getVariableRateStimulus()
{
    return m_VariableRateStimulusEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getScenario()
{
    return m_ScenarioEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getPeriodicSyntheticStimulus()
{
    return m_PeriodicSyntheticStimulusEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getCustomStimulus()
{
    return m_CustomStimulusEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getSingleStimulus()
{
    return m_SingleStimulusEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getInterProcessStimulus()
{
    return m_InterProcessStimulusEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getPeriodicBurstStimulus()
{
    return m_PeriodicBurstStimulusEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getEventStimulus()
{
    return m_EventStimulusEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getArrivalCurveStimulus()
{
    return m_ArrivalCurveStimulusEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getArrivalCurveEntry()
{
    return m_ArrivalCurveEntryEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getClock()
{
    return m_ClockEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getClockFunction()
{
    return m_ClockFunctionEClass;
}
::ecore::EEnum_ptr AmaltheaPackage::getCurveType()
{
    return m_CurveTypeEEnum;
}
::ecore::EClass_ptr AmaltheaPackage::getClockStepList()
{
    return m_ClockStepListEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getClockStep()
{
    return m_ClockStepEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getSWModel()
{
    return m_SWModelEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getAbstractMemoryElement()
{
    return m_AbstractMemoryElementEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getAbstractProcess()
{
    return m_AbstractProcessEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getCustomEntity()
{
    return m_CustomEntityEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getProcessChain()
{
    return m_ProcessChainEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getProcess()
{
    return m_ProcessEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getIActivityGraphItemContainer()
{
    return m_IActivityGraphItemContainerEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getActivityGraph()
{
    return m_ActivityGraphEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getActivityGraphItem()
{
    return m_ActivityGraphItemEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getModeSwitch()
{
    return m_ModeSwitchEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getModeSwitchEntry()
{
    return m_ModeSwitchEntryEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getModeSwitchDefault()
{
    return m_ModeSwitchDefaultEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getProbabilitySwitch()
{
    return m_ProbabilitySwitchEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getProbabilitySwitchEntry()
{
    return m_ProbabilitySwitchEntryEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getCounter()
{
    return m_CounterEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getWaitEvent()
{
    return m_WaitEventEClass;
}
::ecore::EEnum_ptr AmaltheaPackage::getWaitEventType()
{
    return m_WaitEventTypeEEnum;
}
::ecore::EEnum_ptr AmaltheaPackage::getWaitingBehaviour()
{
    return m_WaitingBehaviourEEnum;
}
::ecore::EClass_ptr AmaltheaPackage::getSetEvent()
{
    return m_SetEventEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getClearEvent()
{
    return m_ClearEventEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getEventMask()
{
    return m_EventMaskEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getOsEvent()
{
    return m_OsEventEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getInterProcessTrigger()
{
    return m_InterProcessTriggerEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getEnforcedMigration()
{
    return m_EnforcedMigrationEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getSchedulePoint()
{
    return m_SchedulePointEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getTerminateProcess()
{
    return m_TerminateProcessEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getTask()
{
    return m_TaskEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getISR()
{
    return m_ISREClass;
}
::ecore::EEnum_ptr AmaltheaPackage::getISRCategory()
{
    return m_ISRCategoryEEnum;
}
::ecore::EClass_ptr AmaltheaPackage::getProcessPrototype()
{
    return m_ProcessPrototypeEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getChainedProcessPrototype()
{
    return m_ChainedProcessPrototypeEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getGeneralPrecedence()
{
    return m_GeneralPrecedenceEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getAccessPrecedenceSpec()
{
    return m_AccessPrecedenceSpecEClass;
}
::ecore::EEnum_ptr AmaltheaPackage::getAccessPrecedenceType()
{
    return m_AccessPrecedenceTypeEEnum;
}
::ecore::EClass_ptr AmaltheaPackage::getOrderPrecedenceSpec()
{
    return m_OrderPrecedenceSpecEClass;
}
::ecore::EEnum_ptr AmaltheaPackage::getOrderType()
{
    return m_OrderTypeEEnum;
}
::ecore::EEnum_ptr AmaltheaPackage::getDirectionType()
{
    return m_DirectionTypeEEnum;
}
::ecore::EClass_ptr AmaltheaPackage::getIDependsOn()
{
    return m_IDependsOnEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getDataDependency()
{
    return m_DataDependencyEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getRunnableParameter()
{
    return m_RunnableParameterEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getRunnable()
{
    return m_RunnableEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getLabel()
{
    return m_LabelEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getChannel()
{
    return m_ChannelEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getModeLabel()
{
    return m_ModeLabelEClass;
}
::ecore::EEnum_ptr AmaltheaPackage::getLabelDataStability()
{
    return m_LabelDataStabilityEEnum;
}
::ecore::EClass_ptr AmaltheaPackage::getSection()
{
    return m_SectionEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getComputationItem()
{
    return m_ComputationItemEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getExecutionNeed()
{
    return m_ExecutionNeedEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getNeedEntry()
{
    return m_NeedEntryEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getTicks()
{
    return m_TicksEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getTicksEntry()
{
    return m_TicksEntryEClass;
}
::ecore::EEnum_ptr AmaltheaPackage::getModeLabelAccessEnum()
{
    return m_ModeLabelAccessEnumEEnum;
}
::ecore::EClass_ptr AmaltheaPackage::getModeLabelAccess()
{
    return m_ModeLabelAccessEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getLabelAccess()
{
    return m_LabelAccessEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getChannelAccess()
{
    return m_ChannelAccessEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getChannelSend()
{
    return m_ChannelSendEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getChannelReceive()
{
    return m_ChannelReceiveEClass;
}
::ecore::EEnum_ptr AmaltheaPackage::getReceiveOperation()
{
    return m_ReceiveOperationEEnum;
}
::ecore::EEnum_ptr AmaltheaPackage::getLabelAccessDataStability()
{
    return m_LabelAccessDataStabilityEEnum;
}
::ecore::EEnum_ptr AmaltheaPackage::getLabelAccessEnum()
{
    return m_LabelAccessEnumEEnum;
}
::ecore::EEnum_ptr AmaltheaPackage::getLabelAccessImplementation()
{
    return m_LabelAccessImplementationEEnum;
}
::ecore::EClass_ptr AmaltheaPackage::getSemaphoreAccess()
{
    return m_SemaphoreAccessEClass;
}
::ecore::EEnum_ptr AmaltheaPackage::getSemaphoreAccessEnum()
{
    return m_SemaphoreAccessEnumEEnum;
}
::ecore::EClass_ptr AmaltheaPackage::getSenderReceiverCommunication()
{
    return m_SenderReceiverCommunicationEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getSenderReceiverRead()
{
    return m_SenderReceiverReadEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getSenderReceiverWrite()
{
    return m_SenderReceiverWriteEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getServerCall()
{
    return m_ServerCallEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getSynchronousServerCall()
{
    return m_SynchronousServerCallEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getAsynchronousServerCall()
{
    return m_AsynchronousServerCallEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getGetResultServerCall()
{
    return m_GetResultServerCallEClass;
}
::ecore::EEnum_ptr AmaltheaPackage::getBlockingType()
{
    return m_BlockingTypeEEnum;
}
::ecore::EClass_ptr AmaltheaPackage::getGroup()
{
    return m_GroupEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getCallArgument()
{
    return m_CallArgumentEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getRunnableCall()
{
    return m_RunnableCallEClass;
}
::ecore::EEnum_ptr AmaltheaPackage::getPreemption()
{
    return m_PreemptionEEnum;
}
::ecore::EEnum_ptr AmaltheaPackage::getConcurrencyType()
{
    return m_ConcurrencyTypeEEnum;
}
::ecore::EClass_ptr AmaltheaPackage::getCustomEventTrigger()
{
    return m_CustomEventTriggerEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getDataType()
{
    return m_DataTypeEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getCompoundType()
{
    return m_CompoundTypeEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getStruct()
{
    return m_StructEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getStructEntry()
{
    return m_StructEntryEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getArray()
{
    return m_ArrayEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getPointer()
{
    return m_PointerEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getTypeRef()
{
    return m_TypeRefEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getAlias()
{
    return m_AliasEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getTypeDefinition()
{
    return m_TypeDefinitionEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getDataTypeDefinition()
{
    return m_DataTypeDefinitionEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getBaseTypeDefinition()
{
    return m_BaseTypeDefinitionEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getActivation()
{
    return m_ActivationEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getPeriodicActivation()
{
    return m_PeriodicActivationEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getVariableRateActivation()
{
    return m_VariableRateActivationEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getSporadicActivation()
{
    return m_SporadicActivationEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getSingleActivation()
{
    return m_SingleActivationEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getEventActivation()
{
    return m_EventActivationEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getCustomActivation()
{
    return m_CustomActivationEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getLabelAccessStatistic()
{
    return m_LabelAccessStatisticEClass;
}
::ecore::EClass_ptr AmaltheaPackage::getRunEntityCallStatistic()
{
    return m_RunEntityCallStatisticEClass;
}
::ecore::EEnum_ptr AmaltheaPackage::getASILType()
{
    return m_ASILTypeEEnum;
}

::ecore::EReference_ptr AmaltheaPackage::getIAnnotatable__customProperties()
{
    return m_IAnnotatable__customProperties;
}
::ecore::EAttribute_ptr AmaltheaPackage::getAmalthea__version()
{
    return m_Amalthea__version;
}
::ecore::EReference_ptr AmaltheaPackage::getAmalthea__commonElements()
{
    return m_Amalthea__commonElements;
}
::ecore::EReference_ptr AmaltheaPackage::getAmalthea__swModel()
{
    return m_Amalthea__swModel;
}
::ecore::EReference_ptr AmaltheaPackage::getAmalthea__hwModel()
{
    return m_Amalthea__hwModel;
}
::ecore::EReference_ptr AmaltheaPackage::getAmalthea__osModel()
{
    return m_Amalthea__osModel;
}
::ecore::EReference_ptr AmaltheaPackage::getAmalthea__stimuliModel()
{
    return m_Amalthea__stimuliModel;
}
::ecore::EReference_ptr AmaltheaPackage::getAmalthea__eventModel()
{
    return m_Amalthea__eventModel;
}
::ecore::EReference_ptr AmaltheaPackage::getAmalthea__constraintsModel()
{
    return m_Amalthea__constraintsModel;
}
::ecore::EReference_ptr AmaltheaPackage::getAmalthea__propertyConstraintsModel()
{
    return m_Amalthea__propertyConstraintsModel;
}
::ecore::EReference_ptr AmaltheaPackage::getAmalthea__mappingModel()
{
    return m_Amalthea__mappingModel;
}
::ecore::EReference_ptr AmaltheaPackage::getAmalthea__componentsModel()
{
    return m_Amalthea__componentsModel;
}
::ecore::EReference_ptr AmaltheaPackage::getAmalthea__configModel()
{
    return m_Amalthea__configModel;
}
::ecore::EReference_ptr AmaltheaPackage::getCommonElements__tags()
{
    return m_CommonElements__tags;
}
::ecore::EReference_ptr AmaltheaPackage::getCommonElements__namespaces()
{
    return m_CommonElements__namespaces;
}
::ecore::EReference_ptr AmaltheaPackage::getCommonElements__coreClassifiers()
{
    return m_CommonElements__coreClassifiers;
}
::ecore::EReference_ptr AmaltheaPackage::getCommonElements__memoryClassifiers()
{
    return m_CommonElements__memoryClassifiers;
}
::ecore::EAttribute_ptr AmaltheaPackage::getINamed__name()
{
    return m_INamed__name;
}
::ecore::EAttribute_ptr AmaltheaPackage::getINamed__qualifiedName()
{
    return m_INamed__qualifiedName;
}
::ecore::EAttribute_ptr AmaltheaPackage::getIReferable__uniqueName()
{
    return m_IReferable__uniqueName;
}
::ecore::EReference_ptr AmaltheaPackage::getITaggable__tags()
{
    return m_ITaggable__tags;
}
::ecore::EAttribute_ptr AmaltheaPackage::getIDisplayName__displayName()
{
    return m_IDisplayName__displayName;
}
::ecore::EAttribute_ptr AmaltheaPackage::getIDescription__description()
{
    return m_IDescription__description;
}
::ecore::EReference_ptr AmaltheaPackage::getINamespaceMember__namespace()
{
    return m_INamespaceMember__namespace;
}
::ecore::EAttribute_ptr AmaltheaPackage::getTag__tagType()
{
    return m_Tag__tagType;
}
::ecore::EReference_ptr AmaltheaPackage::getTag__taggedObjects()
{
    return m_Tag__taggedObjects;
}
::ecore::EReference_ptr AmaltheaPackage::getNamespace__nextSegments()
{
    return m_Namespace__nextSegments;
}
::ecore::EReference_ptr AmaltheaPackage::getNamespace__previousSegment()
{
    return m_Namespace__previousSegment;
}
::ecore::EReference_ptr AmaltheaPackage::getNamespace__memberObjects()
{
    return m_Namespace__memberObjects;
}
::ecore::EReference_ptr AmaltheaPackage::getTransmissionPolicy__chunkSize()
{
    return m_TransmissionPolicy__chunkSize;
}
::ecore::EAttribute_ptr AmaltheaPackage::getTransmissionPolicy__chunkProcessingTicks()
{
    return m_TransmissionPolicy__chunkProcessingTicks;
}
::ecore::EAttribute_ptr AmaltheaPackage::getTransmissionPolicy__transmitRatio()
{
    return m_TransmissionPolicy__transmitRatio;
}
::ecore::EAttribute_ptr AmaltheaPackage::getTime__value()
{
    return m_Time__value;
}
::ecore::EAttribute_ptr AmaltheaPackage::getTime__unit()
{
    return m_Time__unit;
}
::ecore::EAttribute_ptr AmaltheaPackage::getFrequency__value()
{
    return m_Frequency__value;
}
::ecore::EAttribute_ptr AmaltheaPackage::getFrequency__unit()
{
    return m_Frequency__unit;
}
::ecore::EAttribute_ptr AmaltheaPackage::getVoltage__value()
{
    return m_Voltage__value;
}
::ecore::EAttribute_ptr AmaltheaPackage::getVoltage__unit()
{
    return m_Voltage__unit;
}
::ecore::EAttribute_ptr AmaltheaPackage::getDataSize__value()
{
    return m_DataSize__value;
}
::ecore::EAttribute_ptr AmaltheaPackage::getDataSize__unit()
{
    return m_DataSize__unit;
}
::ecore::EAttribute_ptr AmaltheaPackage::getDataRate__value()
{
    return m_DataRate__value;
}
::ecore::EAttribute_ptr AmaltheaPackage::getDataRate__unit()
{
    return m_DataRate__unit;
}
::ecore::EAttribute_ptr AmaltheaPackage::getCustomProperty__key()
{
    return m_CustomProperty__key;
}
::ecore::EReference_ptr AmaltheaPackage::getCustomProperty__value()
{
    return m_CustomProperty__value;
}
::ecore::EReference_ptr AmaltheaPackage::getListObject__values()
{
    return m_ListObject__values;
}
::ecore::EAttribute_ptr AmaltheaPackage::getStringObject__value()
{
    return m_StringObject__value;
}
::ecore::EAttribute_ptr AmaltheaPackage::getBigIntegerObject__value()
{
    return m_BigIntegerObject__value;
}
::ecore::EReference_ptr AmaltheaPackage::getReferenceObject__value()
{
    return m_ReferenceObject__value;
}
::ecore::EAttribute_ptr AmaltheaPackage::getIntegerObject__value()
{
    return m_IntegerObject__value;
}
::ecore::EAttribute_ptr AmaltheaPackage::getLongObject__value()
{
    return m_LongObject__value;
}
::ecore::EAttribute_ptr AmaltheaPackage::getFloatObject__value()
{
    return m_FloatObject__value;
}
::ecore::EAttribute_ptr AmaltheaPackage::getDoubleObject__value()
{
    return m_DoubleObject__value;
}
::ecore::EAttribute_ptr AmaltheaPackage::getBooleanObject__value()
{
    return m_BooleanObject__value;
}
::ecore::EAttribute_ptr AmaltheaPackage::getMinAvgMaxStatistic__min()
{
    return m_MinAvgMaxStatistic__min;
}
::ecore::EAttribute_ptr AmaltheaPackage::getMinAvgMaxStatistic__avg()
{
    return m_MinAvgMaxStatistic__avg;
}
::ecore::EAttribute_ptr AmaltheaPackage::getMinAvgMaxStatistic__max()
{
    return m_MinAvgMaxStatistic__max;
}
::ecore::EAttribute_ptr AmaltheaPackage::getSingleValueStatistic__value()
{
    return m_SingleValueStatistic__value;
}
::ecore::EReference_ptr AmaltheaPackage::getTimeInterval__lowerBound()
{
    return m_TimeInterval__lowerBound;
}
::ecore::EReference_ptr AmaltheaPackage::getTimeInterval__upperBound()
{
    return m_TimeInterval__upperBound;
}
::ecore::EReference_ptr AmaltheaPackage::getTimeConstant__value()
{
    return m_TimeConstant__value;
}
::ecore::EReference_ptr AmaltheaPackage::getTimeHistogram__entries()
{
    return m_TimeHistogram__entries;
}
::ecore::EAttribute_ptr AmaltheaPackage::getTimeHistogramEntry__occurrences()
{
    return m_TimeHistogramEntry__occurrences;
}
::ecore::EReference_ptr AmaltheaPackage::getTruncatedTimeDistribution__lowerBound()
{
    return m_TruncatedTimeDistribution__lowerBound;
}
::ecore::EReference_ptr AmaltheaPackage::getTruncatedTimeDistribution__upperBound()
{
    return m_TruncatedTimeDistribution__upperBound;
}
::ecore::EAttribute_ptr AmaltheaPackage::getTimeBoundaries__samplingType()
{
    return m_TimeBoundaries__samplingType;
}
::ecore::EReference_ptr AmaltheaPackage::getTimeStatistics__average()
{
    return m_TimeStatistics__average;
}
::ecore::EReference_ptr AmaltheaPackage::getTimeGaussDistribution__mean()
{
    return m_TimeGaussDistribution__mean;
}
::ecore::EReference_ptr AmaltheaPackage::getTimeGaussDistribution__sd()
{
    return m_TimeGaussDistribution__sd;
}
::ecore::EReference_ptr AmaltheaPackage::getTimeWeibullEstimatorsDistribution__average()
{
    return m_TimeWeibullEstimatorsDistribution__average;
}
::ecore::EAttribute_ptr AmaltheaPackage::getTimeWeibullEstimatorsDistribution__pRemainPromille()
{
    return m_TimeWeibullEstimatorsDistribution__pRemainPromille;
}
::ecore::EAttribute_ptr AmaltheaPackage::getTimeBetaDistribution__alpha()
{
    return m_TimeBetaDistribution__alpha;
}
::ecore::EAttribute_ptr AmaltheaPackage::getTimeBetaDistribution__beta()
{
    return m_TimeBetaDistribution__beta;
}
::ecore::EAttribute_ptr AmaltheaPackage::getDiscreteValueInterval__lowerBound()
{
    return m_DiscreteValueInterval__lowerBound;
}
::ecore::EAttribute_ptr AmaltheaPackage::getDiscreteValueInterval__upperBound()
{
    return m_DiscreteValueInterval__upperBound;
}
::ecore::EAttribute_ptr AmaltheaPackage::getDiscreteValueConstant__value()
{
    return m_DiscreteValueConstant__value;
}
::ecore::EReference_ptr AmaltheaPackage::getDiscreteValueHistogram__entries()
{
    return m_DiscreteValueHistogram__entries;
}
::ecore::EAttribute_ptr AmaltheaPackage::getDiscreteValueHistogramEntry__occurrences()
{
    return m_DiscreteValueHistogramEntry__occurrences;
}
::ecore::EAttribute_ptr AmaltheaPackage::getTruncatedDiscreteValueDistribution__lowerBound()
{
    return m_TruncatedDiscreteValueDistribution__lowerBound;
}
::ecore::EAttribute_ptr AmaltheaPackage::getTruncatedDiscreteValueDistribution__upperBound()
{
    return m_TruncatedDiscreteValueDistribution__upperBound;
}
::ecore::EAttribute_ptr AmaltheaPackage::getDiscreteValueBoundaries__samplingType()
{
    return m_DiscreteValueBoundaries__samplingType;
}
::ecore::EAttribute_ptr AmaltheaPackage::getDiscreteValueStatistics__average()
{
    return m_DiscreteValueStatistics__average;
}
::ecore::EAttribute_ptr AmaltheaPackage::getDiscreteValueGaussDistribution__mean()
{
    return m_DiscreteValueGaussDistribution__mean;
}
::ecore::EAttribute_ptr AmaltheaPackage::getDiscreteValueGaussDistribution__sd()
{
    return m_DiscreteValueGaussDistribution__sd;
}
::ecore::EAttribute_ptr AmaltheaPackage::getDiscreteValueWeibullEstimatorsDistribution__average()
{
    return m_DiscreteValueWeibullEstimatorsDistribution__average;
}
::ecore::EAttribute_ptr AmaltheaPackage::getDiscreteValueWeibullEstimatorsDistribution__pRemainPromille()
{
    return m_DiscreteValueWeibullEstimatorsDistribution__pRemainPromille;
}
::ecore::EAttribute_ptr AmaltheaPackage::getDiscreteValueBetaDistribution__alpha()
{
    return m_DiscreteValueBetaDistribution__alpha;
}
::ecore::EAttribute_ptr AmaltheaPackage::getDiscreteValueBetaDistribution__beta()
{
    return m_DiscreteValueBetaDistribution__beta;
}
::ecore::EAttribute_ptr AmaltheaPackage::getContinuousValueInterval__lowerBound()
{
    return m_ContinuousValueInterval__lowerBound;
}
::ecore::EAttribute_ptr AmaltheaPackage::getContinuousValueInterval__upperBound()
{
    return m_ContinuousValueInterval__upperBound;
}
::ecore::EAttribute_ptr AmaltheaPackage::getContinuousValueConstant__value()
{
    return m_ContinuousValueConstant__value;
}
::ecore::EReference_ptr AmaltheaPackage::getContinuousValueHistogram__entries()
{
    return m_ContinuousValueHistogram__entries;
}
::ecore::EAttribute_ptr AmaltheaPackage::getContinuousValueHistogramEntry__occurrences()
{
    return m_ContinuousValueHistogramEntry__occurrences;
}
::ecore::EAttribute_ptr AmaltheaPackage::getTruncatedContinuousValueDistribution__lowerBound()
{
    return m_TruncatedContinuousValueDistribution__lowerBound;
}
::ecore::EAttribute_ptr AmaltheaPackage::getTruncatedContinuousValueDistribution__upperBound()
{
    return m_TruncatedContinuousValueDistribution__upperBound;
}
::ecore::EAttribute_ptr AmaltheaPackage::getContinuousValueBoundaries__samplingType()
{
    return m_ContinuousValueBoundaries__samplingType;
}
::ecore::EAttribute_ptr AmaltheaPackage::getContinuousValueStatistics__average()
{
    return m_ContinuousValueStatistics__average;
}
::ecore::EAttribute_ptr AmaltheaPackage::getContinuousValueGaussDistribution__mean()
{
    return m_ContinuousValueGaussDistribution__mean;
}
::ecore::EAttribute_ptr AmaltheaPackage::getContinuousValueGaussDistribution__sd()
{
    return m_ContinuousValueGaussDistribution__sd;
}
::ecore::EAttribute_ptr AmaltheaPackage::getContinuousValueWeibullEstimatorsDistribution__average()
{
    return m_ContinuousValueWeibullEstimatorsDistribution__average;
}
::ecore::EAttribute_ptr AmaltheaPackage::getContinuousValueWeibullEstimatorsDistribution__pRemainPromille()
{
    return m_ContinuousValueWeibullEstimatorsDistribution__pRemainPromille;
}
::ecore::EAttribute_ptr AmaltheaPackage::getContinuousValueBetaDistribution__alpha()
{
    return m_ContinuousValueBetaDistribution__alpha;
}
::ecore::EAttribute_ptr AmaltheaPackage::getContinuousValueBetaDistribution__beta()
{
    return m_ContinuousValueBetaDistribution__beta;
}
::ecore::EReference_ptr AmaltheaPackage::getEnumMode__literals()
{
    return m_EnumMode__literals;
}
::ecore::EReference_ptr AmaltheaPackage::getModeLiteral__containingMode()
{
    return m_ModeLiteral__containingMode;
}
::ecore::EReference_ptr AmaltheaPackage::getIComponentContainer__components()
{
    return m_IComponentContainer__components;
}
::ecore::EReference_ptr AmaltheaPackage::getIInterfaceContainer__interfaces()
{
    return m_IInterfaceContainer__interfaces;
}
::ecore::EReference_ptr AmaltheaPackage::getComponentsModel__structures()
{
    return m_ComponentsModel__structures;
}
::ecore::EReference_ptr AmaltheaPackage::getComponentsModel__systems()
{
    return m_ComponentsModel__systems;
}
::ecore::EReference_ptr AmaltheaPackage::getISystem__componentInstances()
{
    return m_ISystem__componentInstances;
}
::ecore::EReference_ptr AmaltheaPackage::getISystem__connectors()
{
    return m_ISystem__connectors;
}
::ecore::EReference_ptr AmaltheaPackage::getISystem__groundedPorts()
{
    return m_ISystem__groundedPorts;
}
::ecore::EReference_ptr AmaltheaPackage::getISystem__innerPorts()
{
    return m_ISystem__innerPorts;
}
::ecore::EReference_ptr AmaltheaPackage::getComponentInterface__datatype()
{
    return m_ComponentInterface__datatype;
}
::ecore::EReference_ptr AmaltheaPackage::getComponentInterface__subInterfaces()
{
    return m_ComponentInterface__subInterfaces;
}
::ecore::EReference_ptr AmaltheaPackage::getIComponentStructureMember__structure()
{
    return m_IComponentStructureMember__structure;
}
::ecore::EAttribute_ptr AmaltheaPackage::getMainInterface__version()
{
    return m_MainInterface__version;
}
::ecore::EReference_ptr AmaltheaPackage::getSubInterface__containingInterface()
{
    return m_SubInterface__containingInterface;
}
::ecore::EReference_ptr AmaltheaPackage::getComponentPort__containingComponent()
{
    return m_ComponentPort__containingComponent;
}
::ecore::EAttribute_ptr AmaltheaPackage::getComponentPort__kind()
{
    return m_ComponentPort__kind;
}
::ecore::EReference_ptr AmaltheaPackage::getComponentPort__interface()
{
    return m_ComponentPort__interface;
}
::ecore::EAttribute_ptr AmaltheaPackage::getComponentStructure__structureType()
{
    return m_ComponentStructure__structureType;
}
::ecore::EReference_ptr AmaltheaPackage::getComponentStructure__subStructures()
{
    return m_ComponentStructure__subStructures;
}
::ecore::EReference_ptr AmaltheaPackage::getComponentStructure__memberObjects()
{
    return m_ComponentStructure__memberObjects;
}
::ecore::EReference_ptr AmaltheaPackage::getComponent__ports()
{
    return m_Component__ports;
}
::ecore::EReference_ptr AmaltheaPackage::getComponent__processes()
{
    return m_Component__processes;
}
::ecore::EReference_ptr AmaltheaPackage::getComponent__runnables()
{
    return m_Component__runnables;
}
::ecore::EReference_ptr AmaltheaPackage::getComponent__labels()
{
    return m_Component__labels;
}
::ecore::EReference_ptr AmaltheaPackage::getComponent__semaphores()
{
    return m_Component__semaphores;
}
::ecore::EReference_ptr AmaltheaPackage::getComponent__osEvents()
{
    return m_Component__osEvents;
}
::ecore::EReference_ptr AmaltheaPackage::getComponentInstance__containingSystem()
{
    return m_ComponentInstance__containingSystem;
}
::ecore::EReference_ptr AmaltheaPackage::getComponentInstance__type()
{
    return m_ComponentInstance__type;
}
::ecore::EReference_ptr AmaltheaPackage::getConnector__containingSystem()
{
    return m_Connector__containingSystem;
}
::ecore::EReference_ptr AmaltheaPackage::getConnector__sourcePort()
{
    return m_Connector__sourcePort;
}
::ecore::EReference_ptr AmaltheaPackage::getConnector__targetPort()
{
    return m_Connector__targetPort;
}
::ecore::EReference_ptr AmaltheaPackage::getConnector__implementedInterfaces()
{
    return m_Connector__implementedInterfaces;
}
::ecore::EReference_ptr AmaltheaPackage::getInterfaceChannel__key()
{
    return m_InterfaceChannel__key;
}
::ecore::EReference_ptr AmaltheaPackage::getInterfaceChannel__value()
{
    return m_InterfaceChannel__value;
}
::ecore::EReference_ptr AmaltheaPackage::getQualifiedPort__instance()
{
    return m_QualifiedPort__instance;
}
::ecore::EReference_ptr AmaltheaPackage::getQualifiedPort__port()
{
    return m_QualifiedPort__port;
}
::ecore::EReference_ptr AmaltheaPackage::getConfigModel__eventsToTrace()
{
    return m_ConfigModel__eventsToTrace;
}
::ecore::EReference_ptr AmaltheaPackage::getEventConfig__event()
{
    return m_EventConfig__event;
}
::ecore::EReference_ptr AmaltheaPackage::getConstraintsModel__eventChains()
{
    return m_ConstraintsModel__eventChains;
}
::ecore::EReference_ptr AmaltheaPackage::getConstraintsModel__timingConstraints()
{
    return m_ConstraintsModel__timingConstraints;
}
::ecore::EReference_ptr AmaltheaPackage::getConstraintsModel__affinityConstraints()
{
    return m_ConstraintsModel__affinityConstraints;
}
::ecore::EReference_ptr AmaltheaPackage::getConstraintsModel__runnableSequencingConstraints()
{
    return m_ConstraintsModel__runnableSequencingConstraints;
}
::ecore::EReference_ptr AmaltheaPackage::getConstraintsModel__dataAgeConstraints()
{
    return m_ConstraintsModel__dataAgeConstraints;
}
::ecore::EReference_ptr AmaltheaPackage::getConstraintsModel__requirements()
{
    return m_ConstraintsModel__requirements;
}
::ecore::EReference_ptr AmaltheaPackage::getConstraintsModel__dataCoherencyGroups()
{
    return m_ConstraintsModel__dataCoherencyGroups;
}
::ecore::EReference_ptr AmaltheaPackage::getConstraintsModel__dataStabilityGroups()
{
    return m_ConstraintsModel__dataStabilityGroups;
}
::ecore::EReference_ptr AmaltheaPackage::getConstraintsModel__physicalSectionConstraints()
{
    return m_ConstraintsModel__physicalSectionConstraints;
}
::ecore::EAttribute_ptr AmaltheaPackage::getRunnableSequencingConstraint__orderType()
{
    return m_RunnableSequencingConstraint__orderType;
}
::ecore::EReference_ptr AmaltheaPackage::getRunnableSequencingConstraint__runnableGroups()
{
    return m_RunnableSequencingConstraint__runnableGroups;
}
::ecore::EReference_ptr AmaltheaPackage::getRunnableSequencingConstraint__processScope()
{
    return m_RunnableSequencingConstraint__processScope;
}
::ecore::EReference_ptr AmaltheaPackage::getProcessConstraint__target()
{
    return m_ProcessConstraint__target;
}
::ecore::EReference_ptr AmaltheaPackage::getRunnableConstraint__target()
{
    return m_RunnableConstraint__target;
}
::ecore::EReference_ptr AmaltheaPackage::getDataConstraint__target()
{
    return m_DataConstraint__target;
}
::ecore::EReference_ptr AmaltheaPackage::getRunnableSeparationConstraint__groups()
{
    return m_RunnableSeparationConstraint__groups;
}
::ecore::EReference_ptr AmaltheaPackage::getProcessSeparationConstraint__groups()
{
    return m_ProcessSeparationConstraint__groups;
}
::ecore::EReference_ptr AmaltheaPackage::getDataSeparationConstraint__groups()
{
    return m_DataSeparationConstraint__groups;
}
::ecore::EReference_ptr AmaltheaPackage::getRunnablePairingConstraint__group()
{
    return m_RunnablePairingConstraint__group;
}
::ecore::EReference_ptr AmaltheaPackage::getProcessPairingConstraint__group()
{
    return m_ProcessPairingConstraint__group;
}
::ecore::EReference_ptr AmaltheaPackage::getDataPairingConstraint__group()
{
    return m_DataPairingConstraint__group;
}
::ecore::EReference_ptr AmaltheaPackage::getTargetMemory__memories()
{
    return m_TargetMemory__memories;
}
::ecore::EReference_ptr AmaltheaPackage::getTargetCore__cores()
{
    return m_TargetCore__cores;
}
::ecore::EReference_ptr AmaltheaPackage::getTargetScheduler__schedulers()
{
    return m_TargetScheduler__schedulers;
}
::ecore::EReference_ptr AmaltheaPackage::getLabelEntityGroup__labels()
{
    return m_LabelEntityGroup__labels;
}
::ecore::EReference_ptr AmaltheaPackage::getRunnableEntityGroup__runnables()
{
    return m_RunnableEntityGroup__runnables;
}
::ecore::EReference_ptr AmaltheaPackage::getProcessEntityGroup__processes()
{
    return m_ProcessEntityGroup__processes;
}
::ecore::EReference_ptr AmaltheaPackage::getTagGroup__tag()
{
    return m_TagGroup__tag;
}
::ecore::EReference_ptr AmaltheaPackage::getAbstractEventChain__stimulus()
{
    return m_AbstractEventChain__stimulus;
}
::ecore::EReference_ptr AmaltheaPackage::getAbstractEventChain__response()
{
    return m_AbstractEventChain__response;
}
::ecore::EReference_ptr AmaltheaPackage::getAbstractEventChain__items()
{
    return m_AbstractEventChain__items;
}
::ecore::EAttribute_ptr AmaltheaPackage::getAbstractEventChain__itemType()
{
    return m_AbstractEventChain__itemType;
}
::ecore::EAttribute_ptr AmaltheaPackage::getAbstractEventChain__minItemsCompleted()
{
    return m_AbstractEventChain__minItemsCompleted;
}
::ecore::EReference_ptr AmaltheaPackage::getEventChainReference__eventChain()
{
    return m_EventChainReference__eventChain;
}
::ecore::EReference_ptr AmaltheaPackage::getEventChainContainer__eventChain()
{
    return m_EventChainContainer__eventChain;
}
::ecore::EReference_ptr AmaltheaPackage::getPhysicalSectionConstraint__section()
{
    return m_PhysicalSectionConstraint__section;
}
::ecore::EReference_ptr AmaltheaPackage::getPhysicalSectionConstraint__memories()
{
    return m_PhysicalSectionConstraint__memories;
}
::ecore::EAttribute_ptr AmaltheaPackage::getSynchronizationConstraint__multipleOccurrencesAllowed()
{
    return m_SynchronizationConstraint__multipleOccurrencesAllowed;
}
::ecore::EReference_ptr AmaltheaPackage::getSynchronizationConstraint__tolerance()
{
    return m_SynchronizationConstraint__tolerance;
}
::ecore::EReference_ptr AmaltheaPackage::getEventSynchronizationConstraint__events()
{
    return m_EventSynchronizationConstraint__events;
}
::ecore::EReference_ptr AmaltheaPackage::getEventChainSynchronizationConstraint__scope()
{
    return m_EventChainSynchronizationConstraint__scope;
}
::ecore::EAttribute_ptr AmaltheaPackage::getEventChainSynchronizationConstraint__type()
{
    return m_EventChainSynchronizationConstraint__type;
}
::ecore::EAttribute_ptr AmaltheaPackage::getDelayConstraint__mappingType()
{
    return m_DelayConstraint__mappingType;
}
::ecore::EReference_ptr AmaltheaPackage::getDelayConstraint__source()
{
    return m_DelayConstraint__source;
}
::ecore::EReference_ptr AmaltheaPackage::getDelayConstraint__target()
{
    return m_DelayConstraint__target;
}
::ecore::EReference_ptr AmaltheaPackage::getDelayConstraint__upper()
{
    return m_DelayConstraint__upper;
}
::ecore::EReference_ptr AmaltheaPackage::getDelayConstraint__lower()
{
    return m_DelayConstraint__lower;
}
::ecore::EReference_ptr AmaltheaPackage::getEventChainLatencyConstraint__scope()
{
    return m_EventChainLatencyConstraint__scope;
}
::ecore::EAttribute_ptr AmaltheaPackage::getEventChainLatencyConstraint__type()
{
    return m_EventChainLatencyConstraint__type;
}
::ecore::EReference_ptr AmaltheaPackage::getEventChainLatencyConstraint__minimum()
{
    return m_EventChainLatencyConstraint__minimum;
}
::ecore::EReference_ptr AmaltheaPackage::getEventChainLatencyConstraint__maximum()
{
    return m_EventChainLatencyConstraint__maximum;
}
::ecore::EReference_ptr AmaltheaPackage::getRepetitionConstraint__event()
{
    return m_RepetitionConstraint__event;
}
::ecore::EAttribute_ptr AmaltheaPackage::getRepetitionConstraint__span()
{
    return m_RepetitionConstraint__span;
}
::ecore::EReference_ptr AmaltheaPackage::getRepetitionConstraint__lower()
{
    return m_RepetitionConstraint__lower;
}
::ecore::EReference_ptr AmaltheaPackage::getRepetitionConstraint__upper()
{
    return m_RepetitionConstraint__upper;
}
::ecore::EReference_ptr AmaltheaPackage::getRepetitionConstraint__jitter()
{
    return m_RepetitionConstraint__jitter;
}
::ecore::EReference_ptr AmaltheaPackage::getRepetitionConstraint__period()
{
    return m_RepetitionConstraint__period;
}
::ecore::EReference_ptr AmaltheaPackage::getDataAgeConstraint__runnable()
{
    return m_DataAgeConstraint__runnable;
}
::ecore::EReference_ptr AmaltheaPackage::getDataAgeConstraint__label()
{
    return m_DataAgeConstraint__label;
}
::ecore::EReference_ptr AmaltheaPackage::getDataAgeConstraint__dataAge()
{
    return m_DataAgeConstraint__dataAge;
}
::ecore::EAttribute_ptr AmaltheaPackage::getDataAgeCycle__minimumCycle()
{
    return m_DataAgeCycle__minimumCycle;
}
::ecore::EAttribute_ptr AmaltheaPackage::getDataAgeCycle__maximumCycle()
{
    return m_DataAgeCycle__maximumCycle;
}
::ecore::EReference_ptr AmaltheaPackage::getDataAgeTime__minimumTime()
{
    return m_DataAgeTime__minimumTime;
}
::ecore::EReference_ptr AmaltheaPackage::getDataAgeTime__maximumTime()
{
    return m_DataAgeTime__maximumTime;
}
::ecore::EAttribute_ptr AmaltheaPackage::getRequirement__severity()
{
    return m_Requirement__severity;
}
::ecore::EReference_ptr AmaltheaPackage::getRequirement__limit()
{
    return m_Requirement__limit;
}
::ecore::EReference_ptr AmaltheaPackage::getProcessRequirement__process()
{
    return m_ProcessRequirement__process;
}
::ecore::EReference_ptr AmaltheaPackage::getRunnableRequirement__runnable()
{
    return m_RunnableRequirement__runnable;
}
::ecore::EReference_ptr AmaltheaPackage::getArchitectureRequirement__component()
{
    return m_ArchitectureRequirement__component;
}
::ecore::EReference_ptr AmaltheaPackage::getProcessChainRequirement__processChain()
{
    return m_ProcessChainRequirement__processChain;
}
::ecore::EAttribute_ptr AmaltheaPackage::getRequirementLimit__limitType()
{
    return m_RequirementLimit__limitType;
}
::ecore::EAttribute_ptr AmaltheaPackage::getCPUPercentageRequirementLimit__metric()
{
    return m_CPUPercentageRequirementLimit__metric;
}
::ecore::EAttribute_ptr AmaltheaPackage::getCPUPercentageRequirementLimit__limitValue()
{
    return m_CPUPercentageRequirementLimit__limitValue;
}
::ecore::EReference_ptr AmaltheaPackage::getCPUPercentageRequirementLimit__hardwareContext()
{
    return m_CPUPercentageRequirementLimit__hardwareContext;
}
::ecore::EAttribute_ptr AmaltheaPackage::getFrequencyRequirementLimit__metric()
{
    return m_FrequencyRequirementLimit__metric;
}
::ecore::EReference_ptr AmaltheaPackage::getFrequencyRequirementLimit__limitValue()
{
    return m_FrequencyRequirementLimit__limitValue;
}
::ecore::EAttribute_ptr AmaltheaPackage::getPercentageRequirementLimit__metric()
{
    return m_PercentageRequirementLimit__metric;
}
::ecore::EAttribute_ptr AmaltheaPackage::getPercentageRequirementLimit__limitValue()
{
    return m_PercentageRequirementLimit__limitValue;
}
::ecore::EAttribute_ptr AmaltheaPackage::getCountRequirementLimit__metric()
{
    return m_CountRequirementLimit__metric;
}
::ecore::EAttribute_ptr AmaltheaPackage::getCountRequirementLimit__limitValue()
{
    return m_CountRequirementLimit__limitValue;
}
::ecore::EAttribute_ptr AmaltheaPackage::getTimeRequirementLimit__metric()
{
    return m_TimeRequirementLimit__metric;
}
::ecore::EReference_ptr AmaltheaPackage::getTimeRequirementLimit__limitValue()
{
    return m_TimeRequirementLimit__limitValue;
}
::ecore::EReference_ptr AmaltheaPackage::getDataCoherencyGroup__labels()
{
    return m_DataCoherencyGroup__labels;
}
::ecore::EReference_ptr AmaltheaPackage::getDataCoherencyGroup__scope()
{
    return m_DataCoherencyGroup__scope;
}
::ecore::EAttribute_ptr AmaltheaPackage::getDataCoherencyGroup__direction()
{
    return m_DataCoherencyGroup__direction;
}
::ecore::EReference_ptr AmaltheaPackage::getDataStabilityGroup__labels()
{
    return m_DataStabilityGroup__labels;
}
::ecore::EReference_ptr AmaltheaPackage::getDataStabilityGroup__scope()
{
    return m_DataStabilityGroup__scope;
}
::ecore::EReference_ptr AmaltheaPackage::getProcessScope__process()
{
    return m_ProcessScope__process;
}
::ecore::EReference_ptr AmaltheaPackage::getRunnableScope__runnable()
{
    return m_RunnableScope__runnable;
}
::ecore::EReference_ptr AmaltheaPackage::getComponentScope__component()
{
    return m_ComponentScope__component;
}
::ecore::EReference_ptr AmaltheaPackage::getEventModel__events()
{
    return m_EventModel__events;
}
::ecore::EReference_ptr AmaltheaPackage::getEventSet__events()
{
    return m_EventSet__events;
}
::ecore::EAttribute_ptr AmaltheaPackage::getCustomEvent__eventType()
{
    return m_CustomEvent__eventType;
}
::ecore::EReference_ptr AmaltheaPackage::getCustomEvent__explicitTriggers()
{
    return m_CustomEvent__explicitTriggers;
}
::ecore::EReference_ptr AmaltheaPackage::getStimulusEvent__entity()
{
    return m_StimulusEvent__entity;
}
::ecore::EAttribute_ptr AmaltheaPackage::getProcessEvent__eventType()
{
    return m_ProcessEvent__eventType;
}
::ecore::EReference_ptr AmaltheaPackage::getProcessEvent__entity()
{
    return m_ProcessEvent__entity;
}
::ecore::EReference_ptr AmaltheaPackage::getProcessEvent__processingUnit()
{
    return m_ProcessEvent__processingUnit;
}
::ecore::EAttribute_ptr AmaltheaPackage::getProcessChainEvent__eventType()
{
    return m_ProcessChainEvent__eventType;
}
::ecore::EReference_ptr AmaltheaPackage::getProcessChainEvent__entity()
{
    return m_ProcessChainEvent__entity;
}
::ecore::EReference_ptr AmaltheaPackage::getProcessChainEvent__processingUnit()
{
    return m_ProcessChainEvent__processingUnit;
}
::ecore::EAttribute_ptr AmaltheaPackage::getRunnableEvent__eventType()
{
    return m_RunnableEvent__eventType;
}
::ecore::EReference_ptr AmaltheaPackage::getRunnableEvent__entity()
{
    return m_RunnableEvent__entity;
}
::ecore::EReference_ptr AmaltheaPackage::getRunnableEvent__process()
{
    return m_RunnableEvent__process;
}
::ecore::EReference_ptr AmaltheaPackage::getRunnableEvent__processingUnit()
{
    return m_RunnableEvent__processingUnit;
}
::ecore::EAttribute_ptr AmaltheaPackage::getLabelEvent__eventType()
{
    return m_LabelEvent__eventType;
}
::ecore::EReference_ptr AmaltheaPackage::getLabelEvent__entity()
{
    return m_LabelEvent__entity;
}
::ecore::EReference_ptr AmaltheaPackage::getLabelEvent__runnable()
{
    return m_LabelEvent__runnable;
}
::ecore::EReference_ptr AmaltheaPackage::getLabelEvent__process()
{
    return m_LabelEvent__process;
}
::ecore::EAttribute_ptr AmaltheaPackage::getChannelEvent__eventType()
{
    return m_ChannelEvent__eventType;
}
::ecore::EReference_ptr AmaltheaPackage::getChannelEvent__entity()
{
    return m_ChannelEvent__entity;
}
::ecore::EReference_ptr AmaltheaPackage::getChannelEvent__runnable()
{
    return m_ChannelEvent__runnable;
}
::ecore::EReference_ptr AmaltheaPackage::getChannelEvent__process()
{
    return m_ChannelEvent__process;
}
::ecore::EAttribute_ptr AmaltheaPackage::getSemaphoreEvent__eventType()
{
    return m_SemaphoreEvent__eventType;
}
::ecore::EReference_ptr AmaltheaPackage::getSemaphoreEvent__entity()
{
    return m_SemaphoreEvent__entity;
}
::ecore::EReference_ptr AmaltheaPackage::getSemaphoreEvent__runnable()
{
    return m_SemaphoreEvent__runnable;
}
::ecore::EReference_ptr AmaltheaPackage::getSemaphoreEvent__process()
{
    return m_SemaphoreEvent__process;
}
::ecore::EReference_ptr AmaltheaPackage::getSemaphoreEvent__processingUnit()
{
    return m_SemaphoreEvent__processingUnit;
}
::ecore::EAttribute_ptr AmaltheaPackage::getComponentEvent__eventType()
{
    return m_ComponentEvent__eventType;
}
::ecore::EReference_ptr AmaltheaPackage::getComponentEvent__entity()
{
    return m_ComponentEvent__entity;
}
::ecore::EReference_ptr AmaltheaPackage::getHWModel__definitions()
{
    return m_HWModel__definitions;
}
::ecore::EReference_ptr AmaltheaPackage::getHWModel__featureCategories()
{
    return m_HWModel__featureCategories;
}
::ecore::EReference_ptr AmaltheaPackage::getHWModel__structures()
{
    return m_HWModel__structures;
}
::ecore::EReference_ptr AmaltheaPackage::getHWModel__domains()
{
    return m_HWModel__domains;
}
::ecore::EAttribute_ptr AmaltheaPackage::getHwStructure__structureType()
{
    return m_HwStructure__structureType;
}
::ecore::EReference_ptr AmaltheaPackage::getHwStructure__ports()
{
    return m_HwStructure__ports;
}
::ecore::EReference_ptr AmaltheaPackage::getHwStructure__structures()
{
    return m_HwStructure__structures;
}
::ecore::EReference_ptr AmaltheaPackage::getHwStructure__modules()
{
    return m_HwStructure__modules;
}
::ecore::EReference_ptr AmaltheaPackage::getHwStructure__connections()
{
    return m_HwStructure__connections;
}
::ecore::EReference_ptr AmaltheaPackage::getHwStructure__innerPorts()
{
    return m_HwStructure__innerPorts;
}
::ecore::EReference_ptr AmaltheaPackage::getHwModule__ports()
{
    return m_HwModule__ports;
}
::ecore::EReference_ptr AmaltheaPackage::getHwModule__powerDomain()
{
    return m_HwModule__powerDomain;
}
::ecore::EReference_ptr AmaltheaPackage::getHwModule__frequencyDomain()
{
    return m_HwModule__frequencyDomain;
}
::ecore::EReference_ptr AmaltheaPackage::getFrequencyDomain__defaultValue()
{
    return m_FrequencyDomain__defaultValue;
}
::ecore::EAttribute_ptr AmaltheaPackage::getFrequencyDomain__clockGating()
{
    return m_FrequencyDomain__clockGating;
}
::ecore::EReference_ptr AmaltheaPackage::getPowerDomain__defaultValue()
{
    return m_PowerDomain__defaultValue;
}
::ecore::EAttribute_ptr AmaltheaPackage::getPowerDomain__powerGating()
{
    return m_PowerDomain__powerGating;
}
::ecore::EReference_ptr AmaltheaPackage::getProcessingUnit__definition()
{
    return m_ProcessingUnit__definition;
}
::ecore::EReference_ptr AmaltheaPackage::getProcessingUnit__accessElements()
{
    return m_ProcessingUnit__accessElements;
}
::ecore::EReference_ptr AmaltheaPackage::getProcessingUnit__caches()
{
    return m_ProcessingUnit__caches;
}
::ecore::EReference_ptr AmaltheaPackage::getMemory__definition()
{
    return m_Memory__definition;
}
::ecore::EReference_ptr AmaltheaPackage::getMemory__mappings()
{
    return m_Memory__mappings;
}
::ecore::EReference_ptr AmaltheaPackage::getCache__definition()
{
    return m_Cache__definition;
}
::ecore::EAttribute_ptr AmaltheaPackage::getHwFeatureCategory__featureType()
{
    return m_HwFeatureCategory__featureType;
}
::ecore::EReference_ptr AmaltheaPackage::getHwFeatureCategory__features()
{
    return m_HwFeatureCategory__features;
}
::ecore::EReference_ptr AmaltheaPackage::getHwFeature__containingCategory()
{
    return m_HwFeature__containingCategory;
}
::ecore::EAttribute_ptr AmaltheaPackage::getHwFeature__value()
{
    return m_HwFeature__value;
}
::ecore::EAttribute_ptr AmaltheaPackage::getHwPort__bitWidth()
{
    return m_HwPort__bitWidth;
}
::ecore::EAttribute_ptr AmaltheaPackage::getHwPort__priority()
{
    return m_HwPort__priority;
}
::ecore::EAttribute_ptr AmaltheaPackage::getHwPort__portType()
{
    return m_HwPort__portType;
}
::ecore::EAttribute_ptr AmaltheaPackage::getHwPort__portInterface()
{
    return m_HwPort__portInterface;
}
::ecore::EAttribute_ptr AmaltheaPackage::getHwPort__delegated()
{
    return m_HwPort__delegated;
}
::ecore::EReference_ptr AmaltheaPackage::getHwPort__connections()
{
    return m_HwPort__connections;
}
::ecore::EReference_ptr AmaltheaPackage::getConnectionHandler__definition()
{
    return m_ConnectionHandler__definition;
}
::ecore::EReference_ptr AmaltheaPackage::getConnectionHandler__internalConnections()
{
    return m_ConnectionHandler__internalConnections;
}
::ecore::EReference_ptr AmaltheaPackage::getHwConnection__readLatency()
{
    return m_HwConnection__readLatency;
}
::ecore::EReference_ptr AmaltheaPackage::getHwConnection__writeLatency()
{
    return m_HwConnection__writeLatency;
}
::ecore::EReference_ptr AmaltheaPackage::getHwConnection__dataRate()
{
    return m_HwConnection__dataRate;
}
::ecore::EReference_ptr AmaltheaPackage::getHwConnection__port1()
{
    return m_HwConnection__port1;
}
::ecore::EReference_ptr AmaltheaPackage::getHwConnection__port2()
{
    return m_HwConnection__port2;
}
::ecore::EAttribute_ptr AmaltheaPackage::getHwConnection__internal()
{
    return m_HwConnection__internal;
}
::ecore::EReference_ptr AmaltheaPackage::getHwAccessElement__source()
{
    return m_HwAccessElement__source;
}
::ecore::EReference_ptr AmaltheaPackage::getHwAccessElement__destination()
{
    return m_HwAccessElement__destination;
}
::ecore::EReference_ptr AmaltheaPackage::getHwAccessElement__accessPath()
{
    return m_HwAccessElement__accessPath;
}
::ecore::EReference_ptr AmaltheaPackage::getHwAccessElement__readLatency()
{
    return m_HwAccessElement__readLatency;
}
::ecore::EReference_ptr AmaltheaPackage::getHwAccessElement__writeLatency()
{
    return m_HwAccessElement__writeLatency;
}
::ecore::EReference_ptr AmaltheaPackage::getHwAccessElement__dataRate()
{
    return m_HwAccessElement__dataRate;
}
::ecore::EAttribute_ptr AmaltheaPackage::getProcessingUnitDefinition__puType()
{
    return m_ProcessingUnitDefinition__puType;
}
::ecore::EReference_ptr AmaltheaPackage::getProcessingUnitDefinition__features()
{
    return m_ProcessingUnitDefinition__features;
}
::ecore::EReference_ptr AmaltheaPackage::getProcessingUnitDefinition__classifiers()
{
    return m_ProcessingUnitDefinition__classifiers;
}
::ecore::EAttribute_ptr AmaltheaPackage::getConnectionHandlerDefinition__policy()
{
    return m_ConnectionHandlerDefinition__policy;
}
::ecore::EReference_ptr AmaltheaPackage::getConnectionHandlerDefinition__readLatency()
{
    return m_ConnectionHandlerDefinition__readLatency;
}
::ecore::EReference_ptr AmaltheaPackage::getConnectionHandlerDefinition__writeLatency()
{
    return m_ConnectionHandlerDefinition__writeLatency;
}
::ecore::EReference_ptr AmaltheaPackage::getConnectionHandlerDefinition__dataRate()
{
    return m_ConnectionHandlerDefinition__dataRate;
}
::ecore::EAttribute_ptr AmaltheaPackage::getConnectionHandlerDefinition__maxBurstSize()
{
    return m_ConnectionHandlerDefinition__maxBurstSize;
}
::ecore::EAttribute_ptr AmaltheaPackage::getConnectionHandlerDefinition__maxConcurrentTransfers()
{
    return m_ConnectionHandlerDefinition__maxConcurrentTransfers;
}
::ecore::EReference_ptr AmaltheaPackage::getMemoryDefinition__size()
{
    return m_MemoryDefinition__size;
}
::ecore::EReference_ptr AmaltheaPackage::getMemoryDefinition__accessLatency()
{
    return m_MemoryDefinition__accessLatency;
}
::ecore::EReference_ptr AmaltheaPackage::getMemoryDefinition__dataRate()
{
    return m_MemoryDefinition__dataRate;
}
::ecore::EAttribute_ptr AmaltheaPackage::getMemoryDefinition__memoryType()
{
    return m_MemoryDefinition__memoryType;
}
::ecore::EReference_ptr AmaltheaPackage::getMemoryDefinition__classifiers()
{
    return m_MemoryDefinition__classifiers;
}
::ecore::EReference_ptr AmaltheaPackage::getCacheDefinition__size()
{
    return m_CacheDefinition__size;
}
::ecore::EReference_ptr AmaltheaPackage::getCacheDefinition__lineSize()
{
    return m_CacheDefinition__lineSize;
}
::ecore::EReference_ptr AmaltheaPackage::getCacheDefinition__accessLatency()
{
    return m_CacheDefinition__accessLatency;
}
::ecore::EAttribute_ptr AmaltheaPackage::getCacheDefinition__cacheType()
{
    return m_CacheDefinition__cacheType;
}
::ecore::EAttribute_ptr AmaltheaPackage::getCacheDefinition__writeStrategy()
{
    return m_CacheDefinition__writeStrategy;
}
::ecore::EAttribute_ptr AmaltheaPackage::getCacheDefinition__nWays()
{
    return m_CacheDefinition__nWays;
}
::ecore::EAttribute_ptr AmaltheaPackage::getCacheDefinition__coherency()
{
    return m_CacheDefinition__coherency;
}
::ecore::EAttribute_ptr AmaltheaPackage::getCacheDefinition__exclusive()
{
    return m_CacheDefinition__exclusive;
}
::ecore::EAttribute_ptr AmaltheaPackage::getCacheDefinition__hitRate()
{
    return m_CacheDefinition__hitRate;
}
::ecore::EReference_ptr AmaltheaPackage::getHwPath__source()
{
    return m_HwPath__source;
}
::ecore::EReference_ptr AmaltheaPackage::getHwPath__destination()
{
    return m_HwPath__destination;
}
::ecore::EReference_ptr AmaltheaPackage::getHwAccessPath__containingAccessElement()
{
    return m_HwAccessPath__containingAccessElement;
}
::ecore::EReference_ptr AmaltheaPackage::getHwAccessPath__pathElements()
{
    return m_HwAccessPath__pathElements;
}
::ecore::EAttribute_ptr AmaltheaPackage::getHwAccessPath__startAddress()
{
    return m_HwAccessPath__startAddress;
}
::ecore::EAttribute_ptr AmaltheaPackage::getHwAccessPath__endAddress()
{
    return m_HwAccessPath__endAddress;
}
::ecore::EAttribute_ptr AmaltheaPackage::getHwAccessPath__memOffset()
{
    return m_HwAccessPath__memOffset;
}
::ecore::EReference_ptr AmaltheaPackage::getMappingModel__schedulerAllocation()
{
    return m_MappingModel__schedulerAllocation;
}
::ecore::EReference_ptr AmaltheaPackage::getMappingModel__runnableAllocation()
{
    return m_MappingModel__runnableAllocation;
}
::ecore::EReference_ptr AmaltheaPackage::getMappingModel__taskAllocation()
{
    return m_MappingModel__taskAllocation;
}
::ecore::EReference_ptr AmaltheaPackage::getMappingModel__isrAllocation()
{
    return m_MappingModel__isrAllocation;
}
::ecore::EReference_ptr AmaltheaPackage::getMappingModel__memoryMapping()
{
    return m_MappingModel__memoryMapping;
}
::ecore::EReference_ptr AmaltheaPackage::getMappingModel__physicalSectionMapping()
{
    return m_MappingModel__physicalSectionMapping;
}
::ecore::EAttribute_ptr AmaltheaPackage::getMappingModel__addressMappingType()
{
    return m_MappingModel__addressMappingType;
}
::ecore::EReference_ptr AmaltheaPackage::getSchedulerAllocation__scheduler()
{
    return m_SchedulerAllocation__scheduler;
}
::ecore::EReference_ptr AmaltheaPackage::getSchedulerAllocation__responsibility()
{
    return m_SchedulerAllocation__responsibility;
}
::ecore::EReference_ptr AmaltheaPackage::getSchedulerAllocation__executingPU()
{
    return m_SchedulerAllocation__executingPU;
}
::ecore::EReference_ptr AmaltheaPackage::getTaskAllocation__task()
{
    return m_TaskAllocation__task;
}
::ecore::EReference_ptr AmaltheaPackage::getTaskAllocation__scheduler()
{
    return m_TaskAllocation__scheduler;
}
::ecore::EReference_ptr AmaltheaPackage::getTaskAllocation__affinity()
{
    return m_TaskAllocation__affinity;
}
::ecore::EReference_ptr AmaltheaPackage::getTaskAllocation__schedulingParameters()
{
    return m_TaskAllocation__schedulingParameters;
}
::ecore::EReference_ptr AmaltheaPackage::getTaskAllocation__parameterExtensions()
{
    return m_TaskAllocation__parameterExtensions;
}
::ecore::EReference_ptr AmaltheaPackage::getISRAllocation__isr()
{
    return m_ISRAllocation__isr;
}
::ecore::EReference_ptr AmaltheaPackage::getISRAllocation__controller()
{
    return m_ISRAllocation__controller;
}
::ecore::EAttribute_ptr AmaltheaPackage::getISRAllocation__priority()
{
    return m_ISRAllocation__priority;
}
::ecore::EReference_ptr AmaltheaPackage::getRunnableAllocation__scheduler()
{
    return m_RunnableAllocation__scheduler;
}
::ecore::EReference_ptr AmaltheaPackage::getRunnableAllocation__entity()
{
    return m_RunnableAllocation__entity;
}
::ecore::EReference_ptr AmaltheaPackage::getMemoryMapping__abstractElement()
{
    return m_MemoryMapping__abstractElement;
}
::ecore::EReference_ptr AmaltheaPackage::getMemoryMapping__memory()
{
    return m_MemoryMapping__memory;
}
::ecore::EAttribute_ptr AmaltheaPackage::getMemoryMapping__memoryPositionAddress()
{
    return m_MemoryMapping__memoryPositionAddress;
}
::ecore::EReference_ptr AmaltheaPackage::getPhysicalSectionMapping__origin()
{
    return m_PhysicalSectionMapping__origin;
}
::ecore::EReference_ptr AmaltheaPackage::getPhysicalSectionMapping__memory()
{
    return m_PhysicalSectionMapping__memory;
}
::ecore::EAttribute_ptr AmaltheaPackage::getPhysicalSectionMapping__startAddress()
{
    return m_PhysicalSectionMapping__startAddress;
}
::ecore::EAttribute_ptr AmaltheaPackage::getPhysicalSectionMapping__endAddress()
{
    return m_PhysicalSectionMapping__endAddress;
}
::ecore::EReference_ptr AmaltheaPackage::getPhysicalSectionMapping__labels()
{
    return m_PhysicalSectionMapping__labels;
}
::ecore::EReference_ptr AmaltheaPackage::getPhysicalSectionMapping__runEntities()
{
    return m_PhysicalSectionMapping__runEntities;
}
::ecore::EReference_ptr AmaltheaPackage::getOSModel__semaphores()
{
    return m_OSModel__semaphores;
}
::ecore::EReference_ptr AmaltheaPackage::getOSModel__operatingSystems()
{
    return m_OSModel__operatingSystems;
}
::ecore::EReference_ptr AmaltheaPackage::getOSModel__osOverheads()
{
    return m_OSModel__osOverheads;
}
::ecore::EAttribute_ptr AmaltheaPackage::getOsDataConsistency__mode()
{
    return m_OsDataConsistency__mode;
}
::ecore::EReference_ptr AmaltheaPackage::getOsDataConsistency__dataStability()
{
    return m_OsDataConsistency__dataStability;
}
::ecore::EReference_ptr AmaltheaPackage::getOsDataConsistency__nonAtomicDataCoherency()
{
    return m_OsDataConsistency__nonAtomicDataCoherency;
}
::ecore::EAttribute_ptr AmaltheaPackage::getDataStability__enabled()
{
    return m_DataStability__enabled;
}
::ecore::EAttribute_ptr AmaltheaPackage::getDataStability__algorithm()
{
    return m_DataStability__algorithm;
}
::ecore::EAttribute_ptr AmaltheaPackage::getDataStability__accessMultiplicity()
{
    return m_DataStability__accessMultiplicity;
}
::ecore::EAttribute_ptr AmaltheaPackage::getDataStability__level()
{
    return m_DataStability__level;
}
::ecore::EAttribute_ptr AmaltheaPackage::getNonAtomicDataCoherency__enabled()
{
    return m_NonAtomicDataCoherency__enabled;
}
::ecore::EAttribute_ptr AmaltheaPackage::getNonAtomicDataCoherency__algorithm()
{
    return m_NonAtomicDataCoherency__algorithm;
}
::ecore::EAttribute_ptr AmaltheaPackage::getNonAtomicDataCoherency__accessMultiplicity()
{
    return m_NonAtomicDataCoherency__accessMultiplicity;
}
::ecore::EAttribute_ptr AmaltheaPackage::getSemaphore__semaphoreType()
{
    return m_Semaphore__semaphoreType;
}
::ecore::EAttribute_ptr AmaltheaPackage::getSemaphore__initialValue()
{
    return m_Semaphore__initialValue;
}
::ecore::EAttribute_ptr AmaltheaPackage::getSemaphore__maxValue()
{
    return m_Semaphore__maxValue;
}
::ecore::EAttribute_ptr AmaltheaPackage::getSemaphore__priorityCeilingProtocol()
{
    return m_Semaphore__priorityCeilingProtocol;
}
::ecore::EReference_ptr AmaltheaPackage::getSemaphore__semaphoreAccesses()
{
    return m_Semaphore__semaphoreAccesses;
}
::ecore::EReference_ptr AmaltheaPackage::getSemaphore__referringComponents()
{
    return m_Semaphore__referringComponents;
}
::ecore::EReference_ptr AmaltheaPackage::getScheduler__computationItems()
{
    return m_Scheduler__computationItems;
}
::ecore::EReference_ptr AmaltheaPackage::getScheduler__schedulerAllocations()
{
    return m_Scheduler__schedulerAllocations;
}
::ecore::EReference_ptr AmaltheaPackage::getScheduler__runnableAllocations()
{
    return m_Scheduler__runnableAllocations;
}
::ecore::EReference_ptr AmaltheaPackage::getTaskScheduler__schedulingAlgorithm()
{
    return m_TaskScheduler__schedulingAlgorithm;
}
::ecore::EReference_ptr AmaltheaPackage::getTaskScheduler__parentAssociation()
{
    return m_TaskScheduler__parentAssociation;
}
::ecore::EReference_ptr AmaltheaPackage::getTaskScheduler__childAssociations()
{
    return m_TaskScheduler__childAssociations;
}
::ecore::EReference_ptr AmaltheaPackage::getTaskScheduler__taskAllocations()
{
    return m_TaskScheduler__taskAllocations;
}
::ecore::EReference_ptr AmaltheaPackage::getTaskScheduler__parentScheduler()
{
    return m_TaskScheduler__parentScheduler;
}
::ecore::EReference_ptr AmaltheaPackage::getTaskScheduler__childSchedulers()
{
    return m_TaskScheduler__childSchedulers;
}
::ecore::EReference_ptr AmaltheaPackage::getSchedulerAssociation__child()
{
    return m_SchedulerAssociation__child;
}
::ecore::EReference_ptr AmaltheaPackage::getSchedulerAssociation__parent()
{
    return m_SchedulerAssociation__parent;
}
::ecore::EReference_ptr AmaltheaPackage::getSchedulerAssociation__schedulingParameters()
{
    return m_SchedulerAssociation__schedulingParameters;
}
::ecore::EReference_ptr AmaltheaPackage::getSchedulerAssociation__parameterExtensions()
{
    return m_SchedulerAssociation__parameterExtensions;
}
::ecore::EReference_ptr AmaltheaPackage::getInterruptController__schedulingAlgorithm()
{
    return m_InterruptController__schedulingAlgorithm;
}
::ecore::EReference_ptr AmaltheaPackage::getInterruptController__isrAllocations()
{
    return m_InterruptController__isrAllocations;
}
::ecore::EAttribute_ptr AmaltheaPackage::getSchedulingParameters__priority()
{
    return m_SchedulingParameters__priority;
}
::ecore::EReference_ptr AmaltheaPackage::getSchedulingParameters__minBudget()
{
    return m_SchedulingParameters__minBudget;
}
::ecore::EReference_ptr AmaltheaPackage::getSchedulingParameters__maxBudget()
{
    return m_SchedulingParameters__maxBudget;
}
::ecore::EReference_ptr AmaltheaPackage::getSchedulingParameters__replenishment()
{
    return m_SchedulingParameters__replenishment;
}
::ecore::EAttribute_ptr AmaltheaPackage::getParameterExtension__key()
{
    return m_ParameterExtension__key;
}
::ecore::EAttribute_ptr AmaltheaPackage::getParameterExtension__value()
{
    return m_ParameterExtension__value;
}
::ecore::EAttribute_ptr AmaltheaPackage::getPfair__quantSizeNs()
{
    return m_Pfair__quantSizeNs;
}
::ecore::EReference_ptr AmaltheaPackage::getUserSpecificSchedulingAlgorithm__parameterExtensions()
{
    return m_UserSpecificSchedulingAlgorithm__parameterExtensions;
}
::ecore::EReference_ptr AmaltheaPackage::getOperatingSystem__overhead()
{
    return m_OperatingSystem__overhead;
}
::ecore::EReference_ptr AmaltheaPackage::getOperatingSystem__taskSchedulers()
{
    return m_OperatingSystem__taskSchedulers;
}
::ecore::EReference_ptr AmaltheaPackage::getOperatingSystem__interruptControllers()
{
    return m_OperatingSystem__interruptControllers;
}
::ecore::EReference_ptr AmaltheaPackage::getOperatingSystem__osDataConsistency()
{
    return m_OperatingSystem__osDataConsistency;
}
::ecore::EAttribute_ptr AmaltheaPackage::getVendorOperatingSystem__osName()
{
    return m_VendorOperatingSystem__osName;
}
::ecore::EAttribute_ptr AmaltheaPackage::getVendorOperatingSystem__vendor()
{
    return m_VendorOperatingSystem__vendor;
}
::ecore::EAttribute_ptr AmaltheaPackage::getVendorOperatingSystem__version()
{
    return m_VendorOperatingSystem__version;
}
::ecore::EReference_ptr AmaltheaPackage::getOsOverhead__apiOverhead()
{
    return m_OsOverhead__apiOverhead;
}
::ecore::EReference_ptr AmaltheaPackage::getOsOverhead__isrCategory1Overhead()
{
    return m_OsOverhead__isrCategory1Overhead;
}
::ecore::EReference_ptr AmaltheaPackage::getOsOverhead__isrCategory2Overhead()
{
    return m_OsOverhead__isrCategory2Overhead;
}
::ecore::EReference_ptr AmaltheaPackage::getOsAPIOverhead__apiSendMessage()
{
    return m_OsAPIOverhead__apiSendMessage;
}
::ecore::EReference_ptr AmaltheaPackage::getOsAPIOverhead__apiTerminateTask()
{
    return m_OsAPIOverhead__apiTerminateTask;
}
::ecore::EReference_ptr AmaltheaPackage::getOsAPIOverhead__apiSchedule()
{
    return m_OsAPIOverhead__apiSchedule;
}
::ecore::EReference_ptr AmaltheaPackage::getOsAPIOverhead__apiRequestResource()
{
    return m_OsAPIOverhead__apiRequestResource;
}
::ecore::EReference_ptr AmaltheaPackage::getOsAPIOverhead__apiReleaseResource()
{
    return m_OsAPIOverhead__apiReleaseResource;
}
::ecore::EReference_ptr AmaltheaPackage::getOsAPIOverhead__apiSetEvent()
{
    return m_OsAPIOverhead__apiSetEvent;
}
::ecore::EReference_ptr AmaltheaPackage::getOsAPIOverhead__apiWaitEvent()
{
    return m_OsAPIOverhead__apiWaitEvent;
}
::ecore::EReference_ptr AmaltheaPackage::getOsAPIOverhead__apiClearEvent()
{
    return m_OsAPIOverhead__apiClearEvent;
}
::ecore::EReference_ptr AmaltheaPackage::getOsAPIOverhead__apiActivateTask()
{
    return m_OsAPIOverhead__apiActivateTask;
}
::ecore::EReference_ptr AmaltheaPackage::getOsAPIOverhead__apiEnforcedMigration()
{
    return m_OsAPIOverhead__apiEnforcedMigration;
}
::ecore::EReference_ptr AmaltheaPackage::getOsAPIOverhead__apiSuspendOsInterrupts()
{
    return m_OsAPIOverhead__apiSuspendOsInterrupts;
}
::ecore::EReference_ptr AmaltheaPackage::getOsAPIOverhead__apiResumeOsInterrupts()
{
    return m_OsAPIOverhead__apiResumeOsInterrupts;
}
::ecore::EReference_ptr AmaltheaPackage::getOsAPIOverhead__apiRequestSpinlock()
{
    return m_OsAPIOverhead__apiRequestSpinlock;
}
::ecore::EReference_ptr AmaltheaPackage::getOsAPIOverhead__apiReleaseSpinlock()
{
    return m_OsAPIOverhead__apiReleaseSpinlock;
}
::ecore::EReference_ptr AmaltheaPackage::getOsAPIOverhead__apiSenderReceiverRead()
{
    return m_OsAPIOverhead__apiSenderReceiverRead;
}
::ecore::EReference_ptr AmaltheaPackage::getOsAPIOverhead__apiSenderReceiverWrite()
{
    return m_OsAPIOverhead__apiSenderReceiverWrite;
}
::ecore::EReference_ptr AmaltheaPackage::getOsAPIOverhead__apiSynchronousServerCallPoint()
{
    return m_OsAPIOverhead__apiSynchronousServerCallPoint;
}
::ecore::EReference_ptr AmaltheaPackage::getOsAPIOverhead__apiIocRead()
{
    return m_OsAPIOverhead__apiIocRead;
}
::ecore::EReference_ptr AmaltheaPackage::getOsAPIOverhead__apiIocWrite()
{
    return m_OsAPIOverhead__apiIocWrite;
}
::ecore::EReference_ptr AmaltheaPackage::getOsISROverhead__preExecutionOverhead()
{
    return m_OsISROverhead__preExecutionOverhead;
}
::ecore::EReference_ptr AmaltheaPackage::getOsISROverhead__postExecutionOverhead()
{
    return m_OsISROverhead__postExecutionOverhead;
}
::ecore::EReference_ptr AmaltheaPackage::getPropertyConstraintsModel__allocationConstraints()
{
    return m_PropertyConstraintsModel__allocationConstraints;
}
::ecore::EReference_ptr AmaltheaPackage::getPropertyConstraintsModel__mappingConstraints()
{
    return m_PropertyConstraintsModel__mappingConstraints;
}
::ecore::EReference_ptr AmaltheaPackage::getCoreAllocationConstraint__coreClassification()
{
    return m_CoreAllocationConstraint__coreClassification;
}
::ecore::EReference_ptr AmaltheaPackage::getMemoryMappingConstraint__memoryClassification()
{
    return m_MemoryMappingConstraint__memoryClassification;
}
::ecore::EReference_ptr AmaltheaPackage::getProcessAllocationConstraint__process()
{
    return m_ProcessAllocationConstraint__process;
}
::ecore::EReference_ptr AmaltheaPackage::getProcessPrototypeAllocationConstraint__processPrototype()
{
    return m_ProcessPrototypeAllocationConstraint__processPrototype;
}
::ecore::EReference_ptr AmaltheaPackage::getRunnableAllocationConstraint__runnable()
{
    return m_RunnableAllocationConstraint__runnable;
}
::ecore::EReference_ptr AmaltheaPackage::getAbstractElementMappingConstraint__abstractElement()
{
    return m_AbstractElementMappingConstraint__abstractElement;
}
::ecore::EAttribute_ptr AmaltheaPackage::getClassification__condition()
{
    return m_Classification__condition;
}
::ecore::EAttribute_ptr AmaltheaPackage::getClassification__grouping()
{
    return m_Classification__grouping;
}
::ecore::EReference_ptr AmaltheaPackage::getCoreClassification__classifiers()
{
    return m_CoreClassification__classifiers;
}
::ecore::EReference_ptr AmaltheaPackage::getMemoryClassification__classifiers()
{
    return m_MemoryClassification__classifiers;
}
::ecore::EReference_ptr AmaltheaPackage::getStimuliModel__stimuli()
{
    return m_StimuliModel__stimuli;
}
::ecore::EReference_ptr AmaltheaPackage::getStimuliModel__clocks()
{
    return m_StimuliModel__clocks;
}
::ecore::EReference_ptr AmaltheaPackage::getStimulus__setModeValueList()
{
    return m_Stimulus__setModeValueList;
}
::ecore::EReference_ptr AmaltheaPackage::getStimulus__executionCondition()
{
    return m_Stimulus__executionCondition;
}
::ecore::EReference_ptr AmaltheaPackage::getStimulus__affectedProcesses()
{
    return m_Stimulus__affectedProcesses;
}
::ecore::EReference_ptr AmaltheaPackage::getModeValueList__entries()
{
    return m_ModeValueList__entries;
}
::ecore::EReference_ptr AmaltheaPackage::getModeValueMapEntry__key()
{
    return m_ModeValueMapEntry__key;
}
::ecore::EAttribute_ptr AmaltheaPackage::getModeValueMapEntry__value()
{
    return m_ModeValueMapEntry__value;
}
::ecore::EReference_ptr AmaltheaPackage::getModeValue__label()
{
    return m_ModeValue__label;
}
::ecore::EAttribute_ptr AmaltheaPackage::getModeValue__value()
{
    return m_ModeValue__value;
}
::ecore::EReference_ptr AmaltheaPackage::getModeConditionDisjunction__entries()
{
    return m_ModeConditionDisjunction__entries;
}
::ecore::EAttribute_ptr AmaltheaPackage::getModeCondition__relation()
{
    return m_ModeCondition__relation;
}
::ecore::EReference_ptr AmaltheaPackage::getModeLabelCondition__label1()
{
    return m_ModeLabelCondition__label1;
}
::ecore::EReference_ptr AmaltheaPackage::getModeLabelCondition__label2()
{
    return m_ModeLabelCondition__label2;
}
::ecore::EReference_ptr AmaltheaPackage::getModeConditionConjunction__entries()
{
    return m_ModeConditionConjunction__entries;
}
::ecore::EReference_ptr AmaltheaPackage::getFixedPeriodic__recurrence()
{
    return m_FixedPeriodic__recurrence;
}
::ecore::EReference_ptr AmaltheaPackage::getFixedPeriodic__offset()
{
    return m_FixedPeriodic__offset;
}
::ecore::EReference_ptr AmaltheaPackage::getPeriodicStimulus__jitter()
{
    return m_PeriodicStimulus__jitter;
}
::ecore::EReference_ptr AmaltheaPackage::getPeriodicStimulus__minDistance()
{
    return m_PeriodicStimulus__minDistance;
}
::ecore::EReference_ptr AmaltheaPackage::getRelativePeriodicStimulus__offset()
{
    return m_RelativePeriodicStimulus__offset;
}
::ecore::EReference_ptr AmaltheaPackage::getRelativePeriodicStimulus__nextOccurrence()
{
    return m_RelativePeriodicStimulus__nextOccurrence;
}
::ecore::EReference_ptr AmaltheaPackage::getVariableRateStimulus__step()
{
    return m_VariableRateStimulus__step;
}
::ecore::EReference_ptr AmaltheaPackage::getVariableRateStimulus__occurrencesPerStep()
{
    return m_VariableRateStimulus__occurrencesPerStep;
}
::ecore::EAttribute_ptr AmaltheaPackage::getVariableRateStimulus__maxIncreasePerStep()
{
    return m_VariableRateStimulus__maxIncreasePerStep;
}
::ecore::EAttribute_ptr AmaltheaPackage::getVariableRateStimulus__maxDecreasePerStep()
{
    return m_VariableRateStimulus__maxDecreasePerStep;
}
::ecore::EReference_ptr AmaltheaPackage::getVariableRateStimulus__scenario()
{
    return m_VariableRateStimulus__scenario;
}
::ecore::EReference_ptr AmaltheaPackage::getScenario__clock()
{
    return m_Scenario__clock;
}
::ecore::EAttribute_ptr AmaltheaPackage::getScenario__samplingOffset()
{
    return m_Scenario__samplingOffset;
}
::ecore::EAttribute_ptr AmaltheaPackage::getScenario__samplingRecurrence()
{
    return m_Scenario__samplingRecurrence;
}
::ecore::EReference_ptr AmaltheaPackage::getPeriodicSyntheticStimulus__occurrenceTimes()
{
    return m_PeriodicSyntheticStimulus__occurrenceTimes;
}
::ecore::EReference_ptr AmaltheaPackage::getSingleStimulus__occurrence()
{
    return m_SingleStimulus__occurrence;
}
::ecore::EReference_ptr AmaltheaPackage::getInterProcessStimulus__counter()
{
    return m_InterProcessStimulus__counter;
}
::ecore::EReference_ptr AmaltheaPackage::getInterProcessStimulus__explicitTriggers()
{
    return m_InterProcessStimulus__explicitTriggers;
}
::ecore::EReference_ptr AmaltheaPackage::getPeriodicBurstStimulus__burstLength()
{
    return m_PeriodicBurstStimulus__burstLength;
}
::ecore::EReference_ptr AmaltheaPackage::getPeriodicBurstStimulus__occurrenceMinDistance()
{
    return m_PeriodicBurstStimulus__occurrenceMinDistance;
}
::ecore::EAttribute_ptr AmaltheaPackage::getPeriodicBurstStimulus__occurrenceCount()
{
    return m_PeriodicBurstStimulus__occurrenceCount;
}
::ecore::EReference_ptr AmaltheaPackage::getEventStimulus__triggeringEvents()
{
    return m_EventStimulus__triggeringEvents;
}
::ecore::EReference_ptr AmaltheaPackage::getEventStimulus__counter()
{
    return m_EventStimulus__counter;
}
::ecore::EReference_ptr AmaltheaPackage::getArrivalCurveStimulus__entries()
{
    return m_ArrivalCurveStimulus__entries;
}
::ecore::EAttribute_ptr AmaltheaPackage::getArrivalCurveEntry__numberOfOccurrences()
{
    return m_ArrivalCurveEntry__numberOfOccurrences;
}
::ecore::EReference_ptr AmaltheaPackage::getArrivalCurveEntry__lowerTimeBorder()
{
    return m_ArrivalCurveEntry__lowerTimeBorder;
}
::ecore::EReference_ptr AmaltheaPackage::getArrivalCurveEntry__upperTimeBorder()
{
    return m_ArrivalCurveEntry__upperTimeBorder;
}
::ecore::EAttribute_ptr AmaltheaPackage::getClockFunction__curveType()
{
    return m_ClockFunction__curveType;
}
::ecore::EReference_ptr AmaltheaPackage::getClockFunction__period()
{
    return m_ClockFunction__period;
}
::ecore::EReference_ptr AmaltheaPackage::getClockFunction__peakToPeak()
{
    return m_ClockFunction__peakToPeak;
}
::ecore::EReference_ptr AmaltheaPackage::getClockFunction__xOffset()
{
    return m_ClockFunction__xOffset;
}
::ecore::EReference_ptr AmaltheaPackage::getClockFunction__yOffset()
{
    return m_ClockFunction__yOffset;
}
::ecore::EReference_ptr AmaltheaPackage::getClockStepList__entries()
{
    return m_ClockStepList__entries;
}
::ecore::EReference_ptr AmaltheaPackage::getClockStepList__period()
{
    return m_ClockStepList__period;
}
::ecore::EReference_ptr AmaltheaPackage::getClockStep__frequency()
{
    return m_ClockStep__frequency;
}
::ecore::EReference_ptr AmaltheaPackage::getClockStep__time()
{
    return m_ClockStep__time;
}
::ecore::EReference_ptr AmaltheaPackage::getSWModel__isrs()
{
    return m_SWModel__isrs;
}
::ecore::EReference_ptr AmaltheaPackage::getSWModel__tasks()
{
    return m_SWModel__tasks;
}
::ecore::EReference_ptr AmaltheaPackage::getSWModel__runnables()
{
    return m_SWModel__runnables;
}
::ecore::EReference_ptr AmaltheaPackage::getSWModel__labels()
{
    return m_SWModel__labels;
}
::ecore::EReference_ptr AmaltheaPackage::getSWModel__channels()
{
    return m_SWModel__channels;
}
::ecore::EReference_ptr AmaltheaPackage::getSWModel__processPrototypes()
{
    return m_SWModel__processPrototypes;
}
::ecore::EReference_ptr AmaltheaPackage::getSWModel__sections()
{
    return m_SWModel__sections;
}
::ecore::EReference_ptr AmaltheaPackage::getSWModel__activations()
{
    return m_SWModel__activations;
}
::ecore::EReference_ptr AmaltheaPackage::getSWModel__events()
{
    return m_SWModel__events;
}
::ecore::EReference_ptr AmaltheaPackage::getSWModel__typeDefinitions()
{
    return m_SWModel__typeDefinitions;
}
::ecore::EReference_ptr AmaltheaPackage::getSWModel__customEntities()
{
    return m_SWModel__customEntities;
}
::ecore::EReference_ptr AmaltheaPackage::getSWModel__processChains()
{
    return m_SWModel__processChains;
}
::ecore::EReference_ptr AmaltheaPackage::getSWModel__modes()
{
    return m_SWModel__modes;
}
::ecore::EReference_ptr AmaltheaPackage::getSWModel__modeLabels()
{
    return m_SWModel__modeLabels;
}
::ecore::EReference_ptr AmaltheaPackage::getAbstractMemoryElement__size()
{
    return m_AbstractMemoryElement__size;
}
::ecore::EReference_ptr AmaltheaPackage::getAbstractMemoryElement__mappings()
{
    return m_AbstractMemoryElement__mappings;
}
::ecore::EReference_ptr AmaltheaPackage::getAbstractProcess__referringComponents()
{
    return m_AbstractProcess__referringComponents;
}
::ecore::EAttribute_ptr AmaltheaPackage::getCustomEntity__typeName()
{
    return m_CustomEntity__typeName;
}
::ecore::EReference_ptr AmaltheaPackage::getProcessChain__processes()
{
    return m_ProcessChain__processes;
}
::ecore::EReference_ptr AmaltheaPackage::getProcess__activityGraph()
{
    return m_Process__activityGraph;
}
::ecore::EReference_ptr AmaltheaPackage::getProcess__stimuli()
{
    return m_Process__stimuli;
}
::ecore::EReference_ptr AmaltheaPackage::getIActivityGraphItemContainer__items()
{
    return m_IActivityGraphItemContainer__items;
}
::ecore::EReference_ptr AmaltheaPackage::getActivityGraphItem__containingProcess()
{
    return m_ActivityGraphItem__containingProcess;
}
::ecore::EReference_ptr AmaltheaPackage::getActivityGraphItem__containingRunnable()
{
    return m_ActivityGraphItem__containingRunnable;
}
::ecore::EReference_ptr AmaltheaPackage::getActivityGraphItem__containingActivityGraph()
{
    return m_ActivityGraphItem__containingActivityGraph;
}
::ecore::EReference_ptr AmaltheaPackage::getModeSwitch__entries()
{
    return m_ModeSwitch__entries;
}
::ecore::EReference_ptr AmaltheaPackage::getModeSwitch__defaultEntry()
{
    return m_ModeSwitch__defaultEntry;
}
::ecore::EReference_ptr AmaltheaPackage::getModeSwitchEntry__condition()
{
    return m_ModeSwitchEntry__condition;
}
::ecore::EReference_ptr AmaltheaPackage::getProbabilitySwitch__entries()
{
    return m_ProbabilitySwitch__entries;
}
::ecore::EAttribute_ptr AmaltheaPackage::getProbabilitySwitchEntry__probability()
{
    return m_ProbabilitySwitchEntry__probability;
}
::ecore::EAttribute_ptr AmaltheaPackage::getCounter__prescaler()
{
    return m_Counter__prescaler;
}
::ecore::EAttribute_ptr AmaltheaPackage::getCounter__offset()
{
    return m_Counter__offset;
}
::ecore::EReference_ptr AmaltheaPackage::getWaitEvent__eventMask()
{
    return m_WaitEvent__eventMask;
}
::ecore::EAttribute_ptr AmaltheaPackage::getWaitEvent__maskType()
{
    return m_WaitEvent__maskType;
}
::ecore::EAttribute_ptr AmaltheaPackage::getWaitEvent__waitingBehaviour()
{
    return m_WaitEvent__waitingBehaviour;
}
::ecore::EReference_ptr AmaltheaPackage::getWaitEvent__counter()
{
    return m_WaitEvent__counter;
}
::ecore::EReference_ptr AmaltheaPackage::getSetEvent__eventMask()
{
    return m_SetEvent__eventMask;
}
::ecore::EReference_ptr AmaltheaPackage::getSetEvent__process()
{
    return m_SetEvent__process;
}
::ecore::EReference_ptr AmaltheaPackage::getSetEvent__counter()
{
    return m_SetEvent__counter;
}
::ecore::EReference_ptr AmaltheaPackage::getClearEvent__eventMask()
{
    return m_ClearEvent__eventMask;
}
::ecore::EReference_ptr AmaltheaPackage::getClearEvent__counter()
{
    return m_ClearEvent__counter;
}
::ecore::EReference_ptr AmaltheaPackage::getEventMask__events()
{
    return m_EventMask__events;
}
::ecore::EAttribute_ptr AmaltheaPackage::getOsEvent__communicationOverheadInBit()
{
    return m_OsEvent__communicationOverheadInBit;
}
::ecore::EReference_ptr AmaltheaPackage::getOsEvent__referringComponents()
{
    return m_OsEvent__referringComponents;
}
::ecore::EReference_ptr AmaltheaPackage::getInterProcessTrigger__stimulus()
{
    return m_InterProcessTrigger__stimulus;
}
::ecore::EReference_ptr AmaltheaPackage::getInterProcessTrigger__counter()
{
    return m_InterProcessTrigger__counter;
}
::ecore::EReference_ptr AmaltheaPackage::getEnforcedMigration__resourceOwner()
{
    return m_EnforcedMigration__resourceOwner;
}
::ecore::EReference_ptr AmaltheaPackage::getTerminateProcess__counter()
{
    return m_TerminateProcess__counter;
}
::ecore::EAttribute_ptr AmaltheaPackage::getTask__preemption()
{
    return m_Task__preemption;
}
::ecore::EAttribute_ptr AmaltheaPackage::getTask__multipleTaskActivationLimit()
{
    return m_Task__multipleTaskActivationLimit;
}
::ecore::EAttribute_ptr AmaltheaPackage::getISR__category()
{
    return m_ISR__category;
}
::ecore::EAttribute_ptr AmaltheaPackage::getProcessPrototype__preemption()
{
    return m_ProcessPrototype__preemption;
}
::ecore::EReference_ptr AmaltheaPackage::getProcessPrototype__firstRunnable()
{
    return m_ProcessPrototype__firstRunnable;
}
::ecore::EReference_ptr AmaltheaPackage::getProcessPrototype__lastRunnable()
{
    return m_ProcessPrototype__lastRunnable;
}
::ecore::EReference_ptr AmaltheaPackage::getProcessPrototype__accessPrecedenceSpec()
{
    return m_ProcessPrototype__accessPrecedenceSpec;
}
::ecore::EReference_ptr AmaltheaPackage::getProcessPrototype__orderPrecedenceSpec()
{
    return m_ProcessPrototype__orderPrecedenceSpec;
}
::ecore::EReference_ptr AmaltheaPackage::getProcessPrototype__chainedPrototypes()
{
    return m_ProcessPrototype__chainedPrototypes;
}
::ecore::EReference_ptr AmaltheaPackage::getProcessPrototype__activation()
{
    return m_ProcessPrototype__activation;
}
::ecore::EReference_ptr AmaltheaPackage::getProcessPrototype__runnableCalls()
{
    return m_ProcessPrototype__runnableCalls;
}
::ecore::EReference_ptr AmaltheaPackage::getChainedProcessPrototype__prototype()
{
    return m_ChainedProcessPrototype__prototype;
}
::ecore::EAttribute_ptr AmaltheaPackage::getChainedProcessPrototype__apply()
{
    return m_ChainedProcessPrototype__apply;
}
::ecore::EAttribute_ptr AmaltheaPackage::getChainedProcessPrototype__offset()
{
    return m_ChainedProcessPrototype__offset;
}
::ecore::EReference_ptr AmaltheaPackage::getGeneralPrecedence__origin()
{
    return m_GeneralPrecedence__origin;
}
::ecore::EReference_ptr AmaltheaPackage::getGeneralPrecedence__target()
{
    return m_GeneralPrecedence__target;
}
::ecore::EReference_ptr AmaltheaPackage::getAccessPrecedenceSpec__label()
{
    return m_AccessPrecedenceSpec__label;
}
::ecore::EAttribute_ptr AmaltheaPackage::getAccessPrecedenceSpec__orderType()
{
    return m_AccessPrecedenceSpec__orderType;
}
::ecore::EAttribute_ptr AmaltheaPackage::getOrderPrecedenceSpec__orderType()
{
    return m_OrderPrecedenceSpec__orderType;
}
::ecore::EReference_ptr AmaltheaPackage::getIDependsOn__dependsOn()
{
    return m_IDependsOn__dependsOn;
}
::ecore::EReference_ptr AmaltheaPackage::getDataDependency__labels()
{
    return m_DataDependency__labels;
}
::ecore::EReference_ptr AmaltheaPackage::getDataDependency__parameters()
{
    return m_DataDependency__parameters;
}
::ecore::EReference_ptr AmaltheaPackage::getDataDependency__callArguments()
{
    return m_DataDependency__callArguments;
}
::ecore::EReference_ptr AmaltheaPackage::getDataDependency__containingRunnable()
{
    return m_DataDependency__containingRunnable;
}
::ecore::EReference_ptr AmaltheaPackage::getRunnableParameter__containingRunnable()
{
    return m_RunnableParameter__containingRunnable;
}
::ecore::EAttribute_ptr AmaltheaPackage::getRunnableParameter__direction()
{
    return m_RunnableParameter__direction;
}
::ecore::EReference_ptr AmaltheaPackage::getRunnableParameter__dataType()
{
    return m_RunnableParameter__dataType;
}
::ecore::EReference_ptr AmaltheaPackage::getRunnable__executionCondition()
{
    return m_Runnable__executionCondition;
}
::ecore::EReference_ptr AmaltheaPackage::getRunnable__parameters()
{
    return m_Runnable__parameters;
}
::ecore::EReference_ptr AmaltheaPackage::getRunnable__activityGraph()
{
    return m_Runnable__activityGraph;
}
::ecore::EReference_ptr AmaltheaPackage::getRunnable__activations()
{
    return m_Runnable__activations;
}
::ecore::EAttribute_ptr AmaltheaPackage::getRunnable__callback()
{
    return m_Runnable__callback;
}
::ecore::EAttribute_ptr AmaltheaPackage::getRunnable__service()
{
    return m_Runnable__service;
}
::ecore::EAttribute_ptr AmaltheaPackage::getRunnable__asilLevel()
{
    return m_Runnable__asilLevel;
}
::ecore::EReference_ptr AmaltheaPackage::getRunnable__section()
{
    return m_Runnable__section;
}
::ecore::EReference_ptr AmaltheaPackage::getRunnable__runnableCalls()
{
    return m_Runnable__runnableCalls;
}
::ecore::EReference_ptr AmaltheaPackage::getRunnable__referringComponents()
{
    return m_Runnable__referringComponents;
}
::ecore::EReference_ptr AmaltheaPackage::getLabel__dataType()
{
    return m_Label__dataType;
}
::ecore::EAttribute_ptr AmaltheaPackage::getLabel__constant()
{
    return m_Label__constant;
}
::ecore::EAttribute_ptr AmaltheaPackage::getLabel__bVolatile()
{
    return m_Label__bVolatile;
}
::ecore::EAttribute_ptr AmaltheaPackage::getLabel__dataStability()
{
    return m_Label__dataStability;
}
::ecore::EAttribute_ptr AmaltheaPackage::getLabel__stabilityLevel()
{
    return m_Label__stabilityLevel;
}
::ecore::EReference_ptr AmaltheaPackage::getLabel__section()
{
    return m_Label__section;
}
::ecore::EReference_ptr AmaltheaPackage::getLabel__labelAccesses()
{
    return m_Label__labelAccesses;
}
::ecore::EReference_ptr AmaltheaPackage::getLabel__referringComponents()
{
    return m_Label__referringComponents;
}
::ecore::EReference_ptr AmaltheaPackage::getChannel__elementType()
{
    return m_Channel__elementType;
}
::ecore::EAttribute_ptr AmaltheaPackage::getChannel__defaultElements()
{
    return m_Channel__defaultElements;
}
::ecore::EAttribute_ptr AmaltheaPackage::getChannel__maxElements()
{
    return m_Channel__maxElements;
}
::ecore::EReference_ptr AmaltheaPackage::getChannel__channelAccesses()
{
    return m_Channel__channelAccesses;
}
::ecore::EReference_ptr AmaltheaPackage::getModeLabel__mode()
{
    return m_ModeLabel__mode;
}
::ecore::EAttribute_ptr AmaltheaPackage::getModeLabel__initialValue()
{
    return m_ModeLabel__initialValue;
}
::ecore::EAttribute_ptr AmaltheaPackage::getSection__asilLevel()
{
    return m_Section__asilLevel;
}
::ecore::EReference_ptr AmaltheaPackage::getSection__labels()
{
    return m_Section__labels;
}
::ecore::EReference_ptr AmaltheaPackage::getSection__runnables()
{
    return m_Section__runnables;
}
::ecore::EReference_ptr AmaltheaPackage::getExecutionNeed__needs()
{
    return m_ExecutionNeed__needs;
}
::ecore::EAttribute_ptr AmaltheaPackage::getNeedEntry__key()
{
    return m_NeedEntry__key;
}
::ecore::EReference_ptr AmaltheaPackage::getNeedEntry__value()
{
    return m_NeedEntry__value;
}
::ecore::EReference_ptr AmaltheaPackage::getTicks__default()
{
    return m_Ticks__default;
}
::ecore::EReference_ptr AmaltheaPackage::getTicks__extended()
{
    return m_Ticks__extended;
}
::ecore::EReference_ptr AmaltheaPackage::getTicksEntry__key()
{
    return m_TicksEntry__key;
}
::ecore::EReference_ptr AmaltheaPackage::getTicksEntry__value()
{
    return m_TicksEntry__value;
}
::ecore::EReference_ptr AmaltheaPackage::getModeLabelAccess__data()
{
    return m_ModeLabelAccess__data;
}
::ecore::EAttribute_ptr AmaltheaPackage::getModeLabelAccess__access()
{
    return m_ModeLabelAccess__access;
}
::ecore::EAttribute_ptr AmaltheaPackage::getModeLabelAccess__value()
{
    return m_ModeLabelAccess__value;
}
::ecore::EAttribute_ptr AmaltheaPackage::getModeLabelAccess__step()
{
    return m_ModeLabelAccess__step;
}
::ecore::EReference_ptr AmaltheaPackage::getLabelAccess__data()
{
    return m_LabelAccess__data;
}
::ecore::EAttribute_ptr AmaltheaPackage::getLabelAccess__access()
{
    return m_LabelAccess__access;
}
::ecore::EReference_ptr AmaltheaPackage::getLabelAccess__statistic()
{
    return m_LabelAccess__statistic;
}
::ecore::EReference_ptr AmaltheaPackage::getLabelAccess__transmissionPolicy()
{
    return m_LabelAccess__transmissionPolicy;
}
::ecore::EAttribute_ptr AmaltheaPackage::getLabelAccess__dataStability()
{
    return m_LabelAccess__dataStability;
}
::ecore::EAttribute_ptr AmaltheaPackage::getLabelAccess__implementation()
{
    return m_LabelAccess__implementation;
}
::ecore::EReference_ptr AmaltheaPackage::getChannelAccess__data()
{
    return m_ChannelAccess__data;
}
::ecore::EAttribute_ptr AmaltheaPackage::getChannelAccess__elements()
{
    return m_ChannelAccess__elements;
}
::ecore::EReference_ptr AmaltheaPackage::getChannelAccess__transmissionPolicy()
{
    return m_ChannelAccess__transmissionPolicy;
}
::ecore::EAttribute_ptr AmaltheaPackage::getChannelReceive__receiveOperation()
{
    return m_ChannelReceive__receiveOperation;
}
::ecore::EAttribute_ptr AmaltheaPackage::getChannelReceive__dataMustBeNew()
{
    return m_ChannelReceive__dataMustBeNew;
}
::ecore::EAttribute_ptr AmaltheaPackage::getChannelReceive__elementIndex()
{
    return m_ChannelReceive__elementIndex;
}
::ecore::EAttribute_ptr AmaltheaPackage::getChannelReceive__lowerBound()
{
    return m_ChannelReceive__lowerBound;
}
::ecore::EReference_ptr AmaltheaPackage::getSemaphoreAccess__semaphore()
{
    return m_SemaphoreAccess__semaphore;
}
::ecore::EAttribute_ptr AmaltheaPackage::getSemaphoreAccess__access()
{
    return m_SemaphoreAccess__access;
}
::ecore::EAttribute_ptr AmaltheaPackage::getSemaphoreAccess__waitingBehaviour()
{
    return m_SemaphoreAccess__waitingBehaviour;
}
::ecore::EAttribute_ptr AmaltheaPackage::getSenderReceiverCommunication__buffered()
{
    return m_SenderReceiverCommunication__buffered;
}
::ecore::EReference_ptr AmaltheaPackage::getSenderReceiverCommunication__label()
{
    return m_SenderReceiverCommunication__label;
}
::ecore::EReference_ptr AmaltheaPackage::getSenderReceiverCommunication__port()
{
    return m_SenderReceiverCommunication__port;
}
::ecore::EReference_ptr AmaltheaPackage::getSenderReceiverWrite__notifiedRunnables()
{
    return m_SenderReceiverWrite__notifiedRunnables;
}
::ecore::EReference_ptr AmaltheaPackage::getServerCall__serverRunnable()
{
    return m_ServerCall__serverRunnable;
}
::ecore::EReference_ptr AmaltheaPackage::getServerCall__port()
{
    return m_ServerCall__port;
}
::ecore::EAttribute_ptr AmaltheaPackage::getSynchronousServerCall__waitingBehaviour()
{
    return m_SynchronousServerCall__waitingBehaviour;
}
::ecore::EReference_ptr AmaltheaPackage::getAsynchronousServerCall__resultRunnable()
{
    return m_AsynchronousServerCall__resultRunnable;
}
::ecore::EAttribute_ptr AmaltheaPackage::getGetResultServerCall__blockingType()
{
    return m_GetResultServerCall__blockingType;
}
::ecore::EAttribute_ptr AmaltheaPackage::getGroup__ordered()
{
    return m_Group__ordered;
}
::ecore::EReference_ptr AmaltheaPackage::getCallArgument__containingCall()
{
    return m_CallArgument__containingCall;
}
::ecore::EReference_ptr AmaltheaPackage::getCallArgument__parameter()
{
    return m_CallArgument__parameter;
}
::ecore::EReference_ptr AmaltheaPackage::getRunnableCall__runnable()
{
    return m_RunnableCall__runnable;
}
::ecore::EReference_ptr AmaltheaPackage::getRunnableCall__arguments()
{
    return m_RunnableCall__arguments;
}
::ecore::EReference_ptr AmaltheaPackage::getRunnableCall__counter()
{
    return m_RunnableCall__counter;
}
::ecore::EReference_ptr AmaltheaPackage::getRunnableCall__statistic()
{
    return m_RunnableCall__statistic;
}
::ecore::EReference_ptr AmaltheaPackage::getCustomEventTrigger__event()
{
    return m_CustomEventTrigger__event;
}
::ecore::EReference_ptr AmaltheaPackage::getStruct__entries()
{
    return m_Struct__entries;
}
::ecore::EReference_ptr AmaltheaPackage::getStructEntry__dataType()
{
    return m_StructEntry__dataType;
}
::ecore::EAttribute_ptr AmaltheaPackage::getArray__numberElements()
{
    return m_Array__numberElements;
}
::ecore::EReference_ptr AmaltheaPackage::getArray__dataType()
{
    return m_Array__dataType;
}
::ecore::EReference_ptr AmaltheaPackage::getPointer__dataType()
{
    return m_Pointer__dataType;
}
::ecore::EReference_ptr AmaltheaPackage::getTypeRef__typeDef()
{
    return m_TypeRef__typeDef;
}
::ecore::EAttribute_ptr AmaltheaPackage::getAlias__target()
{
    return m_Alias__target;
}
::ecore::EAttribute_ptr AmaltheaPackage::getAlias__alias()
{
    return m_Alias__alias;
}
::ecore::EReference_ptr AmaltheaPackage::getTypeDefinition__size()
{
    return m_TypeDefinition__size;
}
::ecore::EReference_ptr AmaltheaPackage::getDataTypeDefinition__dataType()
{
    return m_DataTypeDefinition__dataType;
}
::ecore::EReference_ptr AmaltheaPackage::getBaseTypeDefinition__aliases()
{
    return m_BaseTypeDefinition__aliases;
}
::ecore::EReference_ptr AmaltheaPackage::getPeriodicActivation__min()
{
    return m_PeriodicActivation__min;
}
::ecore::EReference_ptr AmaltheaPackage::getPeriodicActivation__max()
{
    return m_PeriodicActivation__max;
}
::ecore::EReference_ptr AmaltheaPackage::getPeriodicActivation__recurrence()
{
    return m_PeriodicActivation__recurrence;
}
::ecore::EReference_ptr AmaltheaPackage::getPeriodicActivation__offset()
{
    return m_PeriodicActivation__offset;
}
::ecore::EReference_ptr AmaltheaPackage::getVariableRateActivation__step()
{
    return m_VariableRateActivation__step;
}
::ecore::EReference_ptr AmaltheaPackage::getVariableRateActivation__occurrencesPerStep()
{
    return m_VariableRateActivation__occurrencesPerStep;
}
::ecore::EReference_ptr AmaltheaPackage::getSporadicActivation__occurrence()
{
    return m_SporadicActivation__occurrence;
}
::ecore::EReference_ptr AmaltheaPackage::getSingleActivation__min()
{
    return m_SingleActivation__min;
}
::ecore::EReference_ptr AmaltheaPackage::getSingleActivation__max()
{
    return m_SingleActivation__max;
}
::ecore::EReference_ptr AmaltheaPackage::getEventActivation__triggeringEvents()
{
    return m_EventActivation__triggeringEvents;
}
::ecore::EReference_ptr AmaltheaPackage::getEventActivation__counter()
{
    return m_EventActivation__counter;
}
::ecore::EReference_ptr AmaltheaPackage::getLabelAccessStatistic__value()
{
    return m_LabelAccessStatistic__value;
}
::ecore::EReference_ptr AmaltheaPackage::getLabelAccessStatistic__cacheMisses()
{
    return m_LabelAccessStatistic__cacheMisses;
}
::ecore::EReference_ptr AmaltheaPackage::getRunEntityCallStatistic__statistic()
{
    return m_RunEntityCallStatistic__statistic;
}

